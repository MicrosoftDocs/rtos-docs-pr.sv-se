---
title: Kapitel 3 – funktionella komponenter i Azure återställnings tider ThreadX
description: Det här kapitlet innehåller en beskrivning av Azure återställnings tider ThreadX-kärnan med höga prestanda från ett funktionellt perspektiv.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: aa66ad392171958e5d2cc765992fd1a9e41250a6
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 03/22/2021
ms.locfileid: "104827372"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx"></a><span data-ttu-id="c756b-103">Kapitel 3 – funktionella komponenter i Azure återställnings tider ThreadX</span><span class="sxs-lookup"><span data-stu-id="c756b-103">Chapter 3 - Functional Components of Azure RTOS ThreadX</span></span>

<span data-ttu-id="c756b-104">Det här kapitlet innehåller en beskrivning av Azure återställnings tider ThreadX-kärnan med höga prestanda från ett funktionellt perspektiv.</span><span class="sxs-lookup"><span data-stu-id="c756b-104">This chapter contains a description of the high-performance Azure RTOS ThreadX kernel from a functional perspective.</span></span> <span data-ttu-id="c756b-105">Varje funktionell komponent presenteras på ett lätt förståeligt sätt.</span><span class="sxs-lookup"><span data-stu-id="c756b-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="c756b-106">Översikt över körning</span><span class="sxs-lookup"><span data-stu-id="c756b-106">Execution Overview</span></span>

<span data-ttu-id="c756b-107">Det finns fyra typer av program körningar i ett ThreadX-program: initiering, tråd körning, avbrotts tjänst rutiner (ISR: er) och program timers.</span><span class="sxs-lookup"><span data-stu-id="c756b-107">There are four types of program execution within a ThreadX application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="c756b-108">Bild 2 visar varje typ av program körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-108">Figure 2 shows each different type of program execution.</span></span> <span data-ttu-id="c756b-109">Mer detaljerad information om var och en av dessa typer finns i följande avsnitt i det här kapitlet.</span><span class="sxs-lookup"><span data-stu-id="c756b-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="c756b-110">Initiering</span><span class="sxs-lookup"><span data-stu-id="c756b-110">Initialization</span></span>

<span data-ttu-id="c756b-111">Som namnet antyder är det här den första typen av program körning i ett ThreadX program.</span><span class="sxs-lookup"><span data-stu-id="c756b-111">As the name implies, this is the first type of program execution in a ThreadX application.</span></span> <span data-ttu-id="c756b-112">Initieringen omfattar all program körning mellan processor återställning och start punkten i *tråden för tråd schemaläggning.*</span><span class="sxs-lookup"><span data-stu-id="c756b-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

### <a name="thread-execution"></a><span data-ttu-id="c756b-113">Tråd körning</span><span class="sxs-lookup"><span data-stu-id="c756b-113">Thread Execution</span></span>

<span data-ttu-id="c756b-114">När initieringen är klar anger ThreadX sin tråd schema slinga.</span><span class="sxs-lookup"><span data-stu-id="c756b-114">After initialization is complete, ThreadX enters its thread scheduling loop.</span></span> <span data-ttu-id="c756b-115">Schemaläggnings slingan söker efter en program tråd som är klar för körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-115">The scheduling loop looks for an application thread ready for execution.</span></span> <span data-ttu-id="c756b-116">När en färdig tråd påträffas, överför ThreadX kontrollen till den.</span><span class="sxs-lookup"><span data-stu-id="c756b-116">When a ready thread is found, ThreadX transfers control to it.</span></span> <span data-ttu-id="c756b-117">När tråden har slutförts (eller en annan tråd med högre prioritet blir klar) överförs körningen tillbaka till tråden för tråd schemaläggning för att hitta nästa högsta prioritets klara tråd.</span><span class="sxs-lookup"><span data-stu-id="c756b-117">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread.</span></span>

<span data-ttu-id="c756b-118">Den här processen för att kontinuerligt köra och schemalägga trådar är den vanligaste typen av program körning i ThreadX-program.</span><span class="sxs-lookup"><span data-stu-id="c756b-118">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX applications.</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="c756b-119">Avbryta service rutiner (ISR)</span><span class="sxs-lookup"><span data-stu-id="c756b-119">Interrupt Service Routines (ISR)</span></span>

<span data-ttu-id="c756b-120">Avbrott är hörn stenen i real tids system.</span><span class="sxs-lookup"><span data-stu-id="c756b-120">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="c756b-121">Utan avbrott är det mycket svårt att svara på ändringar i den externa världen i rimlig tid.</span><span class="sxs-lookup"><span data-stu-id="c756b-121">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="c756b-122">Vid identifiering av ett avbrott sparar processorn viktig information om den aktuella program körningen (vanligt vis i stacken) och överför sedan kontrollen till ett fördefinierat program.</span><span class="sxs-lookup"><span data-stu-id="c756b-122">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="c756b-123">Den här fördefinierade program arean kallas ofta för en avbrotts tjänst rutin.</span><span class="sxs-lookup"><span data-stu-id="c756b-123">This predefined program area is commonly called an Interrupt Service Routine.</span></span> <span data-ttu-id="c756b-124">I de flesta fall uppstår avbrott under tråd körning (eller i tråden för tråd schemaläggning).</span><span class="sxs-lookup"><span data-stu-id="c756b-124">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="c756b-125">Avbrott kan dock också uppstå i en körning av ISR eller en programtimer.</span><span class="sxs-lookup"><span data-stu-id="c756b-125">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

![Typer av program körningar](./media/user-guide/types-program-execution.png)

<span data-ttu-id="c756b-127">**BILD 2. Typer av program körningar**</span><span class="sxs-lookup"><span data-stu-id="c756b-127">**FIGURE 2. Types of Program Execution**</span></span>

### <a name="application-timers"></a><span data-ttu-id="c756b-128">Program timers</span><span class="sxs-lookup"><span data-stu-id="c756b-128">Application Timers</span></span>

<span data-ttu-id="c756b-129">Program timers liknar ISR: er, förutom att maskin varu implementeringen (vanligt vis ett enda periodiskt maskin varu avbrott används) är dold från programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-129">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="c756b-130">Sådana timers används av program för att utföra tids gränser, periodiska och/eller övervaknings tjänster.</span><span class="sxs-lookup"><span data-stu-id="c756b-130">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="c756b-131">Precis som ISR: er har programtimers ofta avbrott för tråd körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-131">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="c756b-132">Till skillnad från ISR: er kan programtimers dock inte avbryta varandra.</span><span class="sxs-lookup"><span data-stu-id="c756b-132">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="c756b-133">Minnesanvändning</span><span class="sxs-lookup"><span data-stu-id="c756b-133">Memory Usage</span></span>

<span data-ttu-id="c756b-134">ThreadX finns tillsammans med program programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-134">ThreadX resides along with the application program.</span></span> <span data-ttu-id="c756b-135">Därför bestäms användningen av statiskt minne (eller fast minne) för ThreadX av utvecklingsverktygen. t. ex. kompilatorn, länkar och lokaliserare.</span><span class="sxs-lookup"><span data-stu-id="c756b-135">As a result, the static memory (or fixed memory) usage of ThreadX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="c756b-136">Användning av dynamiskt minne (eller körnings minne) är direkt kontroll över programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-136">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="c756b-137">Statisk minnes användning</span><span class="sxs-lookup"><span data-stu-id="c756b-137">Static Memory Usage</span></span>

<span data-ttu-id="c756b-138">De flesta av utvecklingsverktygen delar program program avbildningen i fem grundläggande områden: *instruktion*, *konstant*, *initierade data*, oinitierade *data* och *system stack*.</span><span class="sxs-lookup"><span data-stu-id="c756b-138">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="c756b-139">Bild 3 visar ett exempel på dessa minnes områden.</span><span class="sxs-lookup"><span data-stu-id="c756b-139">Figure 3 shows an example of these memory areas.</span></span>

<span data-ttu-id="c756b-140">Det är viktigt att förstå att detta bara är ett exempel.</span><span class="sxs-lookup"><span data-stu-id="c756b-140">It is important to understand that this is only an example.</span></span> <span data-ttu-id="c756b-141">Den faktiska statiska minnesmodulen är specifika för processor, utvecklingsverktyg och den underliggande maskin varan.</span><span class="sxs-lookup"><span data-stu-id="c756b-141">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="c756b-142">Instruktions avsnittet innehåller alla programmets processor instruktioner.</span><span class="sxs-lookup"><span data-stu-id="c756b-142">The instruction area contains all of the program's processor instructions.</span></span> <span data-ttu-id="c756b-143">Det här fältet är vanligt vis det största och finns ofta i ROM.</span><span class="sxs-lookup"><span data-stu-id="c756b-143">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="c756b-144">Det konstanta fältet innehåller olika kompilerade konstanter, inklusive strängar som definierats eller refereras till i programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-144">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="c756b-145">Dessutom innehåller det här avsnittet "ursprunglig kopia" av det initierade data fältet.</span><span class="sxs-lookup"><span data-stu-id="c756b-145">In addition, this area contains the "initial copy" of the initialized data area.</span></span> <span data-ttu-id="c756b-146">Under initierings processen för *minnes användnings* kompilatorn används den här delen av det fasta området för att konfigurera det initierade data området i RAM-minnet.</span><span class="sxs-lookup"><span data-stu-id="c756b-146">During the *Memory Usage* compiler's initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="c756b-147">Det fasta områdena följer vanligt vis instruktions ytan och finns ofta i ROM.</span><span class="sxs-lookup"><span data-stu-id="c756b-147">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="c756b-148">De initierade data och oinitierade data områdena innehåller alla globala och statiska variabler.</span><span class="sxs-lookup"><span data-stu-id="c756b-148">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="c756b-149">Dessa områden finns alltid i RAM-minnet.</span><span class="sxs-lookup"><span data-stu-id="c756b-149">These areas are always located in RAM.</span></span>

<span data-ttu-id="c756b-150">System stacken konfigureras vanligt vis direkt efter de initierade och oinitierade data områdena.</span><span class="sxs-lookup"><span data-stu-id="c756b-150">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span>

<span data-ttu-id="c756b-151">System stacken används av kompilatorn vid initieringen, sedan av ThreadX under initieringen och senare i ISR-bearbetning.</span><span class="sxs-lookup"><span data-stu-id="c756b-151">The system stack is used by the compiler during initialization, then by ThreadX during initialization and, subsequently, in ISR processing.</span></span>

![Exempel på minnes området](./media/user-guide/memory-area-example.png)

<span data-ttu-id="c756b-153">**BILD 3. Exempel på minnes området**</span><span class="sxs-lookup"><span data-stu-id="c756b-153">**FIGURE 3. Memory Area Example**</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="c756b-154">dynamiskt minne användning</span><span class="sxs-lookup"><span data-stu-id="c756b-154">Dynamic Memory Usage</span></span>

<span data-ttu-id="c756b-155">Som tidigare nämnts är dynamisk minnes användning direkt kontroll av programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-155">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="c756b-156">Kontroll block och minnes områden som är kopplade till stackar, köer och lagringspooler kan placeras var som helst i målets minnes utrymme.</span><span class="sxs-lookup"><span data-stu-id="c756b-156">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target's memory space.</span></span> <span data-ttu-id="c756b-157">Detta är en viktig funktion eftersom den underlättar användningen av olika typer av fysiskt minne.</span><span class="sxs-lookup"><span data-stu-id="c756b-157">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="c756b-158">Anta till exempel att en mål maskin varu miljö har både snabbt minne och långsamt minne.</span><span class="sxs-lookup"><span data-stu-id="c756b-158">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="c756b-159">Om programmet behöver extra prestanda för en tråd med hög prioritet kan kontroll blocket (TX_THREAD) och stacken placeras i det snabba minnes området, vilket kan förbättra dess prestanda avsevärt.</span><span class="sxs-lookup"><span data-stu-id="c756b-159">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="c756b-160">Initiering</span><span class="sxs-lookup"><span data-stu-id="c756b-160">Initialization</span></span>

<span data-ttu-id="c756b-161">Det är viktigt att förstå initierings processen.</span><span class="sxs-lookup"><span data-stu-id="c756b-161">Understanding the initialization process is important.</span></span> <span data-ttu-id="c756b-162">Den första maskin varu miljön konfigureras här.</span><span class="sxs-lookup"><span data-stu-id="c756b-162">The initial hardware environment is set up here.</span></span> <span data-ttu-id="c756b-163">Det är dessutom där programmet får sin initiala personlighet.</span><span class="sxs-lookup"><span data-stu-id="c756b-163">In addition, this is where the application is given its initial personality.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-164">*ThreadX försöker använda (närhelst det är möjligt) för det fullständiga utvecklings verktygets initierings process. Detta gör det enklare att uppgradera till nya versioner av utvecklingsverktyg i framtiden.*</span><span class="sxs-lookup"><span data-stu-id="c756b-164">*ThreadX attempts to utilize (whenever possible) the complete development tool's initialization process. This makes it easier to upgrade to new versions of the development tools in the future.*</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="c756b-165">System återställning, Vector</span><span class="sxs-lookup"><span data-stu-id="c756b-165">System Reset Vector</span></span>

<span data-ttu-id="c756b-166">Alla mikroprocessorer har återställnings logik.</span><span class="sxs-lookup"><span data-stu-id="c756b-166">All microprocessors have reset logic.</span></span> <span data-ttu-id="c756b-167">När en återställning sker (antingen maskin-eller program vara) hämtas adressen till programmets start punkt från en specifik minnes plats.</span><span class="sxs-lookup"><span data-stu-id="c756b-167">When a reset occurs (either hardware or software), the address of the application's entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="c756b-168">När Start punkten har hämtats, överför processorn kontrollen till den platsen.</span><span class="sxs-lookup"><span data-stu-id="c756b-168">After the entry point is retrieved, the processor transfers control to that location.</span></span> <span data-ttu-id="c756b-169">Program start punkten skrivs vanligt vis på det inbyggda sammansättnings språket och tillhandahålls vanligt vis av utvecklingsverktyg (i minst mall-formulär).</span><span class="sxs-lookup"><span data-stu-id="c756b-169">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="c756b-170">I vissa fall medföljer en special version av Entry-programmet med ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-170">In some cases, a special version of the entry program is supplied with ThreadX.</span></span>

### <a name="development-tool-initialization"></a><span data-ttu-id="c756b-171">Initiering av utvecklingsverktyg</span><span class="sxs-lookup"><span data-stu-id="c756b-171">Development Tool Initialization</span></span>

<span data-ttu-id="c756b-172">När den lågnivå initieringen är klar styr du överföring till utvecklings verktygets övergripande initierings nivå.</span><span class="sxs-lookup"><span data-stu-id="c756b-172">After the low-level initialization is complete, control transfers to the development tool's high-level initialization.</span></span> <span data-ttu-id="c756b-173">Detta är vanligt vis den plats där initierade globala och statiska C-variabler konfigureras.</span><span class="sxs-lookup"><span data-stu-id="c756b-173">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="c756b-174">Kom ihåg att de ursprungliga värdena hämtas från det fasta nätverket.</span><span class="sxs-lookup"><span data-stu-id="c756b-174">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="c756b-175">Den exakta initierings bearbetningen är en specifika utvecklingsverktyg.</span><span class="sxs-lookup"><span data-stu-id="c756b-175">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="c756b-176">huvud funktion</span><span class="sxs-lookup"><span data-stu-id="c756b-176">main Function</span></span>

<span data-ttu-id="c756b-177">När distributions verktygets initiering är klar styr du överföring till den användare som anges av *huvud* funktionen.</span><span class="sxs-lookup"><span data-stu-id="c756b-177">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="c756b-178">I det här läget styr programmet vad som händer härnäst.</span><span class="sxs-lookup"><span data-stu-id="c756b-178">At this point, the application controls what happens next.</span></span> <span data-ttu-id="c756b-179">För de flesta program anropar main-funktionen bara *tx_kernel_enter*, som är posten i ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-179">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX.</span></span> <span data-ttu-id="c756b-180">Program kan dock utföra förberedande bearbetning (vanligt vis för maskin varu initiering) innan du anger ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-180">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-181">*Anropet till tx_kernel_enter returnerar inte, så placera ingen bearbetning efter det.*</span><span class="sxs-lookup"><span data-stu-id="c756b-181">*The call to tx_kernel_enter does not return, so do not place any processing after it.*</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="c756b-182">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="c756b-182">tx_kernel_enter</span></span>

<span data-ttu-id="c756b-183">Funktionen post samordnar initiering av olika interna ThreadX-datastrukturer och anropar sedan programmets definitions funktion ***tx_application_define***.</span><span class="sxs-lookup"><span data-stu-id="c756b-183">The entry function coordinates initialization of various internal ThreadX data structures and then calls the application's definition function ***tx_application_define***.</span></span>

<span data-ttu-id="c756b-184">När ***tx_application_define*** returnerar överförs kontrollen till tråd schema slingan.</span><span class="sxs-lookup"><span data-stu-id="c756b-184">When ***tx_application_define*** returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="c756b-185">Detta markerar slutet av initieringen.</span><span class="sxs-lookup"><span data-stu-id="c756b-185">This marks the end of initialization.</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="c756b-186">Program definitions funktion</span><span class="sxs-lookup"><span data-stu-id="c756b-186">Application Definition Function</span></span>

<span data-ttu-id="c756b-187">Funktionen ***tx_application_define*** definierar alla inledande program trådar, köer, semaforer, mutexer, händelse flaggor, minnesmoduler och timers.</span><span class="sxs-lookup"><span data-stu-id="c756b-187">The ***tx_application_define*** function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="c756b-188">Det är också möjligt att skapa och ta bort system resurser från trådar under normal användning av programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-188">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="c756b-189">Alla inledande program resurser definieras dock här.</span><span class="sxs-lookup"><span data-stu-id="c756b-189">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="c756b-190">Funktionen \***tx_application_define** _ har en enda indataparameter och det är värt att nämna.</span><span class="sxs-lookup"><span data-stu-id="c756b-190">The \***tx_application_define** _ function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="c756b-191">Den _first tillgängliga \* RAM-adressen är den enda Indataparametern till den här funktionen.</span><span class="sxs-lookup"><span data-stu-id="c756b-191">The _first-available\* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="c756b-192">Den används vanligt vis som utgångs punkt för inledande minnes tilldelning för körning av tråds tackor, köer och lagringspooler.</span><span class="sxs-lookup"><span data-stu-id="c756b-192">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-193">*När initieringen är klar kan endast en exekverande tråd skapa och ta bort system resurser, inklusive andra trådar. Därför måste du skapa minst en tråd under initieringen.*</span><span class="sxs-lookup"><span data-stu-id="c756b-193">*After initialization is complete, only an executing thread can create and delete system resources— including other threads. Therefore, at least one thread must be created during initialization.*</span></span>

### <a name="interrupts"></a><span data-ttu-id="c756b-194">Avbrott</span><span class="sxs-lookup"><span data-stu-id="c756b-194">Interrupts</span></span>

<span data-ttu-id="c756b-195">Avbrott lämnas inaktiverade under hela initierings processen.</span><span class="sxs-lookup"><span data-stu-id="c756b-195">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="c756b-196">Om programmet på något sätt aktiverar avbrott kan oförutsägbart beteende uppstå.</span><span class="sxs-lookup"><span data-stu-id="c756b-196">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="c756b-197">Bild 4 visar hela initierings processen, från system återställning genom programspecifik initiering.</span><span class="sxs-lookup"><span data-stu-id="c756b-197">Figure 4 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="c756b-198">Tråd körning</span><span class="sxs-lookup"><span data-stu-id="c756b-198">Thread Execution</span></span>

<span data-ttu-id="c756b-199">Schemaläggning och körning av program trådar är den viktigaste aktiviteten i ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-199">Scheduling and executing application threads is the most important activity of ThreadX.</span></span> <span data-ttu-id="c756b-200">En tråd definieras vanligt vis som ett halv oberoende program segment med ett dedikerat syfte.</span><span class="sxs-lookup"><span data-stu-id="c756b-200">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="c756b-201">Den kombinerade bearbetningen av alla trådar gör ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-201">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="c756b-202">Trådar skapas dynamiskt genom att anropa \***tx_thread_create** _ under initiering eller under tråd körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-202">Threads are created dynamically by calling \***tx_thread_create** _ during initialization or during thread execution.</span></span> <span data-ttu-id="c756b-203">Trådar skapas antingen i ett _ready \* eller i *pausat* läge.</span><span class="sxs-lookup"><span data-stu-id="c756b-203">Threads are created in either a _ready\* or *suspended* state.</span></span>

![Initierings process](./media/user-guide/initialization-process.png)

<span data-ttu-id="c756b-205">**BILD 4. Initierings process**</span><span class="sxs-lookup"><span data-stu-id="c756b-205">**FIGURE 4. Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="c756b-206">Tråd körnings tillstånd</span><span class="sxs-lookup"><span data-stu-id="c756b-206">Thread Execution States</span></span>

<span data-ttu-id="c756b-207">Att förstå olika bearbetnings tillstånd för trådar är en viktig ingrediens för att förstå hela den flertrådade miljön.</span><span class="sxs-lookup"><span data-stu-id="c756b-207">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="c756b-208">I ThreadX finns det fem olika tråd tillstånd: *redo*, *pausad*, *körning*, *avslutad* och *slutförd*.</span><span class="sxs-lookup"><span data-stu-id="c756b-208">In ThreadX there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="c756b-209">Bild 5 visar över gångs diagrammet för tråd tillstånd för ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-209">Figure 5 shows the thread state transition diagram for ThreadX.</span></span>

![Över gång av tråd tillstånd](./media/user-guide/thread-state-transition.png)

<span data-ttu-id="c756b-211">**BILD 5. Över gång av tråd tillstånd**</span><span class="sxs-lookup"><span data-stu-id="c756b-211">**FIGURE 5. Thread State Transition**</span></span>

<span data-ttu-id="c756b-212">En tråd är i ett *klart* tillstånd när det är klart att köras.</span><span class="sxs-lookup"><span data-stu-id="c756b-212">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="c756b-213">En färdig tråd körs inte förrän den har den högsta prioritets tråden i klart läge.</span><span class="sxs-lookup"><span data-stu-id="c756b-213">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="c756b-214">När detta inträffar kör ThreadX tråden, som sedan ändrar dess tillstånd till att *köra*.</span><span class="sxs-lookup"><span data-stu-id="c756b-214">When this happens, ThreadX executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="c756b-215">Om en tråd med högre prioritet blir klar återgår den exekverande tråden tillbaka till ett *klart* tillstånd.</span><span class="sxs-lookup"><span data-stu-id="c756b-215">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="c756b-216">Den nyligen färdiga tråden med hög prioritet körs sedan, vilket ändrar det logiska läget till att *köra*.</span><span class="sxs-lookup"><span data-stu-id="c756b-216">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="c756b-217">Den här över gången mellan *färdiga* och *pågående* tillstånd sker varje gång tråden avstängningen inträffar.</span><span class="sxs-lookup"><span data-stu-id="c756b-217">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="c756b-218">Vid ett givet tillfälle är bara en tråd i ett *körnings* tillstånd.</span><span class="sxs-lookup"><span data-stu-id="c756b-218">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="c756b-219">Detta beror på att en tråd i *körnings* tillstånd har kontroll över den underliggande processorn.</span><span class="sxs-lookup"><span data-stu-id="c756b-219">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="c756b-220">Trådar i tillståndet *Suspended* är inte tillgängliga för körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-220">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="c756b-221">Orsaker för att vara i *pausat* tillstånd är att skjuta upp tid, köa meddelanden, semaforer, mutexer, händelse flaggor, minne och Basic Thread SUS pension.</span><span class="sxs-lookup"><span data-stu-id="c756b-221">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="c756b-222">När orsaken till avstängningen har tagits bort placeras tråden i ett *klart* tillstånd.</span><span class="sxs-lookup"><span data-stu-id="c756b-222">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="c756b-223">En tråd i ett *slutfört* tillstånd är en tråd som har slutfört bearbetningen och returnerats från inmatnings funktionen.</span><span class="sxs-lookup"><span data-stu-id="c756b-223">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="c756b-224">Funktionen Entry anges när trådar skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-224">The entry function is specified during thread creation.</span></span> <span data-ttu-id="c756b-225">En tråd i ett *slutfört* tillstånd kan inte köras igen.</span><span class="sxs-lookup"><span data-stu-id="c756b-225">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="c756b-226">En tråd är i ett *avslutat* tillstånd eftersom en annan tråd eller själva tråden anropade tjänsten *tx_thread_terminate* .</span><span class="sxs-lookup"><span data-stu-id="c756b-226">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="c756b-227">En tråd i ett *avslutat* tillstånd kan inte köras igen.</span><span class="sxs-lookup"><span data-stu-id="c756b-227">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-228">*Om du vill starta om en slutförd eller avslutad tråd måste du först ta bort tråden. Den kan sedan skapas på nytt och startas om.*</span><span class="sxs-lookup"><span data-stu-id="c756b-228">*If re-starting a completed or terminated thread is desired, the application must first delete the thread. It can then be re-created and re-started.*</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="c756b-229">Avisering om tråd post/avslutning</span><span class="sxs-lookup"><span data-stu-id="c756b-229">Thread Entry/Exit Notification</span></span>

<span data-ttu-id="c756b-230">Vissa program kan vara fördelaktiga att meddelas när en viss tråd anges för första gången när den är klar eller avslutas.</span><span class="sxs-lookup"><span data-stu-id="c756b-230">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="c756b-231">ThreadX tillhandahåller den här funktionen genom ***tx_thread_entry_exit_notifys*** tjänsten.</span><span class="sxs-lookup"><span data-stu-id="c756b-231">ThreadX provides this ability through the ***tx_thread_entry_exit_notify*** service.</span></span> <span data-ttu-id="c756b-232">Den här tjänsten registrerar en program meddelande funktion för en specifik tråd, som anropas av ThreadX när tråden börjar köras, slutförs eller avbryts.</span><span class="sxs-lookup"><span data-stu-id="c756b-232">This service registers an application notification function for a specific thread, which is called by ThreadX whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="c756b-233">Efter att ha anropats kan program meddelande funktionen utföra programspecifik bearbetning.</span><span class="sxs-lookup"><span data-stu-id="c756b-233">After being invoked, the application notification function can perform the application-specific processing.</span></span> <span data-ttu-id="c756b-234">Det innebär vanligt vis att informerar en annan program tråd för händelsen via en primitiv ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-234">This typically involves informing another application thread of the event via a ThreadX synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="c756b-235">Tråd prioriteter</span><span class="sxs-lookup"><span data-stu-id="c756b-235">Thread Priorities</span></span>

<span data-ttu-id="c756b-236">Som tidigare nämnts är en tråd ett halv oberoende program segment med ett dedikerat syfte.</span><span class="sxs-lookup"><span data-stu-id="c756b-236">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="c756b-237">Alla trådar skapas dock inte lika!</span><span class="sxs-lookup"><span data-stu-id="c756b-237">However, all threads are not created equal!</span></span> <span data-ttu-id="c756b-238">Det dedikerade syftet med vissa trådar är mycket viktigare än andra.</span><span class="sxs-lookup"><span data-stu-id="c756b-238">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="c756b-239">Den här heterogena typen av tråd prioritet är en Hallmark inbäddade real tids program.</span><span class="sxs-lookup"><span data-stu-id="c756b-239">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="c756b-240">ThreadX avgör en tråds betydelse när tråden skapas genom att tilldela ett numeriskt värde som representerar dess *prioritet*.</span><span class="sxs-lookup"><span data-stu-id="c756b-240">ThreadX determines a thread's importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="c756b-241">Det maximala antalet ThreadX-prioriteter kan konfigureras från 32 till 1024 i steg om 32.</span><span class="sxs-lookup"><span data-stu-id="c756b-241">The maximum number of ThreadX priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="c756b-242">Det faktiska maximala antalet prioriteringar bestäms av **TX_MAX_PRIORITIES** konstant vid kompilering av ThreadX-biblioteket.</span><span class="sxs-lookup"><span data-stu-id="c756b-242">The actual maximum number of priorities is determined by the **TX_MAX_PRIORITIES** constant during compilation of the ThreadX library.</span></span> <span data-ttu-id="c756b-243">Om du har ett större antal prioriteter ökar inte bearbetnings kostnaderna avsevärt.</span><span class="sxs-lookup"><span data-stu-id="c756b-243">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="c756b-244">För varje grupp med 32 prioritets nivåer krävs dock ytterligare 128 byte RAM-minne för att hantera dem.</span><span class="sxs-lookup"><span data-stu-id="c756b-244">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="c756b-245">Till exempel kräver 32 prioritets nivåer 128 byte RAM, 64 prioritets nivåer kräver 256 byte RAM-minne, och prioritets nivåer för 96 kräver 384 byte RAM.</span><span class="sxs-lookup"><span data-stu-id="c756b-245">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="c756b-246">Som standard har ThreadX 32 prioritets nivåer, från 0 till prioritet 31.</span><span class="sxs-lookup"><span data-stu-id="c756b-246">By default, ThreadX has 32 priority levels, ranging from priority 0 through priority 31.</span></span> <span data-ttu-id="c756b-247">Numeriska mindre värden innebär högre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-247">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="c756b-248">Prioritet 0 visar alltså högst prioritet, medan prioritet (**TX_MAX_PRIORITIES**-1) representerar den lägsta prioriteten.</span><span class="sxs-lookup"><span data-stu-id="c756b-248">Hence, priority 0 represents the highest priority, while priority (**TX_MAX_PRIORITIES**-1) represents the lowest priority.</span></span>

<span data-ttu-id="c756b-249">Flera trådar kan ha samma prioritet som förlitar sig på samarbets schemaläggning eller tids segmentering.</span><span class="sxs-lookup"><span data-stu-id="c756b-249">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="c756b-250">Dessutom kan tråd prioriteter ändras under körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-250">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="c756b-251">Tråd schemaläggning</span><span class="sxs-lookup"><span data-stu-id="c756b-251">Thread Scheduling</span></span>

<span data-ttu-id="c756b-252">ThreadX schemalägger trådar utifrån deras prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-252">ThreadX schedules threads based on their priority.</span></span> <span data-ttu-id="c756b-253">Den färdiga tråden med den högsta prioriteten körs först.</span><span class="sxs-lookup"><span data-stu-id="c756b-253">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="c756b-254">Om flera trådar av samma prioritet är klara, körs de i ett första- *först-ut-* (FIFO)-sätt.</span><span class="sxs-lookup"><span data-stu-id="c756b-254">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="c756b-255">Round Robin-schemaläggning</span><span class="sxs-lookup"><span data-stu-id="c756b-255">Round-robin Scheduling</span></span>

<span data-ttu-id="c756b-256">ThreadX stöder schemaläggning med *resursallokering* för flera trådar med samma prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-256">ThreadX supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="c756b-257">Detta åstadkoms genom samarbets anrop till \***tx_thread_relinquish** _.</span><span class="sxs-lookup"><span data-stu-id="c756b-257">This is accomplished through cooperative calls to \***tx_thread_relinquish** _.</span></span> <span data-ttu-id="c756b-258">Den här tjänsten ger alla andra redo trådar av samma prioritet en chans att köra innan _ *_tx_thread_relinquish_*\* anroparen körs igen.</span><span class="sxs-lookup"><span data-stu-id="c756b-258">This service gives all other ready threads of the same priority a chance to execute before the _ *_tx_thread_relinquish_*\* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="c756b-259">Time-Slicing</span><span class="sxs-lookup"><span data-stu-id="c756b-259">Time-Slicing</span></span>

<span data-ttu-id="c756b-260">*Tids segmentering* är en annan form av resursallokering-schemaläggning.</span><span class="sxs-lookup"><span data-stu-id="c756b-260">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="c756b-261">Ett Time-slice anger det maximala antalet timer-Tick (timer-avbrott) som en tråd kan köras utan att processorn upprättas.</span><span class="sxs-lookup"><span data-stu-id="c756b-261">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="c756b-262">I ThreadX är tids segmentering tillgänglig per tråd.</span><span class="sxs-lookup"><span data-stu-id="c756b-262">In ThreadX, time-slicing is available on a per-thread basis.</span></span> <span data-ttu-id="c756b-263">Trådens tid-slice tilldelas när den skapas och kan ändras under körningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-263">The thread's time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="c756b-264">När en Time-slice går ut får alla andra redo trådar med samma prioritets nivå möjlighet att köra innan den tidssegmenterade tråden körs igen.</span><span class="sxs-lookup"><span data-stu-id="c756b-264">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="c756b-265">En ny tråd-till-tråd-slice tilldelas en tråd när den har pausats, gör ett ThreadX tjänst anrop som gör att avstängningen eller är i sig själv att vara segmenterad.</span><span class="sxs-lookup"><span data-stu-id="c756b-265">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX service call that causes preemption, or is itself time-sliced.</span></span>

<span data-ttu-id="c756b-266">När en tid-segmenterad tråd avbryts, återupptas den innan andra redo trådar med samma prioritet för resten av dess tids sektor.</span><span class="sxs-lookup"><span data-stu-id="c756b-266">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-267">*Om du använder tids segmentering blir det en liten del av systemets kostnader. Eftersom tids segmentering bara är användbart i fall där flera trådar delar samma prioritet, ska trådar som har en unik prioritet inte tilldelas en tid-sektor.*</span><span class="sxs-lookup"><span data-stu-id="c756b-267">*Using time-slicing results in a slight amount of system overhead. Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.*</span></span>

### <a name="preemption"></a><span data-ttu-id="c756b-268">Avstängningen</span><span class="sxs-lookup"><span data-stu-id="c756b-268">Preemption</span></span>

<span data-ttu-id="c756b-269">Avstängningen är processen för att tillfälligt avbryta en körnings tråd för en tråd med högre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-269">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="c756b-270">Den här processen är osynlig för körnings tråden.</span><span class="sxs-lookup"><span data-stu-id="c756b-270">This process is invisible to the executing thread.</span></span> <span data-ttu-id="c756b-271">När tråden med högre prioritet har slutförts överförs kontrollen tillbaka till den exakta platsen där avstängningen ägde rum.</span><span class="sxs-lookup"><span data-stu-id="c756b-271">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span> <span data-ttu-id="c756b-272">Det här är en mycket viktig funktion i real tids system, eftersom det underlättar snabba svar på viktiga program händelser.</span><span class="sxs-lookup"><span data-stu-id="c756b-272">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="c756b-273">Även om det finns en mycket viktig funktion kan avstängningen också vara en källa till en mängd olika problem, inklusive effekter, överbelastning och prioritets version.</span><span class="sxs-lookup"><span data-stu-id="c756b-273">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-thresholdtrade"></a><span data-ttu-id="c756b-274">Avstängningen tröskel&trade;</span><span class="sxs-lookup"><span data-stu-id="c756b-274">Preemption Threshold&trade;</span></span>

<span data-ttu-id="c756b-275">För att under lätta för några av de avstängningena problemen ger ThreadX en unik och avancerad funktion som kallas *avstängningen-tröskel*.</span><span class="sxs-lookup"><span data-stu-id="c756b-275">To ease some of the inherent problems of preemption, ThreadX provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="c756b-276">Ett avstängningen-tröskelvärde gör det möjligt för en tråd att ange ett prioritets *tak* för inaktive ring av avstängningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-276">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="c756b-277">Trådar som har högre prioritet än taket är fortfarande tillåtna till preempt, medan dessa mindre än taket inte tillåts i preempt.</span><span class="sxs-lookup"><span data-stu-id="c756b-277">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="c756b-278">Anta till exempel att en tråd med prioritet 20 bara interagerar med en grupp trådar som har prioriteringar mellan 15 och 20.</span><span class="sxs-lookup"><span data-stu-id="c756b-278">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="c756b-279">Under dess kritiska delar kan Trådens prioritet 20 ange dess avstängningen-tröskelvärde till 15, vilket hindrar avstängningen från alla trådar som den interagerar med.</span><span class="sxs-lookup"><span data-stu-id="c756b-279">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="c756b-280">Detta tillåter fortfarande viktiga trådar (prioriteringar mellan 0 och 14) för att åsidosätta den här tråden under dess kritiska sektions bearbetning, vilket resulterar i mycket mer besvarad bearbetning.</span><span class="sxs-lookup"><span data-stu-id="c756b-280">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="c756b-281">Naturligtvis är det fortfarande möjligt för en tråd att inaktivera alla avstängningen genom att ange dess avstängningen-tröskelvärde till 0.</span><span class="sxs-lookup"><span data-stu-id="c756b-281">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="c756b-282">Dessutom kan avstängningen-tröskelvärdet ändras under körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-282">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-283">*Om du använder avstängningen-tröskelvärdet inaktive ras tids segmentering för den angivna tråden.*</span><span class="sxs-lookup"><span data-stu-id="c756b-283">*Using preemption-threshold disables time-slicing for the specified thread.*</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="c756b-284">Prioritera arv</span><span class="sxs-lookup"><span data-stu-id="c756b-284">Priority Inheritance</span></span>

<span data-ttu-id="c756b-285">ThreadX stöder även arv av valfria prioritet inom sina mutex-tjänster som beskrivs senare i det här kapitlet.</span><span class="sxs-lookup"><span data-stu-id="c756b-285">ThreadX also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="c756b-286">Med prioriterad arv kan en tråd med lägre prioritet tillfälligt anta prioriteten för en tråd med hög prioritet som väntar på en mutex som ägs av tråden med lägre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-286">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="c756b-287">Den här funktionen hjälper programmet att undvika icke-deterministiska prioritets versioner genom att eliminera avstängningen av mellanliggande tråd prioriteringar.</span><span class="sxs-lookup"><span data-stu-id="c756b-287">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="c756b-288">Naturligtvis kan *avstängningen-tröskelvärdet* användas för att uppnå ett liknande resultat.</span><span class="sxs-lookup"><span data-stu-id="c756b-288">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="c756b-289">Skapa tråd</span><span class="sxs-lookup"><span data-stu-id="c756b-289">Thread Creation</span></span>

<span data-ttu-id="c756b-290">Program trådar skapas vid initiering eller vid körning av andra program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-290">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="c756b-291">Det finns ingen gräns för antalet trådar som kan skapas av ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-291">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="c756b-292">Tråd kontroll block TX_THREAD</span><span class="sxs-lookup"><span data-stu-id="c756b-292">Thread Control Block TX_THREAD</span></span>

<span data-ttu-id="c756b-293">Egenskaperna för varje tråd finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-293">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="c756b-294">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-294">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-295">En tråds kontroll block kan finnas var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-295">A thread's control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="c756b-296">Att hitta kontroll blocket i andra områden kräver lite mer omsorg, precis som allt dynamiskt allokerat minne.</span><span class="sxs-lookup"><span data-stu-id="c756b-296">Locating the control block in other areas requires a bit more care, just like all dynamically-allocated memory.</span></span> <span data-ttu-id="c756b-297">Om ett kontroll block tilldelas i en C-funktion är det minne som är associerat med det en del av den anropande trådens stack.</span><span class="sxs-lookup"><span data-stu-id="c756b-297">If a control block is allocated within a C function, the memory associated with it is part of the calling thread's stack.</span></span> <span data-ttu-id="c756b-298">I allmänhet bör du undvika att använda lokal lagring för kontroll block eftersom när funktionen returnerar, så släpps hela det lokala variabel stack utrymmet – oavsett om en annan tråd använder den för ett kontroll block.</span><span class="sxs-lookup"><span data-stu-id="c756b-298">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block.</span></span>

<span data-ttu-id="c756b-299">I de flesta fall är programmet Oblivious till innehållet i trådens kontroll block.</span><span class="sxs-lookup"><span data-stu-id="c756b-299">In most cases, the application is oblivious to the contents of the thread's control block.</span></span> <span data-ttu-id="c756b-300">Det finns dock vissa situationer, särskilt under fel sökning, där det är praktiskt att titta på vissa medlemmar.</span><span class="sxs-lookup"><span data-stu-id="c756b-300">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="c756b-301">Följande är några av de mer användbara kontroll block medlemmarna.</span><span class="sxs-lookup"><span data-stu-id="c756b-301">The following are some of the more useful control block members.</span></span>

<span data-ttu-id="c756b-302">**tx_thread_run_count** innehåller en räknare för antalet gånger som tråden har schemalagts.</span><span class="sxs-lookup"><span data-stu-id="c756b-302">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="c756b-303">En ökande räknare anger att tråden schemaläggs och körs.</span><span class="sxs-lookup"><span data-stu-id="c756b-303">An increasing counter indicates the thread is being scheduled and executed.</span></span>

<span data-ttu-id="c756b-304">**tx_thread_state** innehåller den associerade Trådens tillstånd.</span><span class="sxs-lookup"><span data-stu-id="c756b-304">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="c756b-305">Nedan visas de möjliga tråd tillstånden.</span><span class="sxs-lookup"><span data-stu-id="c756b-305">The following lists the possible thread states.</span></span>

|  <span data-ttu-id="c756b-306">Tråd tillstånd</span><span class="sxs-lookup"><span data-stu-id="c756b-306">Thread state</span></span>   | <span data-ttu-id="c756b-307">Värde</span><span class="sxs-lookup"><span data-stu-id="c756b-307">Value</span></span> |
| --------------- | ------ |
| <span data-ttu-id="c756b-308">TX_READY</span><span class="sxs-lookup"><span data-stu-id="c756b-308">TX_READY</span></span>       | <span data-ttu-id="c756b-309">0x00</span><span class="sxs-lookup"><span data-stu-id="c756b-309">(0x00)</span></span> |
| <span data-ttu-id="c756b-310">TX_COMPLETED</span><span class="sxs-lookup"><span data-stu-id="c756b-310">TX_COMPLETED</span></span>   | <span data-ttu-id="c756b-311">0x01</span><span class="sxs-lookup"><span data-stu-id="c756b-311">(0x01)</span></span> |
| <span data-ttu-id="c756b-312">TX_TERMINATED</span><span class="sxs-lookup"><span data-stu-id="c756b-312">TX_TERMINATED</span></span>  | <span data-ttu-id="c756b-313">protokollnumret 0x02</span><span class="sxs-lookup"><span data-stu-id="c756b-313">(0x02)</span></span> |
| <span data-ttu-id="c756b-314">TX_SUSPENDED</span><span class="sxs-lookup"><span data-stu-id="c756b-314">TX_SUSPENDED</span></span>   | <span data-ttu-id="c756b-315">(0x03)</span><span class="sxs-lookup"><span data-stu-id="c756b-315">(0x03)</span></span> |
| <span data-ttu-id="c756b-316">TX_SLEEP</span><span class="sxs-lookup"><span data-stu-id="c756b-316">TX_SLEEP</span></span>       | <span data-ttu-id="c756b-317">(0x04)</span><span class="sxs-lookup"><span data-stu-id="c756b-317">(0x04)</span></span> |
| <span data-ttu-id="c756b-318">TX_QUEUE_SUSP</span><span class="sxs-lookup"><span data-stu-id="c756b-318">TX_QUEUE_SUSP</span></span> | <span data-ttu-id="c756b-319">(0x05)</span><span class="sxs-lookup"><span data-stu-id="c756b-319">(0x05)</span></span> |
| <span data-ttu-id="c756b-320">TX_SEMAPHORE_SUSP</span><span class="sxs-lookup"><span data-stu-id="c756b-320">TX_SEMAPHORE_SUSP</span></span> | <span data-ttu-id="c756b-321">(0x06)</span><span class="sxs-lookup"><span data-stu-id="c756b-321">(0x06)</span></span> |
| <span data-ttu-id="c756b-322">TX_EVENT_FLAG</span><span class="sxs-lookup"><span data-stu-id="c756b-322">TX_EVENT_FLAG</span></span>   | <span data-ttu-id="c756b-323">(0x07)</span><span class="sxs-lookup"><span data-stu-id="c756b-323">(0x07)</span></span> |
| <span data-ttu-id="c756b-324">TX_BLOCK_MEMORY</span><span class="sxs-lookup"><span data-stu-id="c756b-324">TX_BLOCK_MEMORY</span></span> | <span data-ttu-id="c756b-325">(0x08)</span><span class="sxs-lookup"><span data-stu-id="c756b-325">(0x08)</span></span> |
| <span data-ttu-id="c756b-326">TX_BYTE_MEMORY</span><span class="sxs-lookup"><span data-stu-id="c756b-326">TX_BYTE_MEMORY</span></span>  | <span data-ttu-id="c756b-327">(0x09)</span><span class="sxs-lookup"><span data-stu-id="c756b-327">(0x09)</span></span> |
| <span data-ttu-id="c756b-328">TX_MUTEX_SUSP</span><span class="sxs-lookup"><span data-stu-id="c756b-328">TX_MUTEX_SUSP</span></span>   | <span data-ttu-id="c756b-329">(0x0D)</span><span class="sxs-lookup"><span data-stu-id="c756b-329">(0x0D)</span></span> |

> [!NOTE]
> <span data-ttu-id="c756b-330">*Naturligtvis finns det många andra intressanta fält i tråd kontroll blocket, inklusive stack pekare, Time-slice-värde, prioriteter osv. Användare är välkommen att granska kontroll Blocks medlemmar, men ändringar är strikt förbjudna!*</span><span class="sxs-lookup"><span data-stu-id="c756b-330">*Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-331">Det finns *ingen som är lika med det "kör"-tillstånd som nämnts tidigare i det här avsnittet. Det är inte nödvändigt eftersom det bara finns en körnings tråd vid en specifik tidpunkt. Status för en körnings tråd* **TX_READY** också.</span><span class="sxs-lookup"><span data-stu-id="c756b-331">*There is no equate for the "executing" state mentioned earlier in this section. It is not necessary because there is only one executing thread at a given time. The state of an executing thread is also* **TX_READY**.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="c756b-332">Tråd som körs för närvarande</span><span class="sxs-lookup"><span data-stu-id="c756b-332">Currently Executing Thread</span></span>

<span data-ttu-id="c756b-333">Som nämnts tidigare finns det bara en tråd som körs vid en specifik tidpunkt.</span><span class="sxs-lookup"><span data-stu-id="c756b-333">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="c756b-334">Det finns flera sätt att identifiera den exekverande tråden på, beroende på vilken tråd som gör begäran.</span><span class="sxs-lookup"><span data-stu-id="c756b-334">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>
<span data-ttu-id="c756b-335">Ett program segment kan hämta kontroll block adressen för tråden som körs genom att anropa ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="c756b-335">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="c756b-336">Detta är användbart i delade delar av program kod som körs från flera trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-336">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="c756b-337">I fel söknings sessioner kan användare undersöka den interna ThreadX-pekaren ***_tx_thread_current_ptr***.</span><span class="sxs-lookup"><span data-stu-id="c756b-337">In debug sessions, users can examine the internal ThreadX pointer ***_tx_thread_current_ptr***.</span></span> <span data-ttu-id="c756b-338">Den innehåller kontroll block adressen för tråden som körs för tillfället.</span><span class="sxs-lookup"><span data-stu-id="c756b-338">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="c756b-339">Om den här pekaren är NULL körs ingen program tråd. t. ex. väntar ThreadX i sin schemaläggnings slinga för att en tråd ska bli klar.</span><span class="sxs-lookup"><span data-stu-id="c756b-339">If this pointer is NULL, no application thread is executing; i.e., ThreadX is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="c756b-340">Tråds tack yta</span><span class="sxs-lookup"><span data-stu-id="c756b-340">Thread Stack Area</span></span>

<span data-ttu-id="c756b-341">Varje tråd måste ha en egen stack för att spara kontexten för den senaste körningen och kompilator användningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-341">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="c756b-342">De flesta C-kompilatorer använder stacken för att skapa funktions anrop och för att tillfälligt allokera lokala variabler.</span><span class="sxs-lookup"><span data-stu-id="c756b-342">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="c756b-343">Bild 6 visar en typisk tråds stack.</span><span class="sxs-lookup"><span data-stu-id="c756b-343">Figure 6 shows a typical thread's stack.</span></span>

<span data-ttu-id="c756b-344">Var en tråds tack finns i minnet är upp till programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-344">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="c756b-345">Stack området anges när trådar skapas och kan placeras var som helst i mål adress utrymmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-345">The stack area is specified during thread creation and can be located anywhere in the target's address space.</span></span> <span data-ttu-id="c756b-346">Detta är en viktig funktion eftersom den gör det möjligt för program att förbättra prestanda för viktiga trådar genom att placera deras stack i höghastighets RAM-minne.</span><span class="sxs-lookup"><span data-stu-id="c756b-346">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="c756b-347">**Stack minnes området** (exempel)</span><span class="sxs-lookup"><span data-stu-id="c756b-347">**Stack Memory Area** (example)</span></span>

![Typisk tråd stack](./media/user-guide/typical-thread-stack.png)

<span data-ttu-id="c756b-349">**BILD 6. Typisk tråd stack**</span><span class="sxs-lookup"><span data-stu-id="c756b-349">**FIGURE 6. Typical Thread Stack**</span></span>

<span data-ttu-id="c756b-350">Hur stor stacken ska vara en av de mest vanliga frågorna om trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-350">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="c756b-351">En tråds stack Area måste vara tillräckligt stor för att rymma värsta Falls funktion anrop, tilldelning av lokala variabler och att den senaste körnings kontexten sparas.</span><span class="sxs-lookup"><span data-stu-id="c756b-351">A thread's stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="c756b-352">Den minsta stack storleken, **TX_MINIMUM_STACK**, definieras av ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-352">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX.</span></span> <span data-ttu-id="c756b-353">En stack med den här storleken har stöd för att spara en tråds kontext och minsta funktions mängd funktions anrop och lokal variabel tilldelning.</span><span class="sxs-lookup"><span data-stu-id="c756b-353">A stack of this size supports saving a thread's context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="c756b-354">För de flesta trådar är den minimala stack storleken för liten, och användaren måste kontrol lera det värsta tillåtna storleks kravet genom att undersöka funktion anrops kapsling och lokal variabel tilldelning.</span><span class="sxs-lookup"><span data-stu-id="c756b-354">For most threads, however, the minimum stack size is too small, and the user must ascertain the worst-case size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="c756b-355">Naturligtvis är det alltid bättre att börja med ett större stack utrymme.</span><span class="sxs-lookup"><span data-stu-id="c756b-355">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="c756b-356">När programmet har felsökts är det möjligt att finjustera trådens stack storlek om minnet är begränsade.</span><span class="sxs-lookup"><span data-stu-id="c756b-356">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="c756b-357">Ett favorit stick är att förinställda alla stack områden med ett enkelt identifierbart data mönster, t. ex. (0xEFEF) innan trådarna skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-357">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="c756b-358">När programmet har genomgått en väl genomförd takt kan stack områdena undersökas för att se hur mycket stack som faktiskt användes genom att hitta området i stacken där data mönstret fortfarande är intakt.</span><span class="sxs-lookup"><span data-stu-id="c756b-358">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="c756b-359">Bild 7 visar en förinställd stack för 0xEFEF efter en grundlig tråd körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-359">Figure 7 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

<span data-ttu-id="c756b-360">**Stack minnes området** (ett annat exempel)</span><span class="sxs-lookup"><span data-stu-id="c756b-360">**Stack Memory Area** (another example)</span></span>

![Stack för inställning till 0xEFEF \*](./media/user-guide/stack-preset.png)

<span data-ttu-id="c756b-362">**BILD 7. Stack för inställning till 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="c756b-362">**FIGURE 7. Stack Preset to 0xEFEF**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-363">*Som standard initierar ThreadX varje byte av varje tråds tack med värdet 0xEF.*</span><span class="sxs-lookup"><span data-stu-id="c756b-363">*By default, ThreadX initializes every byte of each thread stack with a value of 0xEF.*</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="c756b-364">Fall GRO par för minne</span><span class="sxs-lookup"><span data-stu-id="c756b-364">Memory Pitfalls</span></span>

<span data-ttu-id="c756b-365">Stack kraven för trådar kan vara stora.</span><span class="sxs-lookup"><span data-stu-id="c756b-365">The stack requirements for threads can be large.</span></span> <span data-ttu-id="c756b-366">Därför är det viktigt att utforma programmet så att det har ett rimligt antal trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-366">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="c756b-367">Dessutom måste en del försiktighet vidtas för att undvika överdriven stack användning i trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-367">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="c756b-368">Rekursiva algoritmer och stora lokala data strukturer bör undvikas.</span><span class="sxs-lookup"><span data-stu-id="c756b-368">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="c756b-369">I de flesta fall orsakar en överflödad stack tråd körning till skadat minne (vanligt vis före) dess stack område.</span><span class="sxs-lookup"><span data-stu-id="c756b-369">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually before) its stack area.</span></span> <span data-ttu-id="c756b-370">Resultatet är oförutsägbart, men oftast resulterar det i en naturlig ändring i program räknaren.</span><span class="sxs-lookup"><span data-stu-id="c756b-370">The results are unpredictable, but most often result in an unnatural change in the program counter.</span></span> <span data-ttu-id="c756b-371">Detta kallas ofta "att hoppa till ogräs".</span><span class="sxs-lookup"><span data-stu-id="c756b-371">This is often called "jumping into the weeds."</span></span> <span data-ttu-id="c756b-372">Det enda sättet att förhindra detta är naturligtvis att se till att alla tråds tackor är tillräckligt stora.</span><span class="sxs-lookup"><span data-stu-id="c756b-372">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="c756b-373">Valfri stack kontroll på körnings tid</span><span class="sxs-lookup"><span data-stu-id="c756b-373">Optional Run-time Stack Checking</span></span>

<span data-ttu-id="c756b-374">ThreadX ger möjlighet att kontrol lera varje tråds stack för att skadas under körnings tillfället.</span><span class="sxs-lookup"><span data-stu-id="c756b-374">ThreadX provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="c756b-375">Som standard fyller ThreadX varje byte av tråd stackar med ett 0xEF-datamönster när de skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-375">By default, ThreadX fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="c756b-376">Om programmet bygger ThreadX-biblioteket med **TX_ENABLE_STACK_CHECKING** definierat undersöker ThreadX varje tråds stack för att skadas eftersom det pausas eller återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-376">If the application builds the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined, ThreadX will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="c756b-377">Om stack skador identifieras anropar ThreadX programmets stack fel hanterings rutin som anges av anropet till **_tx_thread_stack_error_notify_*_ _. Annars, om ingen stack fel hanterare har angetts, kommer ThreadX att anropa den interna _\* _ _tx_thread_stack_error_handler_*\* rutinen.</span><span class="sxs-lookup"><span data-stu-id="c756b-377">If stack corruption is detected, ThreadX will call the application's stack error handling routine as specified by the call to **_tx_thread_stack_error_notify_*_. Otherwise, if no stack error handler was specified, ThreadX will call the internal _\* _ _tx_thread_stack_error_handler_*\* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="c756b-378">Återinträde</span><span class="sxs-lookup"><span data-stu-id="c756b-378">Reentrancy</span></span>

<span data-ttu-id="c756b-379">En av de verkliga Beauties i multitrådning är att samma C-funktion kan anropas från flera trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-379">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="c756b-380">Detta ger bra kraft och hjälper också till att minska kod utrymmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-380">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="c756b-381">Det kräver dock att C-funktioner som anropas från flera trådar *återkallas.*</span><span class="sxs-lookup"><span data-stu-id="c756b-381">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="c756b-382">En reentrant-funktion lagrar i princip anroparens avsändar adress i den aktuella stacken och förlitar sig inte på globala eller statiska C-variabler som den tidigare har konfigurerat.</span><span class="sxs-lookup"><span data-stu-id="c756b-382">Basically, a reentrant function stores the caller's return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="c756b-383">De flesta kompilatorer placerar avsändar adressen i stacken.</span><span class="sxs-lookup"><span data-stu-id="c756b-383">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="c756b-384">Programutvecklare behöver därför bara bekymra sig om användningen av *globala* och *statics*.</span><span class="sxs-lookup"><span data-stu-id="c756b-384">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="c756b-385">Ett exempel på en icke-reentrant funktion är funktionen String token ***strtok*** som finns i standard-C-biblioteket.</span><span class="sxs-lookup"><span data-stu-id="c756b-385">An example of a non-reentrant function is the string token function ***strtok*** found in the standard C library.</span></span> <span data-ttu-id="c756b-386">Den här funktionen "Remembers" på föregående sträng pekare vid efterföljande anrop.</span><span class="sxs-lookup"><span data-stu-id="c756b-386">This function "remembers" the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="c756b-387">Det gör detta med en statisk sträng pekare.</span><span class="sxs-lookup"><span data-stu-id="c756b-387">It does this with a static string pointer.</span></span> <span data-ttu-id="c756b-388">Om den här funktionen anropas från flera trådar returnerar den förmodligen en ogiltig pekare.</span><span class="sxs-lookup"><span data-stu-id="c756b-388">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="c756b-389">Fall GRO par för tråd prioritet</span><span class="sxs-lookup"><span data-stu-id="c756b-389">Thread Priority Pitfalls</span></span>

<span data-ttu-id="c756b-390">Att välja tråd prioritet är en av de viktigaste aspekterna av multitrådning.</span><span class="sxs-lookup"><span data-stu-id="c756b-390">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="c756b-391">Det är ibland mycket frestande att tilldela prioriteringar baserat på ett uppfattat begrepp i trådens betydelse snarare än att fastställa vad som krävs under körningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-391">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="c756b-392">Missbruk av tråd prioriteter kan strypa andra trådar, skapa prioritets version, minska bearbetnings bandbredden och göra programmets körnings beteende svårt att förstå.</span><span class="sxs-lookup"><span data-stu-id="c756b-392">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application's run-time behavior difficult to understand.</span></span>

<span data-ttu-id="c756b-393">Som nämnts tidigare tillhandahåller ThreadX en prioriterad algoritm för ogiltiga-schemaläggning.</span><span class="sxs-lookup"><span data-stu-id="c756b-393">As mentioned before, ThreadX provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="c756b-394">Trådar med lägre prioritet körs inte förrän det inte finns fler tråds trådar som är klara för körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-394">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="c756b-395">Om en tråd med högre prioritet alltid är klar körs inte trådarna med lägre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-395">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="c756b-396">Det här villkoret kallas för *Thread effekter*.</span><span class="sxs-lookup"><span data-stu-id="c756b-396">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="c756b-397">De flesta tråd effekter problem upptäcks tidigt i debug och kan lösas genom att se till att trådar med högre prioritet inte körs kontinuerligt.</span><span class="sxs-lookup"><span data-stu-id="c756b-397">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don't execute continuously.</span></span> <span data-ttu-id="c756b-398">Du kan också lägga till logik i programmet som gradvis höjer prioriteten för har-trådar tills de får en chans att köra.</span><span class="sxs-lookup"><span data-stu-id="c756b-398">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="c756b-399">En annan Pitfall som är kopplad till tråd prioriteter är *prioritets version*.</span><span class="sxs-lookup"><span data-stu-id="c756b-399">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="c756b-400">Prioritets versionen sker när en tråd med högre prioritet har pausats eftersom en tråd med lägre prioritet har en nödvändig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-400">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="c756b-401">I vissa fall är det naturligtvis nödvändigt med två trådar av olika prioritet för att dela en gemensam resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-401">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="c756b-402">Om de här trådarna är de enda som är aktiva, begränsas prioritets versionen av tiden av tiden som den lägre prioritets tråden innehåller resursen.</span><span class="sxs-lookup"><span data-stu-id="c756b-402">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="c756b-403">Det här villkoret är både deterministiskt och helt vanligt.</span><span class="sxs-lookup"><span data-stu-id="c756b-403">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="c756b-404">Men om trådar med mellanliggande prioritet blir aktiva under det här prioritets villkoret, är tiden för prioritets version inte längre deterministisk och kan orsaka ett program fel.</span><span class="sxs-lookup"><span data-stu-id="c756b-404">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="c756b-405">Det finns huvudsakligen tre distinkta metoder för att förhindra icke-deterministiska prioritets versioner i ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-405">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX.</span></span> <span data-ttu-id="c756b-406">Först kan program prioritets valen och körnings beteendet utformas på ett sätt som förhindrar problem med prioritets versionen.</span><span class="sxs-lookup"><span data-stu-id="c756b-406">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="c756b-407">För det andra kan trådar med lägre prioritet använda *avstängningen tröskel* för att blockera avstängningen från mellanliggande trådar medan de delar resurser med trådar med högre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-407">Second, lower priority threads can utilize *preemption threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="c756b-408">Slutligen kan trådar som använder ThreadX mutex-objekt för att skydda system resurser använda sig av valfria mutex- *prioritets arv* för att eliminera icke-deterministiska prioritets versioner.</span><span class="sxs-lookup"><span data-stu-id="c756b-408">Finally, threads using ThreadX mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="c756b-409">Prioriterad omkostnader</span><span class="sxs-lookup"><span data-stu-id="c756b-409">Priority Overhead</span></span>

<span data-ttu-id="c756b-410">Ett av de mest överblickade sätten att minska omkostnader i multitrådning är att minska antalet kontext byten.</span><span class="sxs-lookup"><span data-stu-id="c756b-410">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="c756b-411">Som tidigare nämnts inträffar en kontext växel när körningen av en tråd med högre prioritet prioriteras över den som kör tråden.</span><span class="sxs-lookup"><span data-stu-id="c756b-411">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="c756b-412">Det är ett exempel på att nämna att trådar med högre prioritet kan bli klara till följd av både externa händelser (t. ex. avbrott) och från tjänst anrop som görs av tråden som körs.</span><span class="sxs-lookup"><span data-stu-id="c756b-412">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="c756b-413">För att illustrera de effekter som Trådens prioritet har på kontext växlings omkostnader, förutsätter en tre tråd miljö med trådar som heter *thread_1*, *thread_2* och *thread_3*.</span><span class="sxs-lookup"><span data-stu-id="c756b-413">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="c756b-414">Anta ytterligare att alla trådar är i ett tillstånd där SUS Pension väntar på ett meddelande.</span><span class="sxs-lookup"><span data-stu-id="c756b-414">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="c756b-415">När thread_1 tar emot ett meddelande vidarebefordras det direkt till thread_2.</span><span class="sxs-lookup"><span data-stu-id="c756b-415">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="c756b-416">Thread_2 vidarebefordrar sedan meddelandet till thread_3.</span><span class="sxs-lookup"><span data-stu-id="c756b-416">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="c756b-417">Thread_3 tar bara bort meddelandet.</span><span class="sxs-lookup"><span data-stu-id="c756b-417">Thread_3 just discards the message.</span></span> <span data-ttu-id="c756b-418">När varje tråd bearbetar meddelandet går det tillbaka och väntar på ett annat meddelande.</span><span class="sxs-lookup"><span data-stu-id="c756b-418">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="c756b-419">Den bearbetning som krävs för att köra dessa tre trådar varierar kraftigt beroende på deras prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-419">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="c756b-420">Om alla trådar har samma prioritet inträffar en enda kontext växel innan varje tråd körs.</span><span class="sxs-lookup"><span data-stu-id="c756b-420">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="c756b-421">Kontext växeln inträffar när varje tråd pausas i en tom meddelandekö.</span><span class="sxs-lookup"><span data-stu-id="c756b-421">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="c756b-422">Men om thread_2 högre prioritet än thread_1 och thread_3 är högre prioritet än thread_2, dubbleras antalet kontext byten.</span><span class="sxs-lookup"><span data-stu-id="c756b-422">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="c756b-423">Detta beror på att en annan kontext växel förekommer i *tx_queue_send* tjänsten när den upptäcker att en tråd med högre prioritet nu är klar.</span><span class="sxs-lookup"><span data-stu-id="c756b-423">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="c756b-424">ThreadX avstängningen-tröskel kan undvika dessa extra kontext byten och tillåter fortfarande de tidigare nämnda prioritets valen.</span><span class="sxs-lookup"><span data-stu-id="c756b-424">The ThreadX preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="c756b-425">Detta är en viktig funktion eftersom den tillåter flera tråd prioriteringar under schemaläggningen, samtidigt som en del av den oönskade kontext växlingen mellan dem under tråd körningen elimineras.</span><span class="sxs-lookup"><span data-stu-id="c756b-425">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="c756b-426">Prestanda information för körnings tråd</span><span class="sxs-lookup"><span data-stu-id="c756b-426">Run-time Thread Performance Information</span></span>

<span data-ttu-id="c756b-427">ThreadX tillhandahåller valfria prestanda information för körnings tråd.</span><span class="sxs-lookup"><span data-stu-id="c756b-427">ThreadX provides optional run-time thread performance information.</span></span> <span data-ttu-id="c756b-428">Om ThreadX-biblioteket och programmet har skapats med **TX_THREAD_ENABLE_PERFORMANCE_INFO** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-428">If the ThreadX library and application is built with **TX_THREAD_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-429">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-429">Total number for the overall system:</span></span>

  - <span data-ttu-id="c756b-430">återuppta trådar</span><span class="sxs-lookup"><span data-stu-id="c756b-430">thread resumptions</span></span>

  - <span data-ttu-id="c756b-431">tråd upphängningar</span><span class="sxs-lookup"><span data-stu-id="c756b-431">thread suspensions</span></span>

  - <span data-ttu-id="c756b-432">preemptions för service samtal</span><span class="sxs-lookup"><span data-stu-id="c756b-432">service call preemptions</span></span>

  - <span data-ttu-id="c756b-433">Avbryt preemptions</span><span class="sxs-lookup"><span data-stu-id="c756b-433">interrupt preemptions</span></span>

  - <span data-ttu-id="c756b-434">prioritets version</span><span class="sxs-lookup"><span data-stu-id="c756b-434">priority inversions</span></span>

  - <span data-ttu-id="c756b-435">Time-Slices</span><span class="sxs-lookup"><span data-stu-id="c756b-435">time-slices</span></span>

  - <span data-ttu-id="c756b-436">låser sig</span><span class="sxs-lookup"><span data-stu-id="c756b-436">relinquishes</span></span>

  - <span data-ttu-id="c756b-437">tids gräns för trådar</span><span class="sxs-lookup"><span data-stu-id="c756b-437">thread timeouts</span></span>

  - <span data-ttu-id="c756b-438">avbrott i avbrott</span><span class="sxs-lookup"><span data-stu-id="c756b-438">suspension aborts</span></span>

  - <span data-ttu-id="c756b-439">inaktiva system returnerar</span><span class="sxs-lookup"><span data-stu-id="c756b-439">idle system returns</span></span>

  - <span data-ttu-id="c756b-440">system som inte är inaktiva returneras</span><span class="sxs-lookup"><span data-stu-id="c756b-440">non-idle system returns</span></span>

<span data-ttu-id="c756b-441">Totalt antal för varje tråd:</span><span class="sxs-lookup"><span data-stu-id="c756b-441">Total number for each thread:</span></span>

  - <span data-ttu-id="c756b-442">återupptagning</span><span class="sxs-lookup"><span data-stu-id="c756b-442">resumptions</span></span>

  - <span data-ttu-id="c756b-443">SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-443">suspensions</span></span>

  - <span data-ttu-id="c756b-444">preemptions för service samtal</span><span class="sxs-lookup"><span data-stu-id="c756b-444">service call preemptions</span></span>

  - <span data-ttu-id="c756b-445">Avbryt preemptions</span><span class="sxs-lookup"><span data-stu-id="c756b-445">interrupt preemptions</span></span>

  - <span data-ttu-id="c756b-446">prioritets version</span><span class="sxs-lookup"><span data-stu-id="c756b-446">priority inversions</span></span>

  - <span data-ttu-id="c756b-447">Time-Slices</span><span class="sxs-lookup"><span data-stu-id="c756b-447">time-slices</span></span>

  - <span data-ttu-id="c756b-448">tråden låser sig</span><span class="sxs-lookup"><span data-stu-id="c756b-448">thread relinquishes</span></span>

  - <span data-ttu-id="c756b-449">tids gräns för trådar</span><span class="sxs-lookup"><span data-stu-id="c756b-449">thread timeouts</span></span>

  - <span data-ttu-id="c756b-450">avbrott i avbrott</span><span class="sxs-lookup"><span data-stu-id="c756b-450">suspension aborts</span></span>

<span data-ttu-id="c756b-451">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_thread_performance_info_get** _ och _ *_tx_thread_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-451">This information is available at run-time through the services ***tx_thread_performance_info_get** _ and _*_tx_thread_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-452">Information om tråd prestanda är användbar för att fastställa om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-452">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-453">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-453">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-454">Till exempel kan ett relativt högt antal service samtal preemptions föreslå Trådens prioritet och/eller avstängningen-tröskelvärdet är för lågt.</span><span class="sxs-lookup"><span data-stu-id="c756b-454">For example, a relatively high number of service call preemptions might suggest the thread's priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="c756b-455">Dessutom kan ett relativt lågt antal inaktiva system returer föreslå att trådar med lägre prioritet inte pausas tillräckligt.</span><span class="sxs-lookup"><span data-stu-id="c756b-455">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="c756b-456">Felsöka fall GRO par</span><span class="sxs-lookup"><span data-stu-id="c756b-456">Debugging Pitfalls</span></span>

<span data-ttu-id="c756b-457">Fel sökning av flertrådiga program är lite svårare eftersom samma program kod kan köras från flera trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-457">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="c756b-458">I sådana fall kanske det inte finns tillräckligt med en Bryt punkt.</span><span class="sxs-lookup"><span data-stu-id="c756b-458">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="c756b-459">Fel sökaren måste också visa den aktuella tråd pekaren **_tx_thread_current_ptr** att använda en villkorlig Bryt punkt för att se om den anropande tråden är den som ska felsöka.</span><span class="sxs-lookup"><span data-stu-id="c756b-459">The debugger must also view the current thread pointer **_tx_thread_current_ptr** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="c756b-460">Mycket av detta hanteras i support paket för flera trådar som erbjuds via olika leverantörer av utvecklingsverktyg.</span><span class="sxs-lookup"><span data-stu-id="c756b-460">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="c756b-461">På grund av sin enkla utformning är det relativt enkelt att integrera ThreadX med olika utvecklingsverktyg.</span><span class="sxs-lookup"><span data-stu-id="c756b-461">Because of its simple design, integrating ThreadX with different development tools is relatively easy.</span></span>

<span data-ttu-id="c756b-462">Stack storleken är alltid ett viktigt fel söknings avsnitt i multitrådning.</span><span class="sxs-lookup"><span data-stu-id="c756b-462">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="c756b-463">När ett oförutsägbart beteende observeras, är det vanligt vis en bra första gissning att öka stack storlekarna för alla trådar, särskilt stack storleken på den senaste tråden som ska köras!</span><span class="sxs-lookup"><span data-stu-id="c756b-463">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!TIP]
> <span data-ttu-id="c756b-464">*Det är också en bra idé att bygga ThreadX-biblioteket med **TX_ENABLE_STACK_CHECKING** definierat. Detta hjälper till att isolera problem med stack skador så tidigt som möjligt.*</span><span class="sxs-lookup"><span data-stu-id="c756b-464">*It is also a good idea to build the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined. This will help isolate stack corruption problems as early in the processing as possible.*</span></span>

## <a name="message-queues"></a><span data-ttu-id="c756b-465">Meddelande köer</span><span class="sxs-lookup"><span data-stu-id="c756b-465">Message Queues</span></span>

<span data-ttu-id="c756b-466">Meddelande köer är det främsta sättet att kommunicera mellan trådar i ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-466">Message queues are the primary means of inter-thread communication in ThreadX.</span></span> <span data-ttu-id="c756b-467">Ett eller flera meddelanden kan finnas i en meddelandekö.</span><span class="sxs-lookup"><span data-stu-id="c756b-467">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="c756b-468">En meddelandekö som innehåller ett enda meddelande kallas ofta för en *post låda*.</span><span class="sxs-lookup"><span data-stu-id="c756b-468">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="c756b-469">Meddelanden kopieras till en kö med \***tx_queue_send** _ och kopieras från en kö efter _ *_tx_queue_receive_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-469">Messages are copied to a queue by ***tx_queue_send** _ and are copied from a queue by _*_tx_queue_receive_\*\*.</span></span> <span data-ttu-id="c756b-470">Det enda undantaget är när en tråd pausas och väntar på ett meddelande på en tom kö.</span><span class="sxs-lookup"><span data-stu-id="c756b-470">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="c756b-471">I det här fallet placeras nästa meddelande som skickas till kön direkt i trådens mål område.</span><span class="sxs-lookup"><span data-stu-id="c756b-471">In this case, the next message sent to the queue is placed directly into the thread's destination area.</span></span>

<span data-ttu-id="c756b-472">Varje meddelandekö är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-472">Each message queue is a public resource.</span></span> <span data-ttu-id="c756b-473">ThreadX placerar inga begränsningar för hur meddelande köer används.</span><span class="sxs-lookup"><span data-stu-id="c756b-473">ThreadX places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="c756b-474">Skapa meddelande köer</span><span class="sxs-lookup"><span data-stu-id="c756b-474">Creating Message Queues</span></span>

<span data-ttu-id="c756b-475">Meddelande köer skapas antingen under initiering eller under körning av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-475">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-476">Det finns ingen gräns för antalet meddelande köer i ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-476">There is no limit on the number of message queues in an application.</span></span>

### <a name="message-size"></a><span data-ttu-id="c756b-477">Meddelande storlek</span><span class="sxs-lookup"><span data-stu-id="c756b-477">Message Size</span></span>

<span data-ttu-id="c756b-478">Varje meddelandekö har stöd för ett antal meddelanden med fast storlek.</span><span class="sxs-lookup"><span data-stu-id="c756b-478">Each message queue supports a number of fixed-sized messages.</span></span> <span data-ttu-id="c756b-479">De tillgängliga meddelande storlekarna är 1 till 16 32-bitars ord, inklusive.</span><span class="sxs-lookup"><span data-stu-id="c756b-479">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="c756b-480">Meddelande storleken anges när kön skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-480">The message size is specified when the queue is created.</span></span> <span data-ttu-id="c756b-481">Program meddelanden som är större än 16 ord måste skickas av en pekare.</span><span class="sxs-lookup"><span data-stu-id="c756b-481">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="c756b-482">Detta åstadkommer du genom att skapa en kö med en meddelande storlek på 1 ord (tillräckligt för att hålla en pekare) och sedan skicka och ta emot meddelande pekare i stället för hela meddelandet.</span><span class="sxs-lookup"><span data-stu-id="c756b-482">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="c756b-483">Meddelandekö-kapacitet</span><span class="sxs-lookup"><span data-stu-id="c756b-483">Message Queue Capacity</span></span>

<span data-ttu-id="c756b-484">Antalet meddelanden som en kö kan innehålla är en funktion i dess meddelande storlek och storleken på det minnes utrymme som angavs när den skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-484">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="c756b-485">Den totala meddelande kapaciteten för kön beräknas genom att antalet byte i varje meddelande divideras med det totala antalet byte i det angivna minnes området.</span><span class="sxs-lookup"><span data-stu-id="c756b-485">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="c756b-486">Om till exempel en meddelandekö som stöder en meddelande storlek på 1 32-bitars ord (4 byte) skapas med minnes området 100 byte, är dess kapacitet 25 meddelanden.</span><span class="sxs-lookup"><span data-stu-id="c756b-486">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="c756b-487">Köa minnes området</span><span class="sxs-lookup"><span data-stu-id="c756b-487">Queue Memory Area</span></span>

<span data-ttu-id="c756b-488">Som tidigare nämnts anges minnes området för buffring av meddelanden när kön skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-488">As mentioned previously, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="c756b-489">Precis som andra minnes områden i ThreadX kan det finnas var som helst i målets adress utrymme.</span><span class="sxs-lookup"><span data-stu-id="c756b-489">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="c756b-490">Detta är en viktig funktion eftersom den ger programmet stor flexibilitet.</span><span class="sxs-lookup"><span data-stu-id="c756b-490">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="c756b-491">Ett program kan till exempel hitta minnes området för en viktig kö i snabb RAM-minne för att förbättra prestanda.</span><span class="sxs-lookup"><span data-stu-id="c756b-491">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c756b-492">Tråd upphängning</span><span class="sxs-lookup"><span data-stu-id="c756b-492">Thread Suspension</span></span>

<span data-ttu-id="c756b-493">Program trådar kan pausas vid försök att skicka eller ta emot ett meddelande från en kö.</span><span class="sxs-lookup"><span data-stu-id="c756b-493">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="c756b-494">Vanligt vis avser tråd upphängning väntar på ett meddelande från en tom kö.</span><span class="sxs-lookup"><span data-stu-id="c756b-494">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="c756b-495">Det är dock också möjligt för en tråd att pausa försök att skicka ett meddelande till en fullständig kö.</span><span class="sxs-lookup"><span data-stu-id="c756b-495">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span>

<span data-ttu-id="c756b-496">När tillståndet för uppskjutningen har lösts slutförs den begärda tjänsten och vänte tråden återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-496">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="c756b-497">Om flera trådar är inaktiverade i samma kö återupptas de i den ordning som de var pausade (FIFO).</span><span class="sxs-lookup"><span data-stu-id="c756b-497">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="c756b-498">Men prioritets återupptagning är också möjligt om programmet anropar ***tx_queue_prioritize*** före den Queue Service som lyfter tråd SUS pension.</span><span class="sxs-lookup"><span data-stu-id="c756b-498">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="c756b-499">Prioritets tjänsten för köer placerar den högsta prioritets tråden överst i uppskjutnings listan, samtidigt som alla andra pausade trådar i samma FIFO-ordning lämnas kvar.</span><span class="sxs-lookup"><span data-stu-id="c756b-499">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="c756b-500">Tids gränser är också tillgängliga för alla uppehåll i kön.</span><span class="sxs-lookup"><span data-stu-id="c756b-500">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="c756b-501">I princip anger ett timeout-värde det maximala antalet timer-Tick som tråden förblir inaktive rad.</span><span class="sxs-lookup"><span data-stu-id="c756b-501">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="c756b-502">Om en timeout inträffar återupptas tråden och tjänsten returnerar rätt felkod.</span><span class="sxs-lookup"><span data-stu-id="c756b-502">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="c756b-503">Köa sändnings meddelande</span><span class="sxs-lookup"><span data-stu-id="c756b-503">Queue Send Notification</span></span>

<span data-ttu-id="c756b-504">Vissa program kan vara fördelaktiga att meddelas när ett meddelande placeras i en kö.</span><span class="sxs-lookup"><span data-stu-id="c756b-504">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="c756b-505">ThreadX tillhandahåller den här funktionen genom ***tx_queue_send_notifys*** tjänsten.</span><span class="sxs-lookup"><span data-stu-id="c756b-505">ThreadX provides this ability through the ***tx_queue_send_notify*** service.</span></span> <span data-ttu-id="c756b-506">Den här tjänsten registrerar den angivna program aviserings funktionen med den angivna kön.</span><span class="sxs-lookup"><span data-stu-id="c756b-506">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="c756b-507">ThreadX anropar sedan den här program meddelande funktionen när ett meddelande skickas till kön.</span><span class="sxs-lookup"><span data-stu-id="c756b-507">ThreadX will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="c756b-508">Den exakta bearbetningen inom programmets meddelande funktion bestäms av programmet. Det består dock vanligt vis av att återuppta den aktuella tråden för att bearbeta det nya meddelandet.</span><span class="sxs-lookup"><span data-stu-id="c756b-508">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chainingtrade"></a><span data-ttu-id="c756b-509">Köa händelse länkning&trade;</span><span class="sxs-lookup"><span data-stu-id="c756b-509">Queue Event chaining&trade;</span></span>

<span data-ttu-id="c756b-510">Aviserings funktionerna i ThreadX kan användas för att kedja samman olika synkroniseringsobjekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-510">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="c756b-511">Detta är vanligt vis användbart när en enskild tråd måste bearbeta flera synkroniseringsanvändare.</span><span class="sxs-lookup"><span data-stu-id="c756b-511">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="c756b-512">Anta till exempel att en enskild tråd ansvarar för att bearbeta meddelanden från fem olika köer och måste även inaktive ras när inga meddelanden är tillgängliga.</span><span class="sxs-lookup"><span data-stu-id="c756b-512">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="c756b-513">Detta åstadkommer du genom att registrera en program meddelande funktion för varje kö och introducera en extra beräknings semafor.</span><span class="sxs-lookup"><span data-stu-id="c756b-513">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="c756b-514">Mer specifikt utför funktionen program meddelande en *tx_semaphore_put* när den anropas (antalet semaforer representerar det totala antalet meddelanden i alla fem köer).</span><span class="sxs-lookup"><span data-stu-id="c756b-514">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="c756b-515">Bearbetnings tråden inaktive ras på den här semaforen via tjänsten *tx_semaphore_get* .</span><span class="sxs-lookup"><span data-stu-id="c756b-515">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="c756b-516">När semaforen är tillgänglig (i det här fallet när ett meddelande är tillgängligt!) återupptas bearbetnings tråden.</span><span class="sxs-lookup"><span data-stu-id="c756b-516">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="c756b-517">Sedan söker den efter varje kö för ett meddelande, bearbetar det påträffade meddelandet och utför en annan ***tx_semaphore_get*** att vänta på nästa meddelande.</span><span class="sxs-lookup"><span data-stu-id="c756b-517">It then interrogates each queue for a message, processes the found message, and performs another ***tx_semaphore_get*** to wait for the next message.</span></span> <span data-ttu-id="c756b-518">Att göra detta utan händelse länkning är ganska svårt och sannolikt kräver fler trådar och/eller ytterligare program kod.</span><span class="sxs-lookup"><span data-stu-id="c756b-518">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="c756b-519">I allmänhet resulterar *händelse länkning* i färre trådar, mindre omkostnader och mindre RAM-krav.</span><span class="sxs-lookup"><span data-stu-id="c756b-519">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="c756b-520">Det ger också en mycket flexibel mekanism för att hantera krav för synkronisering av mer komplexa system.</span><span class="sxs-lookup"><span data-stu-id="c756b-520">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="c756b-521">Prestanda information för kör tids kön</span><span class="sxs-lookup"><span data-stu-id="c756b-521">Run-time Queue Performance Information</span></span>
<span data-ttu-id="c756b-522">ThreadX tillhandahåller valfri prestanda information för körning av kö.</span><span class="sxs-lookup"><span data-stu-id="c756b-522">ThreadX provides optional run-time queue performance information.</span></span> <span data-ttu-id="c756b-523">Om ThreadX-biblioteket och programmet har skapats med ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-523">If the ThreadX library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-524">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-524">Total number for the overall system:</span></span>

  - <span data-ttu-id="c756b-525">skickade meddelanden</span><span class="sxs-lookup"><span data-stu-id="c756b-525">messages sent</span></span>

  - <span data-ttu-id="c756b-526">mottagna meddelanden</span><span class="sxs-lookup"><span data-stu-id="c756b-526">messages received</span></span>

  - <span data-ttu-id="c756b-527">köa tomma SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-527">queue empty suspensions</span></span>

  - <span data-ttu-id="c756b-528">köa fullständig fjädring</span><span class="sxs-lookup"><span data-stu-id="c756b-528">queue full suspensions</span></span>

  - <span data-ttu-id="c756b-529">Returnerar fullständiga fel i kön (ingen avstängning har angetts)</span><span class="sxs-lookup"><span data-stu-id="c756b-529">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="c756b-530">timeout för kö</span><span class="sxs-lookup"><span data-stu-id="c756b-530">queue timeouts</span></span>

<span data-ttu-id="c756b-531">Totalt antal för varje kö:</span><span class="sxs-lookup"><span data-stu-id="c756b-531">Total number for each queue:</span></span>

  - <span data-ttu-id="c756b-532">skickade meddelanden</span><span class="sxs-lookup"><span data-stu-id="c756b-532">messages sent</span></span>

  - <span data-ttu-id="c756b-533">mottagna meddelanden</span><span class="sxs-lookup"><span data-stu-id="c756b-533">messages received</span></span>

  - <span data-ttu-id="c756b-534">köa tomma SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-534">queue empty suspensions</span></span>

  - <span data-ttu-id="c756b-535">köa fullständig fjädring</span><span class="sxs-lookup"><span data-stu-id="c756b-535">queue full suspensions</span></span>

  - <span data-ttu-id="c756b-536">Returnerar fullständiga fel i kön (ingen avstängning har angetts)</span><span class="sxs-lookup"><span data-stu-id="c756b-536">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="c756b-537">timeout för kö</span><span class="sxs-lookup"><span data-stu-id="c756b-537">queue timeouts</span></span>

<span data-ttu-id="c756b-538">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_queue_performance_info_get** _ och _ *_tx_queue_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-538">This information is available at run-time through the services ***tx_queue_performance_info_get** _ and _*_tx_queue_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-539">Prestanda information för kö är användbar för att avgöra om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-539">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-540">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-540">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-541">Till exempel, ett relativt högt antal "kön full fjädring" föreslår en ökning i kös Tor lek kan vara fördelaktig.</span><span class="sxs-lookup"><span data-stu-id="c756b-541">For example, a relatively high number of "queue full suspensions" suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="c756b-542">Block TX_QUEUE för Queue Control</span><span class="sxs-lookup"><span data-stu-id="c756b-542">Queue Control Block TX_QUEUE</span></span>

<span data-ttu-id="c756b-543">Egenskaperna för varje meddelandekö finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-543">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="c756b-544">Den innehåller intressant information, till exempel antalet meddelanden i kön.</span><span class="sxs-lookup"><span data-stu-id="c756b-544">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="c756b-545">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-545">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-546">Meddelande köns kontroll block kan också finnas var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-546">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="c756b-547">Pitfall för meddelande mål</span><span class="sxs-lookup"><span data-stu-id="c756b-547">Message Destination Pitfall</span></span>

<span data-ttu-id="c756b-548">Som tidigare nämnts kopieras meddelanden mellan området kö och program data.</span><span class="sxs-lookup"><span data-stu-id="c756b-548">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="c756b-549">Det är viktigt att se till att målet för ett mottaget meddelande är tillräckligt stort för att rymma hela meddelandet.</span><span class="sxs-lookup"><span data-stu-id="c756b-549">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="c756b-550">Om inte, kommer minnet som följer meddelande målet förmodligen att skadas.</span><span class="sxs-lookup"><span data-stu-id="c756b-550">If not, the memory following the message destination will likely be corrupted.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-551">*Detta är särskilt dödligt när ett för litet meddelande mål är i stacken – inget som skadar retur adressen för en funktion!*</span><span class="sxs-lookup"><span data-stu-id="c756b-551">*This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!*</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="c756b-552">Inventering av semaforer</span><span class="sxs-lookup"><span data-stu-id="c756b-552">Counting Semaphores</span></span>

<span data-ttu-id="c756b-553">ThreadX tillhandahåller 32-bitars beräknings semaforer som ligger inom intervallet 0 till 4 294 967 295.</span><span class="sxs-lookup"><span data-stu-id="c756b-553">ThreadX provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="c756b-554">Det finns två åtgärder för att räkna semaforer: *tx_semaphore_get* och *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="c756b-554">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="c756b-555">Åtgärden get minskar semaforen med en.</span><span class="sxs-lookup"><span data-stu-id="c756b-555">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="c756b-556">Om semaforen är 0 fungerar inte get-åtgärden.</span><span class="sxs-lookup"><span data-stu-id="c756b-556">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="c756b-557">Inversen av Get-åtgärden är åtgärden placera.</span><span class="sxs-lookup"><span data-stu-id="c756b-557">The inverse of the get operation is the put operation.</span></span>
<span data-ttu-id="c756b-558">Den ökar semaforen med en.</span><span class="sxs-lookup"><span data-stu-id="c756b-558">It increases the semaphore by one.</span></span>

<span data-ttu-id="c756b-559">Varje semafor i beräkningen är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-559">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="c756b-560">ThreadX placerar inga begränsningar för hur antalet semaforer används.</span><span class="sxs-lookup"><span data-stu-id="c756b-560">ThreadX places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="c756b-561">Inventering av semaforer används vanligt vis för *ömsesidig uteslutning*.</span><span class="sxs-lookup"><span data-stu-id="c756b-561">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="c756b-562">Inventering av semaforer kan dock också användas som en metod för händelse aviseringar.</span><span class="sxs-lookup"><span data-stu-id="c756b-562">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="c756b-563">Ömsesidigt undantag</span><span class="sxs-lookup"><span data-stu-id="c756b-563">Mutual Exclusion</span></span>

 <span data-ttu-id="c756b-564">Ömsesidigt undantag avser att kontrol lera åtkomsten till trådar till vissa program områden (kallas även *kritiska avsnitt* eller *program resurser*).</span><span class="sxs-lookup"><span data-stu-id="c756b-564">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="c756b-565">När det används för ömsesidig uteslutning representerar "Aktuellt antal" för en semafor det totala antalet trådar som tillåts åtkomst.</span><span class="sxs-lookup"><span data-stu-id="c756b-565">When used for mutual exclusion, the "current count" of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="c756b-566">I de flesta fall har semaforer som används för ömsesidig undantag ett initialt värde på 1, vilket innebär att endast en tråd kan komma åt den associerade resursen i taget.</span><span class="sxs-lookup"><span data-stu-id="c756b-566">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="c756b-567">Antalet semaforer som räknas som värden på 0 eller 1 kallas ofta *binära semaforer*.</span><span class="sxs-lookup"><span data-stu-id="c756b-567">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-568">*Om en binär semafor används måste användaren förhindra att samma tråd utför en get-åtgärd på en semafor som redan äger. En andra get skulle Miss lyckas och kan orsaka obestämd avstängning av den anropande tråden och permanent otillgänglig resurs.*</span><span class="sxs-lookup"><span data-stu-id="c756b-568">*If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns. A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.*</span></span>

### <a name="event-notification"></a><span data-ttu-id="c756b-569">Händelse meddelande</span><span class="sxs-lookup"><span data-stu-id="c756b-569">Event Notification</span></span>

<span data-ttu-id="c756b-570">Det är också möjligt att använda beräknings semaforer som händelse meddelanden i en producent som är konsument.</span><span class="sxs-lookup"><span data-stu-id="c756b-570">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="c756b-571">Konsumenten försöker få inventerings semaforen medan producenten ökar semaforen när något är tillgängligt.</span><span class="sxs-lookup"><span data-stu-id="c756b-571">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="c756b-572">Sådana semaforer har vanligt vis ett ursprungligt värde på 0 och kommer inte att öka förrän producenten har något som är redo för konsumenten.</span><span class="sxs-lookup"><span data-stu-id="c756b-572">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="c756b-573">Semaforer som används för händelse aviseringar kan också ha nytta av att ***tx_semaphore_ceiling_put*** tjänst anropet.</span><span class="sxs-lookup"><span data-stu-id="c756b-573">Semaphores used for event notification may also benefit from use of the ***tx_semaphore_ceiling_put*** service call.</span></span> <span data-ttu-id="c756b-574">Den här tjänsten säkerställer att antalet semaforer aldrig överskrider det värde som anges i anropet.</span><span class="sxs-lookup"><span data-stu-id="c756b-574">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="c756b-575">Skapa inventerings semaforer</span><span class="sxs-lookup"><span data-stu-id="c756b-575">Creating Counting Semaphores</span></span>

<span data-ttu-id="c756b-576">Inventering av semaforer skapas antingen under initieringen eller under körningen av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-576">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-577">Det inledande antalet av semaforen anges när du skapar.</span><span class="sxs-lookup"><span data-stu-id="c756b-577">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="c756b-578">Det finns ingen gräns för antalet semaforer i ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-578">There is no limit on the number of counting semaphores in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c756b-579">Tråd upphängning</span><span class="sxs-lookup"><span data-stu-id="c756b-579">Thread Suspension</span></span>

<span data-ttu-id="c756b-580">Program trådar kan pausas vid försök att utföra en get-åtgärd på en semafor med det aktuella antalet 0.</span><span class="sxs-lookup"><span data-stu-id="c756b-580">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span>

<span data-ttu-id="c756b-581">När en beställnings åtgärd utförs utförs den pausade trådens get-åtgärd och tråden återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-581">After a put operation is performed, the suspended thread's get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="c756b-582">Om flera trådar har pausats på samma inventerings semafor, återupptas de i samma ordning som de var pausade (FIFO).</span><span class="sxs-lookup"><span data-stu-id="c756b-582">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="c756b-583">Men prioritets återupptagning är också möjligt om programmet anropar ***tx_semaphore_prioritize*** före semaforen som lyfter upp tråd SUS pension.</span><span class="sxs-lookup"><span data-stu-id="c756b-583">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="c756b-584">I semafors prioriterings tjänsten placeras den högsta prioritets tråden längst fram i uppskjutnings listan, samtidigt som alla andra pausade trådar i samma FIFO-ordning lämnas kvar.</span><span class="sxs-lookup"><span data-stu-id="c756b-584">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="c756b-585">Varning om semafors placering</span><span class="sxs-lookup"><span data-stu-id="c756b-585">Semaphore Put Notification</span></span>

<span data-ttu-id="c756b-586">Vissa program kan vara fördelaktiga att meddelas varje gång en semafor införs.</span><span class="sxs-lookup"><span data-stu-id="c756b-586">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="c756b-587">ThreadX tillhandahåller den här funktionen genom ***tx_semaphore_put_notifys*** tjänsten.</span><span class="sxs-lookup"><span data-stu-id="c756b-587">ThreadX provides this ability through the ***tx_semaphore_put_notify*** service.</span></span> <span data-ttu-id="c756b-588">Den här tjänsten registrerar den angivna program aviserings funktionen med den angivna semaforen.</span><span class="sxs-lookup"><span data-stu-id="c756b-588">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="c756b-589">ThreadX kommer sedan att anropa den här program aviserings funktionen varje gång som semaforen placeras.</span><span class="sxs-lookup"><span data-stu-id="c756b-589">ThreadX will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="c756b-590">Den exakta bearbetningen inom programmets meddelande funktion bestäms av programmet. Det består dock vanligt vis av att återuppta den aktuella tråden för bearbetning av den nya händelsen semafor.</span><span class="sxs-lookup"><span data-stu-id="c756b-590">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-event-chainingtrade"></a><span data-ttu-id="c756b-591">Händelse länkning i semafor&trade;</span><span class="sxs-lookup"><span data-stu-id="c756b-591">Semaphore Event chaining&trade;</span></span>

<span data-ttu-id="c756b-592">Aviserings funktionerna i ThreadX kan användas för att kedja samman olika synkroniseringsobjekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-592">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="c756b-593">Detta är vanligt vis användbart när en enskild tråd måste bearbeta flera synkroniseringsanvändare.</span><span class="sxs-lookup"><span data-stu-id="c756b-593">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="c756b-594">I stället för att en separat tråd pausas för ett köat meddelande, händelse flaggor och en semafor, kan programmet registrera en avisering för varje objekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-594">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="c756b-595">Vid anrop kan program aviserings rutinen återupptas och sedan återuppta en enda tråd, som kan söka varje objekt för att hitta och bearbeta den nya händelsen.</span><span class="sxs-lookup"><span data-stu-id="c756b-595">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="c756b-596">I allmänhet resulterar *händelse länkning* i färre trådar, mindre omkostnader och mindre RAM-krav.</span><span class="sxs-lookup"><span data-stu-id="c756b-596">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="c756b-597">Det ger också en mycket flexibel mekanism för att hantera krav för synkronisering av mer komplexa system.</span><span class="sxs-lookup"><span data-stu-id="c756b-597">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="c756b-598">Prestanda information om körning av semafor</span><span class="sxs-lookup"><span data-stu-id="c756b-598">Run-time Semaphore Performance Information</span></span>

<span data-ttu-id="c756b-599">ThreadX tillhandahåller valfria prestanda information för semaforen i körnings läge.</span><span class="sxs-lookup"><span data-stu-id="c756b-599">ThreadX provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="c756b-600">Om ThreadX-biblioteket och programmet har skapats med **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-600">If the ThreadX library and application is built with **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-601">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-601">Total number for the overall system:</span></span>

  - <span data-ttu-id="c756b-602">Infoga semafor</span><span class="sxs-lookup"><span data-stu-id="c756b-602">semaphore puts</span></span>

  - <span data-ttu-id="c756b-603">semafor får</span><span class="sxs-lookup"><span data-stu-id="c756b-603">semaphore gets</span></span>

  - <span data-ttu-id="c756b-604">semafor för att hämta SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-604">semaphore get suspensions</span></span>

  - <span data-ttu-id="c756b-605">timeout för semafor</span><span class="sxs-lookup"><span data-stu-id="c756b-605">semaphore get timeouts</span></span>

<span data-ttu-id="c756b-606">Totalt antal för varje semafor:</span><span class="sxs-lookup"><span data-stu-id="c756b-606">Total number for each semaphore:</span></span>

  - <span data-ttu-id="c756b-607">Infoga semafor</span><span class="sxs-lookup"><span data-stu-id="c756b-607">semaphore puts</span></span>

  - <span data-ttu-id="c756b-608">semafor får</span><span class="sxs-lookup"><span data-stu-id="c756b-608">semaphore gets</span></span>

  - <span data-ttu-id="c756b-609">semafor för att hämta SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-609">semaphore get suspensions</span></span>

  - <span data-ttu-id="c756b-610">timeout för semafor</span><span class="sxs-lookup"><span data-stu-id="c756b-610">semaphore get timeouts</span></span>

<span data-ttu-id="c756b-611">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_semaphore_performance_info_get** _ och _ *_tx_semaphore_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-611">This information is available at run-time through the services ***tx_semaphore_performance_info_get** _ and _*_tx_semaphore_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-612">Information om semafor-prestanda är användbar för att fastställa om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-612">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-613">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-613">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-614">Till exempel kan ett relativt högt antal "semafors tids gränser" innebära att andra trådar håller resurserna för långa.</span><span class="sxs-lookup"><span data-stu-id="c756b-614">For example, a relatively high number of "semaphore get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="c756b-615">Semafor-kontroll block TX_SEMAPHORE</span><span class="sxs-lookup"><span data-stu-id="c756b-615">Semaphore Control Block TX_SEMAPHORE</span></span>

<span data-ttu-id="c756b-616">Egenskaperna för varje semafor i inventeringen finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-616">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="c756b-617">Den innehåller information som det aktuella antalet semaforer.</span><span class="sxs-lookup"><span data-stu-id="c756b-617">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="c756b-618">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-618">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-619">Semafors kontroll block kan finnas var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-619">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="c756b-620">Deadly</span><span class="sxs-lookup"><span data-stu-id="c756b-620">Deadly Embrace</span></span>

<span data-ttu-id="c756b-621">En av de mest intressanta och farliga fall GRO par som är kopplade till semaforer som används för ömsesidiga undantag är *Deadly*.</span><span class="sxs-lookup"><span data-stu-id="c756b-621">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="c756b-622">En Deadly-begränsning, eller *deadlock*, är ett tillstånd där två eller flera trådar pausas på obestämd tid vid försök att hämta semaforer som redan ägs av varandra.</span><span class="sxs-lookup"><span data-stu-id="c756b-622">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="c756b-623">Det här villkoret illustreras bäst av två trådar, två semafor-exempel.</span><span class="sxs-lookup"><span data-stu-id="c756b-623">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="c756b-624">Anta att den första tråden äger den första semaforen och den andra tråden äger den andra semaforen.</span><span class="sxs-lookup"><span data-stu-id="c756b-624">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="c756b-625">Om den första tråden försöker hämta den andra semaforen och samtidigt den andra tråden försöker hämta den första semaforen, anger båda trådarna ett död läge.</span><span class="sxs-lookup"><span data-stu-id="c756b-625">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="c756b-626">Om dessa trådar fortsätter att skjutas upp, är deras associerade resurser även låsta för alltid.</span><span class="sxs-lookup"><span data-stu-id="c756b-626">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="c756b-627">Bild 8 illustrerar det här exemplet.</span><span class="sxs-lookup"><span data-stu-id="c756b-627">Figure 8 illustrates this example.</span></span>

<span data-ttu-id="c756b-628">**Deadly** (exempel)</span><span class="sxs-lookup"><span data-stu-id="c756b-628">**Deadly Embrace** (example)</span></span>

![Exempel på pausade trådar](./media/user-guide/example-suspended-threads.png)

<span data-ttu-id="c756b-630">**FIGUR 8. Exempel på pausade trådar**</span><span class="sxs-lookup"><span data-stu-id="c756b-630">**FIGURE 8. Example of Suspended Threads**</span></span>

<span data-ttu-id="c756b-631">För real tids system kan Deadly-begränsningar förhindras genom att placera vissa begränsningar för hur trådar får semaforer.</span><span class="sxs-lookup"><span data-stu-id="c756b-631">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="c756b-632">Trådar kan bara ha en semafor i taget.</span><span class="sxs-lookup"><span data-stu-id="c756b-632">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="c756b-633">Ett annat sätt är att trådarna kan äga flera semaforer om de samlar in dem i samma ordning.</span><span class="sxs-lookup"><span data-stu-id="c756b-633">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="c756b-634">I föregående exempel, om den första och andra tråden får den första och andra semaforen i ordning, förhindras Deadly-.</span><span class="sxs-lookup"><span data-stu-id="c756b-634">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!TIP]
> <span data-ttu-id="c756b-635">*Du kan också använda tids gränsen för avstängningen som är kopplad till åtgärden Hämta för att återställa från en Deadly.*</span><span class="sxs-lookup"><span data-stu-id="c756b-635">*It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.*</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="c756b-636">Prioritets version</span><span class="sxs-lookup"><span data-stu-id="c756b-636">Priority Inversion</span></span>

<span data-ttu-id="c756b-637">En annan Pitfall som är kopplad till ömsesidiga undantags semaforer är prioritets version.</span><span class="sxs-lookup"><span data-stu-id="c756b-637">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="c756b-638">Det här avsnittet beskrivs mer fullständigt i "[tråd prioritet fall GRO par](#thread-priority-pitfalls)".</span><span class="sxs-lookup"><span data-stu-id="c756b-638">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="c756b-639">Det grundläggande problemet uppstår i en situation där en lägre prioritets tråd har en semafor som kräver tråd med högre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-639">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="c756b-640">Detta är normalt.</span><span class="sxs-lookup"><span data-stu-id="c756b-640">This in itself is normal.</span></span> <span data-ttu-id="c756b-641">Trådar med prioriteter mellan dem kan dock orsaka att prioriteten är inaktiv för senaste icke-deterministisk tids period.</span><span class="sxs-lookup"><span data-stu-id="c756b-641">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="c756b-642">Detta kan hanteras genom noggrann val av tråd prioriteter, med hjälp av avstängningen och tillfälligt höja prioriteten för den tråd som äger resursen till den för tråden med hög prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-642">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="c756b-643">Mutexer</span><span class="sxs-lookup"><span data-stu-id="c756b-643">Mutexes</span></span>

<span data-ttu-id="c756b-644">Förutom semaforer innehåller ThreadX även ett mutex-objekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-644">In addition to semaphores, ThreadX also provides a mutex object.</span></span> <span data-ttu-id="c756b-645">En mutex är i princip en binär semafor, vilket innebär att endast en tråd kan äga en mutex i taget.</span><span class="sxs-lookup"><span data-stu-id="c756b-645">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="c756b-646">Dessutom kan samma tråd utföra en lyckad mutex get-åtgärd på ett ägd mutex flera gånger, 4 294 967 295 att vara exakt.</span><span class="sxs-lookup"><span data-stu-id="c756b-646">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="c756b-647">Det finns två åtgärder på mutex-objektet: \***tx_mutex_get** _ och _ *_tx_mutex_put_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-647">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="c756b-648">Get-åtgärden hämtar en mutex som inte ägs av en annan tråd, medan åtgärds åtgärden släpper en tidigare Hämtad mutex.</span><span class="sxs-lookup"><span data-stu-id="c756b-648">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="c756b-649">För att en tråd ska kunna släppa en mutex måste antalet placera åtgärder vara lika med antalet tidigare hämtnings åtgärder.</span><span class="sxs-lookup"><span data-stu-id="c756b-649">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="c756b-650">Varje mutex är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-650">Each mutex is a public resource.</span></span> <span data-ttu-id="c756b-651">ThreadX placerar inga begränsningar för hur mutexer används.</span><span class="sxs-lookup"><span data-stu-id="c756b-651">ThreadX places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="c756b-652">ThreadX-mutexer används enbart för *ömsesidigt uteslutande undantag*.</span><span class="sxs-lookup"><span data-stu-id="c756b-652">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="c756b-653">Till skillnad från semaforer har mutexer ingen användning som metod för händelse aviseringar.</span><span class="sxs-lookup"><span data-stu-id="c756b-653">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="c756b-654">Ömsesidigt uteslutande mutex</span><span class="sxs-lookup"><span data-stu-id="c756b-654">Mutex Mutual Exclusion</span></span>

<span data-ttu-id="c756b-655">På samma sätt som i avsnittet om inventering av semafor, avser ömsesidigt undantag för att kontrol lera åtkomsten till trådar till vissa program områden (kallas även *kritiska avsnitt* eller *program resurser*).</span><span class="sxs-lookup"><span data-stu-id="c756b-655">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="c756b-656">När det är tillgängligt får ett ThreadX-mutex ett antal ägarskap 0.</span><span class="sxs-lookup"><span data-stu-id="c756b-656">When available, a ThreadX mutex will have an ownership count of 0.</span></span> <span data-ttu-id="c756b-657">När mutexen har hämtats av en tråd ökas ägarskapet en gång för varje lyckad get-åtgärd som utförs på mutex och minskas för varje lyckad åtgärd.</span><span class="sxs-lookup"><span data-stu-id="c756b-657">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="c756b-658">Skapa mutexer</span><span class="sxs-lookup"><span data-stu-id="c756b-658">Creating Mutexes</span></span>

<span data-ttu-id="c756b-659">ThreadX-mutexer skapas antingen under initieringen eller under körningen av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-659">ThreadX mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-660">Det första villkoret för en mutex är alltid "tillgängligt".</span><span class="sxs-lookup"><span data-stu-id="c756b-660">The initial condition of a mutex is always "available."</span></span> <span data-ttu-id="c756b-661">En mutex kan också skapas med *prioriterat arv* valt.</span><span class="sxs-lookup"><span data-stu-id="c756b-661">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c756b-662">Tråd upphängning</span><span class="sxs-lookup"><span data-stu-id="c756b-662">Thread Suspension</span></span>

<span data-ttu-id="c756b-663">Program trådar kan pausas vid försök att utföra en get-åtgärd på en mutex som redan ägs av en annan tråd.</span><span class="sxs-lookup"><span data-stu-id="c756b-663">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="c756b-664">När samma antal placerings åtgärder utförs av den ägande tråden, utförs den inaktiverade trådens get-åtgärd, vilket ger IT-ägarskap för mutexen och tråden återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-664">After the same number of put operations are performed by the owning thread, the suspended thread's get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="c756b-665">Om flera trådar har pausats på samma mutex återupptas de i samma ordning som de var pausade (FIFO).</span><span class="sxs-lookup"><span data-stu-id="c756b-665">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="c756b-666">Prioritets återupptagning görs dock automatiskt om arv av mutex prioritet valdes när de skapades.</span><span class="sxs-lookup"><span data-stu-id="c756b-666">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="c756b-667">Prioritets återupptagning är också möjligt om programmet anropar ***tx_mutex_prioritize*** före det mutex-anrop som lyfter tråd upphängning.</span><span class="sxs-lookup"><span data-stu-id="c756b-667">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="c756b-668">I mutex-prioriterings tjänsten placeras den högsta prioritets tråden längst fram i uppskjutnings listan, samtidigt som alla andra pausade trådar i samma FIFO-ordning lämnas kvar.</span><span class="sxs-lookup"><span data-stu-id="c756b-668">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="c756b-669">Prestanda information för kör tid-mutex</span><span class="sxs-lookup"><span data-stu-id="c756b-669">Run-time Mutex Performance Information</span></span>

<span data-ttu-id="c756b-670">ThreadX tillhandahåller valfria prestanda information för körning av mutex.</span><span class="sxs-lookup"><span data-stu-id="c756b-670">ThreadX provides optional run-time mutex performance information.</span></span> <span data-ttu-id="c756b-671">Om ThreadX-biblioteket och programmet har skapats med **TX_MUTEX_ENABLE_PERFORMANCE_INFO** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-671">If the ThreadX library and application is built with **TX_MUTEX_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-672">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-672">Total number for the overall system:</span></span>

- <span data-ttu-id="c756b-673">mutex lägger</span><span class="sxs-lookup"><span data-stu-id="c756b-673">mutex puts</span></span>

- <span data-ttu-id="c756b-674">mutex hämtar</span><span class="sxs-lookup"><span data-stu-id="c756b-674">mutex gets</span></span>

- <span data-ttu-id="c756b-675">mutex get SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-675">mutex get suspensions</span></span>

- <span data-ttu-id="c756b-676">timeout för mutex-hämtning</span><span class="sxs-lookup"><span data-stu-id="c756b-676">mutex get timeouts</span></span>

- <span data-ttu-id="c756b-677">mutex Priority-versioner</span><span class="sxs-lookup"><span data-stu-id="c756b-677">mutex priority inversions</span></span>

- <span data-ttu-id="c756b-678">arv av mutex-prioritet</span><span class="sxs-lookup"><span data-stu-id="c756b-678">mutex priority inheritances</span></span>

<span data-ttu-id="c756b-679">Totalt antal för varje mutex:</span><span class="sxs-lookup"><span data-stu-id="c756b-679">Total number for each mutex:</span></span>

  - <span data-ttu-id="c756b-680">mutex lägger</span><span class="sxs-lookup"><span data-stu-id="c756b-680">mutex puts</span></span>

  - <span data-ttu-id="c756b-681">mutex hämtar</span><span class="sxs-lookup"><span data-stu-id="c756b-681">mutex gets</span></span>

  - <span data-ttu-id="c756b-682">mutex get SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-682">mutex get suspensions</span></span>

  - <span data-ttu-id="c756b-683">timeout för mutex-hämtning</span><span class="sxs-lookup"><span data-stu-id="c756b-683">mutex get timeouts</span></span>

  - <span data-ttu-id="c756b-684">mutex Priority-versioner</span><span class="sxs-lookup"><span data-stu-id="c756b-684">mutex priority inversions</span></span>

  - <span data-ttu-id="c756b-685">arv av mutex-prioritet</span><span class="sxs-lookup"><span data-stu-id="c756b-685">mutex priority inheritances</span></span>

<span data-ttu-id="c756b-686">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_mutex_performance_info_get** _ och _ *_tx_mutex_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-686">This information is available at run-time through the services ***tx_mutex_performance_info_get** _ and _*_tx_mutex_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-687">Information om mutex-prestanda är användbar för att fastställa om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-687">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-688">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-688">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-689">Till exempel kanske ett relativt högt antal "mutex get Times"-tids gränser "föreslår att andra trådar håller resurserna för långa.</span><span class="sxs-lookup"><span data-stu-id="c756b-689">For example, a relatively high number of "mutex get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="c756b-690">Mutex Control Block TX_MUTEX</span><span class="sxs-lookup"><span data-stu-id="c756b-690">Mutex Control Block TX_MUTEX</span></span>

<span data-ttu-id="c756b-691">Egenskaperna för varje mutex finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-691">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="c756b-692">Den innehåller information, till exempel antalet aktuella mutex-ägarskap, tillsammans med pekaren över den tråd som äger mutex.</span><span class="sxs-lookup"><span data-stu-id="c756b-692">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="c756b-693">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-693">This structure is defined in the ***tx_api.h*** file.</span></span> <span data-ttu-id="c756b-694">Mutex Control Block kan finnas var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-694">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="c756b-695">Deadly</span><span class="sxs-lookup"><span data-stu-id="c756b-695">Deadly Embrace</span></span>

<span data-ttu-id="c756b-696">En av de mest intressanta och farliga fall GRO par som är kopplade till mutex-ägande är att *Deadly-kraften*.</span><span class="sxs-lookup"><span data-stu-id="c756b-696">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="c756b-697">En Deadly-begränsning, eller *deadlock*, är ett villkor där två eller flera trådar inaktive ras oändligt under försök att hämta en mutex som redan ägs av de andra trådarna.</span><span class="sxs-lookup"><span data-stu-id="c756b-697">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="c756b-698">*Deadly* -diskussionen och dess lösningar är helt giltiga även för mutex-objektet.</span><span class="sxs-lookup"><span data-stu-id="c756b-698">The discussion of *deadly embrace* and its remedies are completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="c756b-699">Prioritets version</span><span class="sxs-lookup"><span data-stu-id="c756b-699">Priority Inversion</span></span>

<span data-ttu-id="c756b-700">Som tidigare nämnts är en större Pitfall som är kopplad till ömsesidig undantag prioritets version.</span><span class="sxs-lookup"><span data-stu-id="c756b-700">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="c756b-701">Det här avsnittet beskrivs mer fullständigt i "[tråd prioritet fall GRO par](#thread-priority-pitfalls)".</span><span class="sxs-lookup"><span data-stu-id="c756b-701">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="c756b-702">Det grundläggande problemet uppstår i en situation där en tråd med lägre prioritet har en semafor som kräver tråd med högre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-702">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="c756b-703">Detta är normalt.</span><span class="sxs-lookup"><span data-stu-id="c756b-703">This in itself is normal.</span></span> <span data-ttu-id="c756b-704">Trådar med prioriteter mellan dem kan dock orsaka att prioriteten är inaktiv för senaste icke-deterministisk tids period.</span><span class="sxs-lookup"><span data-stu-id="c756b-704">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="c756b-705">Till skillnad från semaforer som diskuterats tidigare har mutex-objektet ThreadX valfria *prioritets arv*.</span><span class="sxs-lookup"><span data-stu-id="c756b-705">Unlike semaphores discussed previously, the ThreadX mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="c756b-706">Den grundläggande idén bakom prioriterad arv är att en tråd med lägre prioritet har sin prioritet tillfälligt upphöjt till prioriteten för en tråd med hög prioritet som vill ha samma mutex som ägs av tråden med lägre prioritet.</span><span class="sxs-lookup"><span data-stu-id="c756b-706">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="c756b-707">När den nedre prioritets tråden frigör mutex återställs den ursprungliga prioriteten och tråden med högre prioritet får ägarskapet av mutexen.</span><span class="sxs-lookup"><span data-stu-id="c756b-707">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="c756b-708">Den här funktionen eliminerar icke-deterministiska prioritets versioner genom att begränsa mängden inversion till den tid som den lägre prioritets tråden innehåller mutex.</span><span class="sxs-lookup"><span data-stu-id="c756b-708">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="c756b-709">De tekniker som beskrivs tidigare i det här kapitlet för att hantera icke-deterministiska prioritets versioner är också även giltiga med mutexer.</span><span class="sxs-lookup"><span data-stu-id="c756b-709">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="c756b-710">Händelse flaggor</span><span class="sxs-lookup"><span data-stu-id="c756b-710">Event Flags</span></span>

<span data-ttu-id="c756b-711">Händelse flaggor är ett kraftfullt verktyg för Thread-synkronisering.</span><span class="sxs-lookup"><span data-stu-id="c756b-711">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="c756b-712">Varje händelse flagga representeras av en enskild bit.</span><span class="sxs-lookup"><span data-stu-id="c756b-712">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="c756b-713">Händelse flaggor är ordnade i grupper om 32.</span><span class="sxs-lookup"><span data-stu-id="c756b-713">Event flags are arranged in groups of 32.</span></span> <span data-ttu-id="c756b-714">Trådar kan köras på alla 32 händelse flaggor i en grupp på samma tid.</span><span class="sxs-lookup"><span data-stu-id="c756b-714">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="c756b-715">Händelser anges av \***tx_event_flags_set** _ och hämtas av _ *_tx_event_flags_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-715">Events are set by ***tx_event_flags_set** _ and are retrieved by _*_tx_event_flags_get_\*\*.</span></span>

<span data-ttu-id="c756b-716">Inställning av händelse flaggor görs med logisk och/eller åtgärd mellan aktuella händelse flaggor och nya händelse flaggor.</span><span class="sxs-lookup"><span data-stu-id="c756b-716">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="c756b-717">Typen av logisk åtgärd (antingen en och eller eller) anges i ***tx_event_flags_set*** -anropet.</span><span class="sxs-lookup"><span data-stu-id="c756b-717">The type of logical operation (either an AND or OR) is specified in the ***tx_event_flags_set*** call.</span></span>

<span data-ttu-id="c756b-718">Det finns liknande logiska alternativ för att hämta händelse flaggor.</span><span class="sxs-lookup"><span data-stu-id="c756b-718">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="c756b-719">En get-begäran kan ange att alla angivna händelse flaggor krävs (ett logiskt och).</span><span class="sxs-lookup"><span data-stu-id="c756b-719">A get request can specify that all specified event flags are required (a logical AND).</span></span>

<span data-ttu-id="c756b-720">Alternativt kan en get-begäran ange att någon av de angivna händelse flaggorna ska uppfylla begäran (ett logiskt eller).</span><span class="sxs-lookup"><span data-stu-id="c756b-720">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="c756b-721">Den typ av logisk åtgärd som är associerad med händelse flaggorna som ska hämtas anges i ***tx_event_flags_get*** -anropet.</span><span class="sxs-lookup"><span data-stu-id="c756b-721">The type of logical operation associated with event flags retrieval is specified in the ***tx_event_flags_get*** call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-722">*Händelse flaggor som uppfyller en get-begäran används, d.v.s. värdet noll, om* **TX_OR_CLEAR** *eller* **TX_AND_CLEAR** *anges i begäran.*</span><span class="sxs-lookup"><span data-stu-id="c756b-722">*Event flags that satisfy a get request are consumed, i.e., set to zero, if* **TX_OR_CLEAR** *or* **TX_AND_CLEAR** *are specified by the request.*</span></span>

<span data-ttu-id="c756b-723">Varje händelse flaggor grupp är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-723">Each event flags group is a public resource.</span></span> <span data-ttu-id="c756b-724">ThreadX placerar inga begränsningar för hur grupper av händelse flaggor används.</span><span class="sxs-lookup"><span data-stu-id="c756b-724">ThreadX places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="c756b-725">Skapa händelse flaggor grupper</span><span class="sxs-lookup"><span data-stu-id="c756b-725">Creating Event Flags Groups</span></span>

<span data-ttu-id="c756b-726">Händelse flaggor grupper skapas antingen under initiering eller under körning av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-726">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-727">När de skapas har alla händelse flaggor i gruppen värdet noll.</span><span class="sxs-lookup"><span data-stu-id="c756b-727">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="c756b-728">Det finns ingen gräns för antalet händelse flaggor grupper i ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-728">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c756b-729">Tråd upphängning</span><span class="sxs-lookup"><span data-stu-id="c756b-729">Thread Suspension</span></span>

<span data-ttu-id="c756b-730">Program trådar kan pausas vid försök att hämta en logisk kombination av händelse flaggor från en grupp.</span><span class="sxs-lookup"><span data-stu-id="c756b-730">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="c756b-731">När en händelse flagga har angetts granskas get-begäranden för alla pausade trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-731">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="c756b-732">Alla trådar som nu har de nödvändiga händelse flaggorna återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-732">All the threads that now have the required event flags are resumed.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-733">*Alla pausade trådar i en händelse flaggas grupp granskas när dess händelse flaggor anges. Det innebär naturligtvis ytterligare kostnader. Därför är det bra att begränsa antalet trådar som använder samma händelse flagg grupp till ett rimligt tal.*</span><span class="sxs-lookup"><span data-stu-id="c756b-733">*All suspended threads on an event flag group are reviewed when its event flags are set. This, of course, introduces additional overhead. Therefore, it is good practice to limit the number of threads using the same event flag group to a reasonable number.*</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="c756b-734">Händelse flaggor ange meddelande</span><span class="sxs-lookup"><span data-stu-id="c756b-734">Event Flags Set Notification</span></span>

<span data-ttu-id="c756b-735">Vissa program kan vara fördelaktiga att meddelas när en händelse flagga har angetts.</span><span class="sxs-lookup"><span data-stu-id="c756b-735">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="c756b-736">ThreadX tillhandahåller den här funktionen genom ***tx_event_flags_set_notifys*** tjänsten.</span><span class="sxs-lookup"><span data-stu-id="c756b-736">ThreadX provides this ability through the ***tx_event_flags_set_notify*** service.</span></span> <span data-ttu-id="c756b-737">Den här tjänsten registrerar den angivna program aviserings funktionen med den angivna händelse flaggas gruppen.</span><span class="sxs-lookup"><span data-stu-id="c756b-737">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="c756b-738">ThreadX kommer sedan att anropa den här program aviserings funktionen när en händelse flagga i gruppen anges.</span><span class="sxs-lookup"><span data-stu-id="c756b-738">ThreadX will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="c756b-739">Den exakta bearbetningen inom programmets meddelande funktion bestäms av programmet, men det består vanligt vis av att återuppta den aktuella tråden för att bearbeta den nya händelse flaggan.</span><span class="sxs-lookup"><span data-stu-id="c756b-739">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span>

### <a name="event-flags-event-chainingtrade"></a><span data-ttu-id="c756b-740">Händelse länkning för händelse flaggor&trade;</span><span class="sxs-lookup"><span data-stu-id="c756b-740">Event Flags Event chaining&trade;</span></span>

<span data-ttu-id="c756b-741">Aviserings funktionerna i ThreadX kan användas för att "kedja" olika synkroniserings händelser tillsammans.</span><span class="sxs-lookup"><span data-stu-id="c756b-741">The notification capabilities in ThreadX can be used to "chain" various synchronization events together.</span></span> <span data-ttu-id="c756b-742">Detta är vanligt vis användbart när en enskild tråd måste bearbeta flera synkroniseringsanvändare.</span><span class="sxs-lookup"><span data-stu-id="c756b-742">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="c756b-743">I stället för att en separat tråd pausas för ett köat meddelande, händelse flaggor och en semafor, kan programmet registrera en avisering för varje objekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-743">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="c756b-744">Vid anrop kan program aviserings rutinen återupptas och sedan återuppta en enda tråd, som kan söka varje objekt för att hitta och bearbeta den nya händelsen.</span><span class="sxs-lookup"><span data-stu-id="c756b-744">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="c756b-745">I allmänhet resulterar *händelse länkning* i färre trådar, mindre omkostnader och mindre RAM-krav.</span><span class="sxs-lookup"><span data-stu-id="c756b-745">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="c756b-746">Det ger också en mycket flexibel mekanism för att hantera krav för synkronisering av mer komplexa system.</span><span class="sxs-lookup"><span data-stu-id="c756b-746">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="c756b-747">Prestanda information för kör tids händelse flaggor</span><span class="sxs-lookup"><span data-stu-id="c756b-747">Run-time Event Flags Performance Information</span></span>

<span data-ttu-id="c756b-748">ThreadX tillhandahåller valfria prestanda information för kör tids händelse flaggor.</span><span class="sxs-lookup"><span data-stu-id="c756b-748">ThreadX provides optional run-time event flags performance information.</span></span> <span data-ttu-id="c756b-749">Om ThreadX-biblioteket och programmet har skapats med **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-749">If the ThreadX library and application is built with **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-750">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-750">Total number for the overall system:</span></span>

  - <span data-ttu-id="c756b-751">händelse flaggor uppsättningar</span><span class="sxs-lookup"><span data-stu-id="c756b-751">event flags sets</span></span>

  - <span data-ttu-id="c756b-752">händelse flaggor hämtas</span><span class="sxs-lookup"><span data-stu-id="c756b-752">event flags gets</span></span>

  - <span data-ttu-id="c756b-753">händelse flaggor hämta SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-753">event flags get suspensions</span></span>

  - <span data-ttu-id="c756b-754">händelse flaggor Hämta timeout</span><span class="sxs-lookup"><span data-stu-id="c756b-754">event flags get timeouts</span></span>

<span data-ttu-id="c756b-755">Totalt antal för varje händelse flaggor grupp:</span><span class="sxs-lookup"><span data-stu-id="c756b-755">Total number for each event flags group:</span></span>

  - <span data-ttu-id="c756b-756">händelse flaggor uppsättningar</span><span class="sxs-lookup"><span data-stu-id="c756b-756">event flags sets</span></span>

  - <span data-ttu-id="c756b-757">händelse flaggor hämtas</span><span class="sxs-lookup"><span data-stu-id="c756b-757">event flags gets</span></span>

  - <span data-ttu-id="c756b-758">händelse flaggor hämta SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-758">event flags get suspensions</span></span>

  - <span data-ttu-id="c756b-759">händelse flaggor Hämta timeout</span><span class="sxs-lookup"><span data-stu-id="c756b-759">event flags get timeouts</span></span>

<span data-ttu-id="c756b-760">Den här informationen är tillgänglig i körnings läge genom tjänsterna ***tx_event_flags_performance_info_get** _ och _*_tx_event_flags_performance_system_info_get_\*_.</span><span class="sxs-lookup"><span data-stu-id="c756b-760">This information is available at run-time through the services ***tx_event_flags_performance_info_get** _ and _*_tx_event_flags_performance_system_info_get_\*_.</span></span> <span data-ttu-id="c756b-761">Prestanda informationen för händelse flaggor är användbar för att fastställa om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-761">The performance information of event flags is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-762">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-762">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-763">Till exempel kan ett relativt högt antal tids gränser på den _ \*_tx_event_flags_get_\*\*-tjänsten föreslå att tids gränsen för inaktive ring av händelse flaggor är för kort.</span><span class="sxs-lookup"><span data-stu-id="c756b-763">For example, a relatively high number of timeouts on the _ *_tx_event_flags_get_*\* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="c756b-764">Händelse flaggor grupp kontroll block TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="c756b-764">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>

<span data-ttu-id="c756b-765">Egenskaperna för varje händelse flaggas grupp finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-765">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="c756b-766">Den innehåller information som de aktuella inställningarna för händelse flaggor och antalet trådar som har avbrutits för händelser.</span><span class="sxs-lookup"><span data-stu-id="c756b-766">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="c756b-767">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-767">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-768">Kontroll block för händelse grupper kan finnas var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-768">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="memory-block-pools"></a><span data-ttu-id="c756b-769">Pool för minnes block</span><span class="sxs-lookup"><span data-stu-id="c756b-769">Memory Block Pools</span></span>

<span data-ttu-id="c756b-770">Att allokera minne på ett snabbt och entydigt sätt är alltid en utmaning i real tids program.</span><span class="sxs-lookup"><span data-stu-id="c756b-770">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="c756b-771">Med detta i åtanke ger ThreadX möjlighet att skapa och hantera flera pooler med minnes block med fast storlek.</span><span class="sxs-lookup"><span data-stu-id="c756b-771">With this in mind, ThreadX provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="c756b-772">Eftersom minnes Blocks pooler består av block med fast storlek, finns det aldrig några fragmenterings problem.</span><span class="sxs-lookup"><span data-stu-id="c756b-772">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="c756b-773">Fragmenteringen orsakar naturligtvis att beteendet är icke deterministiskt.</span><span class="sxs-lookup"><span data-stu-id="c756b-773">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="c756b-774">Dessutom är tiden som krävs för att allokera och frigöra ett minnes block med fast storlek jämförbar med det för enkel manipulering av länkade listor.</span><span class="sxs-lookup"><span data-stu-id="c756b-774">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="c756b-775">Dessutom görs tilldelningen av minnes block och avallokering i huvudet i listan över tillgängliga.</span><span class="sxs-lookup"><span data-stu-id="c756b-775">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="c756b-776">Detta ger snabbast möjlig länkad List bearbetning och kan hjälpa till att behålla det faktiska minnes blocket i cachen.</span><span class="sxs-lookup"><span data-stu-id="c756b-776">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="c756b-777">Brist på flexibilitet är den största nack delen med minnes pooler med fast storlek.</span><span class="sxs-lookup"><span data-stu-id="c756b-777">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="c756b-778">Block storleken för en pool måste vara tillräckligt stor för att hantera de sämsta fall minnes kraven för sina användare.</span><span class="sxs-lookup"><span data-stu-id="c756b-778">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="c756b-779">Naturligtvis kan minnet slösas om många olika storleks minnes begär Anden görs i samma pool.</span><span class="sxs-lookup"><span data-stu-id="c756b-779">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="c756b-780">En möjlig lösning är att göra flera olika minnes Blocks pooler som innehåller olika minnes block i storlek.</span><span class="sxs-lookup"><span data-stu-id="c756b-780">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="c756b-781">Varje minnes Blocks pool är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-781">Each memory block pool is a public resource.</span></span> <span data-ttu-id="c756b-782">ThreadX placerar inga begränsningar för hur pooler används.</span><span class="sxs-lookup"><span data-stu-id="c756b-782">ThreadX places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="c756b-783">Skapa minnes Blocks pooler</span><span class="sxs-lookup"><span data-stu-id="c756b-783">Creating Memory Block Pools</span></span>

<span data-ttu-id="c756b-784">Minnes Blocks pooler skapas antingen under initieringen eller under körningen av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-784">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-785">Det finns ingen gräns för antalet minnes Blocks pooler i ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-785">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="c756b-786">Minnes block storlek</span><span class="sxs-lookup"><span data-stu-id="c756b-786">Memory Block Size</span></span>

<span data-ttu-id="c756b-787">Som tidigare nämnts innehåller Memory block-pooler ett antal block med fast storlek.</span><span class="sxs-lookup"><span data-stu-id="c756b-787">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="c756b-788">Block storleken, i byte, anges när poolen skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-788">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-789">*ThreadX lägger till en liten mängd kostnader – storleken på en C-pekare – till varje minnes block i poolen. Dessutom kan ThreadX behöva fylla block storleken för att behålla början på varje minnes block vid rätt justering.*</span><span class="sxs-lookup"><span data-stu-id="c756b-789">*ThreadX adds a small amount of overhead—the size of a C pointer—to each memory block in the pool. In addition, ThreadX might have to pad the block size to keep the beginning of each memory block on proper alignment.*</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="c756b-790">Pool-kapacitet</span><span class="sxs-lookup"><span data-stu-id="c756b-790">Pool Capacity</span></span>

<span data-ttu-id="c756b-791">Antalet minnes block i en pool är en funktion i block storlek och det totala antalet byte i minnes området som angavs när den skapades.</span><span class="sxs-lookup"><span data-stu-id="c756b-791">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="c756b-792">Kapaciteten för en pool beräknas genom att block storleken divideras (inklusive utfyllnad och övergångs byte) till det totala antalet byte i det angivna minnes området.</span><span class="sxs-lookup"><span data-stu-id="c756b-792">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="c756b-793">Poolens minnes områden</span><span class="sxs-lookup"><span data-stu-id="c756b-793">Pool's Memory Area</span></span>

<span data-ttu-id="c756b-794">Som tidigare nämnts anges minnes området för block-poolen när den skapas.</span><span class="sxs-lookup"><span data-stu-id="c756b-794">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="c756b-795">Precis som andra minnes områden i ThreadX kan det finnas var som helst i målets adress utrymme.</span><span class="sxs-lookup"><span data-stu-id="c756b-795">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="c756b-796">Detta är en viktig funktion på grund av den stora flexibiliteten.</span><span class="sxs-lookup"><span data-stu-id="c756b-796">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="c756b-797">Anta till exempel att en kommunikations produkt har ett highspeed minnes utrymme för I/O.</span><span class="sxs-lookup"><span data-stu-id="c756b-797">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="c756b-798">Det här minnes området hanteras enkelt genom att göra det till en ThreadX-pool för minnes block.</span><span class="sxs-lookup"><span data-stu-id="c756b-798">This memory area is easily managed by making it into a ThreadX memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c756b-799">Tråd upphängning</span><span class="sxs-lookup"><span data-stu-id="c756b-799">Thread Suspension</span></span>

<span data-ttu-id="c756b-800">Program trådar kan pausas i väntan på ett minnes block från en tom pool.</span><span class="sxs-lookup"><span data-stu-id="c756b-800">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="c756b-801">När ett block returneras till poolen får den pausade tråden det här blocket och tråden återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-801">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="c756b-802">Om flera trådar har pausats på samma minnes Blocks pool återupptas de i den ordning som de var pausade (FIFO).</span><span class="sxs-lookup"><span data-stu-id="c756b-802">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="c756b-803">Men prioritets återupptagning är också möjligt om programmet anropar ***tx_block_pool_prioritize*** före det blockerade release-anropet som lyfter upp tråd upphängning.</span><span class="sxs-lookup"><span data-stu-id="c756b-803">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="c756b-804">Prioritets tjänsten för block pool placerar den högsta prioritets tråden längst fram i uppskjutnings listan, samtidigt som alla andra pausade trådar i samma FIFO-ordning lämnas kvar.</span><span class="sxs-lookup"><span data-stu-id="c756b-804">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="c756b-805">Prestanda information för kör tid för block pool</span><span class="sxs-lookup"><span data-stu-id="c756b-805">Run-time Block Pool Performance Information</span></span>

<span data-ttu-id="c756b-806">ThreadX tillhandahåller valfri prestanda information för körning av programpooler.</span><span class="sxs-lookup"><span data-stu-id="c756b-806">ThreadX provides optional run-time block pool performance information.</span></span> <span data-ttu-id="c756b-807">Om ThreadX-biblioteket och programmet har skapats med **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-807">If the ThreadX library and application is built with **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-808">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-808">Total number for the overall system:</span></span>

  - <span data-ttu-id="c756b-809">tilldelade block</span><span class="sxs-lookup"><span data-stu-id="c756b-809">blocks allocated</span></span>

  - <span data-ttu-id="c756b-810">släppta block</span><span class="sxs-lookup"><span data-stu-id="c756b-810">blocks released</span></span>

  - <span data-ttu-id="c756b-811">tilldelnings SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-811">allocation suspensions</span></span>

  - <span data-ttu-id="c756b-812">tids gräns för tilldelning</span><span class="sxs-lookup"><span data-stu-id="c756b-812">allocation timeouts</span></span>

<span data-ttu-id="c756b-813">Totalt antal för varje block pool:</span><span class="sxs-lookup"><span data-stu-id="c756b-813">Total number for each block pool:</span></span>

  - <span data-ttu-id="c756b-814">tilldelade block</span><span class="sxs-lookup"><span data-stu-id="c756b-814">blocks allocated</span></span>

  - <span data-ttu-id="c756b-815">släppta block</span><span class="sxs-lookup"><span data-stu-id="c756b-815">blocks released</span></span>

  - <span data-ttu-id="c756b-816">tilldelnings SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-816">allocation suspensions</span></span>

  - <span data-ttu-id="c756b-817">tids gräns för tilldelning</span><span class="sxs-lookup"><span data-stu-id="c756b-817">allocation timeouts</span></span>

<span data-ttu-id="c756b-818">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_block_pool_performance_info_get** _ och _ *_tx_block_pool_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-818">This information is available at run-time through the services ***tx_block_pool_performance_info_get** _ and _*_tx_block_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-819">Det är praktiskt att blockera poolens prestanda information när programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-819">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-820">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-820">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-821">Till exempel kan ett relativt högt antal "tilldelnings SUS pensioner" innebära att den blockerande poolen är för liten.</span><span class="sxs-lookup"><span data-stu-id="c756b-821">For example, a relatively high number of "allocation suspensions" might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="c756b-822">Minnes Blocks kontroll block TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="c756b-822">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>

<span data-ttu-id="c756b-823">Egenskaperna för varje minnes Blocks pool finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-823">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="c756b-824">Den innehåller information som till exempel antalet tillgängliga minnes block och storleken på minnesbufferten.</span><span class="sxs-lookup"><span data-stu-id="c756b-824">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="c756b-825">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-825">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-826">Du kan också placera kontroll block var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-826">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="c756b-827">Skriva över minnes block</span><span class="sxs-lookup"><span data-stu-id="c756b-827">Overwriting Memory Blocks</span></span>

<span data-ttu-id="c756b-828">Det är viktigt att se till att användaren av ett allokerat minnes block inte skriver utanför dess gränser.</span><span class="sxs-lookup"><span data-stu-id="c756b-828">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="c756b-829">Om detta händer inträffar skada i ett intilliggande minnes område (vanligt vis senare).</span><span class="sxs-lookup"><span data-stu-id="c756b-829">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="c756b-830">Resultatet är oförutsägbart och ofta allvarligt för programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-830">The results are unpredictable and often fatal to the application.</span></span>

## <a name="memory-byte-pools"></a><span data-ttu-id="c756b-831">Minnes byte pooler</span><span class="sxs-lookup"><span data-stu-id="c756b-831">Memory Byte Pools</span></span>

<span data-ttu-id="c756b-832">ThreadX minnes byte pooler liknar en standard-C-heap.</span><span class="sxs-lookup"><span data-stu-id="c756b-832">ThreadX memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="c756b-833">Till skillnad från standard-C-heapen är det möjligt att ha flera minnes byte pooler.</span><span class="sxs-lookup"><span data-stu-id="c756b-833">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="c756b-834">Dessutom kan trådar pausa på en pool tills det begärda minnet är tillgängligt.</span><span class="sxs-lookup"><span data-stu-id="c756b-834">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="c756b-835">Tilldelningar från poolerna för minnes byte liknar traditionella \***malloc** _-anrop, vilket innefattar mängden minne som önskas (i byte).</span><span class="sxs-lookup"><span data-stu-id="c756b-835">Allocations from memory byte pools are similar to traditional \***malloc** _ calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="c756b-836">Minne tilldelas från poolen på ett _first-passning \* sätt; dvs. det första lediga minnes blocket som uppfyller begäran används.</span><span class="sxs-lookup"><span data-stu-id="c756b-836">Memory is allocated from the pool in a _first-fit\* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="c756b-837">Överflödigt minne från det här blocket konverteras till ett nytt block och placeras i listan över lediga minnen igen.</span><span class="sxs-lookup"><span data-stu-id="c756b-837">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="c756b-838">Den här processen kallas *fragmentering*.</span><span class="sxs-lookup"><span data-stu-id="c756b-838">This process is called *fragmentation*.</span></span>

<span data-ttu-id="c756b-839">Intilliggande lediga minnes block *sammanfogas* tillsammans under en efterföljande tilldelnings sökning för att få tillräckligt med ledigt minnes block.</span><span class="sxs-lookup"><span data-stu-id="c756b-839">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="c756b-840">Den här processen kallas *defragmentering*.</span><span class="sxs-lookup"><span data-stu-id="c756b-840">This process is called *defragmentation*.</span></span>

<span data-ttu-id="c756b-841">Varje pool för minnes byte är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-841">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="c756b-842">ThreadX placerar inga begränsningar för hur pooler används, förutom att minnes byte tjänster inte kan anropas från ISR: er.</span><span class="sxs-lookup"><span data-stu-id="c756b-842">ThreadX places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="c756b-843">Skapa minnes byte pooler</span><span class="sxs-lookup"><span data-stu-id="c756b-843">Creating Memory Byte Pools</span></span>

<span data-ttu-id="c756b-844">Minnes byte pooler skapas antingen under initieringen eller under körningen av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-844">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-845">Det finns ingen gräns för antalet minnes byte pooler i ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-845">There is no limit on the number of memory byte pools in an application.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="c756b-846">Pool-kapacitet</span><span class="sxs-lookup"><span data-stu-id="c756b-846">Pool Capacity</span></span>

<span data-ttu-id="c756b-847">Antalet allocatable byte i en pool för minnes byte är något mindre än vad som angavs när det skapades.</span><span class="sxs-lookup"><span data-stu-id="c756b-847">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="c756b-848">Detta beror på att hanteringen av det lediga minnes området introducerar en del kostnader.</span><span class="sxs-lookup"><span data-stu-id="c756b-848">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="c756b-849">Varje ledigt minnes block i poolen kräver motsvarande två C-pekare.</span><span class="sxs-lookup"><span data-stu-id="c756b-849">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="c756b-850">Dessutom skapas poolen med två block, ett stort ledigt block och ett litet permanent allokerat block i slutet av minnes området.</span><span class="sxs-lookup"><span data-stu-id="c756b-850">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="c756b-851">Detta allokerade block används för att förbättra prestandan för algoritmen.</span><span class="sxs-lookup"><span data-stu-id="c756b-851">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="c756b-852">Den eliminerar behovet av att kontinuerligt kontrol lera om poolens slut under sammanfogningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-852">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>

<span data-ttu-id="c756b-853">Under körningen ökar mängden omkostnader i poolen vanligt vis.</span><span class="sxs-lookup"><span data-stu-id="c756b-853">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="c756b-854">Allokeringar av ett udda antal byte fylls i för att säkerställa korrekt justering av nästa minnes block.</span><span class="sxs-lookup"><span data-stu-id="c756b-854">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="c756b-855">Dessutom ökar belastningen när poolen blir mer fragmenterad.</span><span class="sxs-lookup"><span data-stu-id="c756b-855">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="c756b-856">Poolens minnes områden</span><span class="sxs-lookup"><span data-stu-id="c756b-856">Pool's Memory Area</span></span>

<span data-ttu-id="c756b-857">Minnes området för en Memory byte-pool anges när du skapar.</span><span class="sxs-lookup"><span data-stu-id="c756b-857">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="c756b-858">Precis som andra minnes områden i ThreadX kan det finnas var som helst i målets adress utrymme.</span><span class="sxs-lookup"><span data-stu-id="c756b-858">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="c756b-859">Detta är en viktig funktion på grund av den stora flexibiliteten.</span><span class="sxs-lookup"><span data-stu-id="c756b-859">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="c756b-860">Om mål maskin varan till exempel har ett höghastighets minnes område och ett minnes kort med låg hastighet, kan användaren hantera minnesallokering för båda områdena genom att skapa en pool i var och en av dem.</span><span class="sxs-lookup"><span data-stu-id="c756b-860">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c756b-861">Tråd upphängning</span><span class="sxs-lookup"><span data-stu-id="c756b-861">Thread Suspension</span></span>

<span data-ttu-id="c756b-862">Program trådar kan pausas i väntan på minnes byte från en pool.</span><span class="sxs-lookup"><span data-stu-id="c756b-862">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="c756b-863">När tillräckligt sammanhängande minne blir tillgängligt får de pausade trådarna det begärda minnet och trådarna återupptas.</span><span class="sxs-lookup"><span data-stu-id="c756b-863">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span>

<span data-ttu-id="c756b-864">Om flera trådar har pausats på samma minnes byte pool, tilldelas de minne (återupptas) i den ordning som de var pausade (FIFO).</span><span class="sxs-lookup"><span data-stu-id="c756b-864">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="c756b-865">Men prioritets återupptagning är också möjligt om programmet anropar ***tx_byte_pool_prioritize*** före byte release-anropet som lyfter upp tråd upphängning.</span><span class="sxs-lookup"><span data-stu-id="c756b-865">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="c756b-866">Prioritets tjänsten för byte av byte placerar den högsta prioritets tråden längst fram i uppskjutnings listan, samtidigt som alla andra pausade trådar i samma FIFO-ordning lämnas kvar.</span><span class="sxs-lookup"><span data-stu-id="c756b-866">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="c756b-867">Prestanda information för kör tids byte-pool</span><span class="sxs-lookup"><span data-stu-id="c756b-867">Run-time Byte Pool Performance Information</span></span>

<span data-ttu-id="c756b-868">ThreadX tillhandahåller valfria prestanda information för prestanda information för kör tids byte.</span><span class="sxs-lookup"><span data-stu-id="c756b-868">ThreadX provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="c756b-869">Om ThreadX-biblioteket och programmet har skapats med ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** definierat, samlar ThreadX in följande information.</span><span class="sxs-lookup"><span data-stu-id="c756b-869">If the ThreadX library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-870">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-870">Total number for the overall system:</span></span>

  - <span data-ttu-id="c756b-871">allokeringar</span><span class="sxs-lookup"><span data-stu-id="c756b-871">allocations</span></span>

  - <span data-ttu-id="c756b-872">versioner</span><span class="sxs-lookup"><span data-stu-id="c756b-872">releases</span></span>

  - <span data-ttu-id="c756b-873">genomsökta fragment</span><span class="sxs-lookup"><span data-stu-id="c756b-873">fragments searched</span></span>

  - <span data-ttu-id="c756b-874">sammanfogade fragment</span><span class="sxs-lookup"><span data-stu-id="c756b-874">fragments merged</span></span>

  - <span data-ttu-id="c756b-875">skapade fragment</span><span class="sxs-lookup"><span data-stu-id="c756b-875">fragments created</span></span>

  - <span data-ttu-id="c756b-876">tilldelnings SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-876">allocation suspensions</span></span>

  - <span data-ttu-id="c756b-877">tids gräns för tilldelning</span><span class="sxs-lookup"><span data-stu-id="c756b-877">allocation timeouts</span></span>

<span data-ttu-id="c756b-878">Totalt antal för varje byte-pool:</span><span class="sxs-lookup"><span data-stu-id="c756b-878">Total number for each byte pool:</span></span>

  - <span data-ttu-id="c756b-879">allokeringar</span><span class="sxs-lookup"><span data-stu-id="c756b-879">allocations</span></span>

  - <span data-ttu-id="c756b-880">versioner</span><span class="sxs-lookup"><span data-stu-id="c756b-880">releases</span></span>

  - <span data-ttu-id="c756b-881">genomsökta fragment</span><span class="sxs-lookup"><span data-stu-id="c756b-881">fragments searched</span></span>

  - <span data-ttu-id="c756b-882">sammanfogade fragment</span><span class="sxs-lookup"><span data-stu-id="c756b-882">fragments merged</span></span>

  - <span data-ttu-id="c756b-883">skapade fragment</span><span class="sxs-lookup"><span data-stu-id="c756b-883">fragments created</span></span>

  - <span data-ttu-id="c756b-884">tilldelnings SUS pensioner</span><span class="sxs-lookup"><span data-stu-id="c756b-884">allocation suspensions</span></span>

  - <span data-ttu-id="c756b-885">tids gräns för tilldelning</span><span class="sxs-lookup"><span data-stu-id="c756b-885">allocation timeouts</span></span>

<span data-ttu-id="c756b-886">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_byte_pool_performance_info_get** _ och _ *_tx_byte_pool_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-886">This information is available at run-time through the services ***tx_byte_pool_performance_info_get** _ and _*_tx_byte_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-887">Prestanda informationen för byte-poolen är användbar för att fastställa om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-887">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-888">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-888">It is also useful in optimizing the application.</span></span> <span data-ttu-id="c756b-889">Till exempel kan ett relativt högt antal "tilldelnings SUS pensioner" föreslå att byte-poolen är för liten.</span><span class="sxs-lookup"><span data-stu-id="c756b-889">For example, a relatively high number of "allocation suspensions" might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="c756b-890">Kontroll block TX_BYTE_POOL för minnes-byte-pool</span><span class="sxs-lookup"><span data-stu-id="c756b-890">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>

<span data-ttu-id="c756b-891">Egenskaperna för varje pool för minnes byte finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-891">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="c756b-892">Den innehåller användbar information, till exempel antalet tillgängliga byte i poolen.</span><span class="sxs-lookup"><span data-stu-id="c756b-892">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="c756b-893">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-893">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-894">Du kan också placera kontroll block var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-894">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="nondeterministic-behavior"></a><span data-ttu-id="c756b-895">Icke-deterministiskt beteende</span><span class="sxs-lookup"><span data-stu-id="c756b-895">Nondeterministic Behavior</span></span>

<span data-ttu-id="c756b-896">Även om minnes byte pooler ger mest flexibel minnesallokering, har de också en något icke deterministisk funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-896">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="c756b-897">Till exempel kan en minnes byte pool ha 2 000 byte tillgängligt minne, men kanske inte kan uppfylla en tilldelnings förfrågan på 1 000 byte.</span><span class="sxs-lookup"><span data-stu-id="c756b-897">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="c756b-898">Det beror på att det inte finns några garantier för hur många lediga byte som är sammanhängande.</span><span class="sxs-lookup"><span data-stu-id="c756b-898">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="c756b-899">Även om det finns ett ledigt block på 1 000 byte finns det inga garantier för hur lång tid det tar att hitta blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-899">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="c756b-900">Det är helt möjligt att hela lagringspoolen måste sökas för att hitta 1 000 byte-blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-900">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span>

> [!TIP]
> <span data-ttu-id="c756b-901">*Som ett resultat av det icke deterministiska beteendet för minnes byte pooler är det vanligt vis bra att undvika att använda minnes byte tjänster i områden där deterministisk, real tids beteende krävs. Många program förallokerar det minne som krävs för att förallokeras under initiering eller körnings tids konfiguration.*</span><span class="sxs-lookup"><span data-stu-id="c756b-901">*As a result of the nondeterministic behavior of memory byte pools, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required. Many applications pre-allocate their required memory during initialization or run-time configuration.*</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="c756b-902">Skriva över minnes block</span><span class="sxs-lookup"><span data-stu-id="c756b-902">Overwriting Memory Blocks</span></span>

<span data-ttu-id="c756b-903">Det är viktigt att se till att användaren av allokerat minne inte skriver utanför dess gränser.</span><span class="sxs-lookup"><span data-stu-id="c756b-903">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="c756b-904">Om detta händer inträffar skada i ett intilliggande minnes område (vanligt vis senare).</span><span class="sxs-lookup"><span data-stu-id="c756b-904">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="c756b-905">Resultatet är oförutsägbart och ofta oåterkalleligt för program körning.</span><span class="sxs-lookup"><span data-stu-id="c756b-905">The results are unpredictable and often catastrophic for program execution.</span></span>

## <a name="application-timers"></a><span data-ttu-id="c756b-906">Program timers</span><span class="sxs-lookup"><span data-stu-id="c756b-906">Application Timers</span></span>

<span data-ttu-id="c756b-907">Snabba svar på asynkrona externa händelser är den viktigaste funktionen för inbäddade program i real tid.</span><span class="sxs-lookup"><span data-stu-id="c756b-907">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="c756b-908">Många av dessa program måste dock också utföra vissa aktiviteter vid förinställda tids perioder.</span><span class="sxs-lookup"><span data-stu-id="c756b-908">However, many of these applications must also perform certain activities at predetermined intervals of time.</span></span>

<span data-ttu-id="c756b-909">ThreadX-programtimers tillhandahåller program med möjlighet att köra program C-funktioner vid specifika tidsintervall.</span><span class="sxs-lookup"><span data-stu-id="c756b-909">ThreadX application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="c756b-910">Det är också möjligt att ett programs timer upphör att gälla en gång.</span><span class="sxs-lookup"><span data-stu-id="c756b-910">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="c756b-911">Den här typen av timer kallas för en väntande *timer*, medan timers med upprepade intervall kallas *periodiska timers*.</span><span class="sxs-lookup"><span data-stu-id="c756b-911">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="c756b-912">Varje program timer är en offentlig resurs.</span><span class="sxs-lookup"><span data-stu-id="c756b-912">Each application timer is a public resource.</span></span> <span data-ttu-id="c756b-913">ThreadX placerar inga begränsningar för hur Application timers används.</span><span class="sxs-lookup"><span data-stu-id="c756b-913">ThreadX places no constraints on how application timers are used.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="c756b-914">Tidsintervall</span><span class="sxs-lookup"><span data-stu-id="c756b-914">Timer Intervals</span></span>

<span data-ttu-id="c756b-915">I ThreadX tidsintervaller mäts av periodiska timer-avbrott.</span><span class="sxs-lookup"><span data-stu-id="c756b-915">In ThreadX time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="c756b-916">Varje timer-avbrott kallas för ett timer- *Tick*.</span><span class="sxs-lookup"><span data-stu-id="c756b-916">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="c756b-917">Den faktiska tiden mellan timer-Tick anges av programmet, men 10ms är normen för de flesta implementeringar.</span><span class="sxs-lookup"><span data-stu-id="c756b-917">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="c756b-918">Den periodiska tids inställningen finns vanligt vis i ***tx_initialize_low_level*** sammansättnings filen.</span><span class="sxs-lookup"><span data-stu-id="c756b-918">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="c756b-919">Det är värt att nämna att den underliggande maskin varan måste ha möjlighet att generera periodiska avbrott för att program timers ska fungera.</span><span class="sxs-lookup"><span data-stu-id="c756b-919">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="c756b-920">I vissa fall har processorn en inbyggd periodisk avbrotts funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-920">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="c756b-921">Om processorn inte har denna möjlighet måste användarens tavla ha en kring utrustning som kan generera periodiska avbrott.</span><span class="sxs-lookup"><span data-stu-id="c756b-921">If the processor doesn't have this ability, the user's board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-922">*ThreadX kan fortfarande fungera även utan en regelbunden avbrotts källa. All timer-relaterad bearbetning inaktive ras dock. Detta omfattar timeslicing, uppskjutnings tids gränser och timer-tjänster.*</span><span class="sxs-lookup"><span data-stu-id="c756b-922">*ThreadX can still function even without a periodic interrupt source. However, all timer-related processing is then disabled. This includes timeslicing, suspension time-outs, and timer services.*</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="c756b-923">Tids exakthet</span><span class="sxs-lookup"><span data-stu-id="c756b-923">Timer Accuracy</span></span>

<span data-ttu-id="c756b-924">Timer-förfaller anges i förhållande till Tick.</span><span class="sxs-lookup"><span data-stu-id="c756b-924">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="c756b-925">Det angivna värdet för förfallo tid minskas med ett på varje timer-Ticket.</span><span class="sxs-lookup"><span data-stu-id="c756b-925">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="c756b-926">Eftersom en programtimer kunde aktive ras precis före ett timer-avbrott (eller timer Ticket), kan den faktiska förfallo tiden vara upp till ett kort tidigt.</span><span class="sxs-lookup"><span data-stu-id="c756b-926">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="c756b-927">Om timer-skalstrecket är 10ms kan programtimers förfalla upp till 10ms tidigt.</span><span class="sxs-lookup"><span data-stu-id="c756b-927">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="c756b-928">Detta är mer betydelsefullt för 10ms timers än 1 andra timers.</span><span class="sxs-lookup"><span data-stu-id="c756b-928">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="c756b-929">Om du ökar den tids lösa frekvensen minskar dock den här fel marginalen.</span><span class="sxs-lookup"><span data-stu-id="c756b-929">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="c756b-930">Timer-körning</span><span class="sxs-lookup"><span data-stu-id="c756b-930">Timer Execution</span></span>

<span data-ttu-id="c756b-931">Program timers körs i den ordning som de blir aktiva.</span><span class="sxs-lookup"><span data-stu-id="c756b-931">Application timers execute in the order they become active.</span></span> <span data-ttu-id="c756b-932">Om till exempel tre timers har skapats med samma förfallo värde och aktive ras, så garanteras att deras motsvarande utgångs funktioner kan köras i den ordning som de aktiverades.</span><span class="sxs-lookup"><span data-stu-id="c756b-932">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span>

### <a name="creating-application-timers"></a><span data-ttu-id="c756b-933">Skapa timers för program</span><span class="sxs-lookup"><span data-stu-id="c756b-933">Creating Application Timers</span></span>

<span data-ttu-id="c756b-934">Program timers skapas antingen under initieringen eller under körningen av program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-934">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="c756b-935">Det finns ingen gräns för antalet program timers i ett program.</span><span class="sxs-lookup"><span data-stu-id="c756b-935">There is no limit on the number of application timers in an application.</span></span>

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="c756b-936">Prestanda information för programtimern för program</span><span class="sxs-lookup"><span data-stu-id="c756b-936">Run-time Application Timer Performance Information</span></span>

<span data-ttu-id="c756b-937">ThreadX tillhandahåller valfria prestanda information för programtimern för program.</span><span class="sxs-lookup"><span data-stu-id="c756b-937">ThreadX provides optional run-time application timer performance information.</span></span> <span data-ttu-id="c756b-938">Om ThreadX-biblioteket och programmet har skapats med **TX_TIMER_ENABLE_PERFORMANCE_INFO** definierat ackumuleras följande information i ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-938">If the ThreadX library and application are built with **TX_TIMER_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="c756b-939">Totalt antal för det övergripande systemet:</span><span class="sxs-lookup"><span data-stu-id="c756b-939">Total number for the overall system:</span></span>

- <span data-ttu-id="c756b-940">aktiveringar</span><span class="sxs-lookup"><span data-stu-id="c756b-940">activations</span></span>

- <span data-ttu-id="c756b-941">inaktive ring</span><span class="sxs-lookup"><span data-stu-id="c756b-941">deactivations</span></span>

- <span data-ttu-id="c756b-942">återaktivering (periodiska timers)</span><span class="sxs-lookup"><span data-stu-id="c756b-942">reactivations (periodic timers)</span></span>

- <span data-ttu-id="c756b-943">förfallo tider</span><span class="sxs-lookup"><span data-stu-id="c756b-943">expirations</span></span>

- <span data-ttu-id="c756b-944">giltighets justeringar</span><span class="sxs-lookup"><span data-stu-id="c756b-944">expiration adjustments</span></span>

<span data-ttu-id="c756b-945">Totalt antal för varje program-timer:</span><span class="sxs-lookup"><span data-stu-id="c756b-945">Total number for each application timer:</span></span>

- <span data-ttu-id="c756b-946">aktiveringar</span><span class="sxs-lookup"><span data-stu-id="c756b-946">activations</span></span>

- <span data-ttu-id="c756b-947">inaktive ring</span><span class="sxs-lookup"><span data-stu-id="c756b-947">deactivations</span></span>

- <span data-ttu-id="c756b-948">återaktivering (periodiska timers)</span><span class="sxs-lookup"><span data-stu-id="c756b-948">reactivations (periodic timers)</span></span>

- <span data-ttu-id="c756b-949">förfallo tider</span><span class="sxs-lookup"><span data-stu-id="c756b-949">expirations</span></span>

- <span data-ttu-id="c756b-950">giltighets justeringar</span><span class="sxs-lookup"><span data-stu-id="c756b-950">expiration adjustments</span></span>

<span data-ttu-id="c756b-951">Den här informationen är tillgänglig i körnings läge genom tjänsterna \***tx_timer_performance_info_get** _ och _ *_tx_timer_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-951">This information is available at run-time through the services ***tx_timer_performance_info_get** _ and _*_tx_timer_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="c756b-952">Prestanda information för programtimern är användbar för att fastställa om programmet fungerar korrekt.</span><span class="sxs-lookup"><span data-stu-id="c756b-952">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="c756b-953">Det är också användbart när du optimerar programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-953">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="c756b-954">Block TX_TIMER för kontroll av program timer</span><span class="sxs-lookup"><span data-stu-id="c756b-954">Application Timer Control Block TX_TIMER</span></span>

<span data-ttu-id="c756b-955">Egenskaperna för varje program timer finns i kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="c756b-955">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="c756b-956">Den innehåller användbar information, till exempel ett värde för identifiering av 32-bitars utgång.</span><span class="sxs-lookup"><span data-stu-id="c756b-956">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="c756b-957">Den här strukturen definieras i filen ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="c756b-957">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="c756b-958">Block för timer-kontroll kan finnas var som helst i minnet, men det är vanligt att kontrol lera att kontrollen blockerar en global struktur genom att definiera den utanför omfånget för en funktion.</span><span class="sxs-lookup"><span data-stu-id="c756b-958">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="excessive-timers"></a><span data-ttu-id="c756b-959">Överdriven timers</span><span class="sxs-lookup"><span data-stu-id="c756b-959">Excessive Timers</span></span>

<span data-ttu-id="c756b-960">Som standard körs programtimers inifrån en dold system tråd som körs med prioritet noll, vilket vanligt vis är högre än alla program trådar.</span><span class="sxs-lookup"><span data-stu-id="c756b-960">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="c756b-961">På grund av detta bör bearbetningen i program timers vara minst.</span><span class="sxs-lookup"><span data-stu-id="c756b-961">Because of this, processing inside application timers should be kept to a minimum.</span></span>

<span data-ttu-id="c756b-962">Det är också viktigt att undvika, när så är möjligt, timers som upphör att gälla varje timer.</span><span class="sxs-lookup"><span data-stu-id="c756b-962">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="c756b-963">En sådan situation kan medföra överdriven till koppling i programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-963">Such a situation might induce excessive overhead in the application.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c756b-964">*Som tidigare nämnts körs tids program timers från en dold system tråd. Det är därför viktigt att inte välja SUS pension för eventuella ThreadX tjänst anrop som görs inifrån programmets timer-funktion.*</span><span class="sxs-lookup"><span data-stu-id="c756b-964">*As mentioned previously, application timers are executed from a hidden system thread. It is, therefore, important not to select suspension on any ThreadX service calls made from within the application timer's expiration function.*</span></span>

## <a name="relative-time"></a><span data-ttu-id="c756b-965">Relativ tid</span><span class="sxs-lookup"><span data-stu-id="c756b-965">Relative Time</span></span>

<span data-ttu-id="c756b-966">Utöver de program timers som nämnts tidigare, ger ThreadX en enda stegvis ökning av 32-bitars Ticket-räknare.</span><span class="sxs-lookup"><span data-stu-id="c756b-966">In addition to the application timers mentioned previously, ThreadX provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="c756b-967">Ticket eller *tiden* ökas med ett vid varje timer-avbrott.</span><span class="sxs-lookup"><span data-stu-id="c756b-967">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="c756b-968">Programmet kan läsa eller ange denna 32-bitars räknare genom anrop till \***tx_time_get** _ och _ *_tx_time_set_* \*.</span><span class="sxs-lookup"><span data-stu-id="c756b-968">The application can read or set this 32-bit counter through calls to ***tx_time_get** _ and _*_tx_time_set_\*\*, respectively.</span></span> <span data-ttu-id="c756b-969">Användningen av den här skal räknaren avgörs helt av programmet.</span><span class="sxs-lookup"><span data-stu-id="c756b-969">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="c756b-970">Den används inte internt av ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-970">It is not used internally by ThreadX.</span></span>

## <a name="interrupts"></a><span data-ttu-id="c756b-971">Avbrott</span><span class="sxs-lookup"><span data-stu-id="c756b-971">Interrupts</span></span>

<span data-ttu-id="c756b-972">Snabba svar på asynkrona händelser är huvud funktionen för inbäddade program i real tid.</span><span class="sxs-lookup"><span data-stu-id="c756b-972">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="c756b-973">Programmet vet att en sådan händelse föreligger genom maskin varu avbrott.</span><span class="sxs-lookup"><span data-stu-id="c756b-973">The application knows such an event is present through hardware interrupts.</span></span>

<span data-ttu-id="c756b-974">Ett avbrott är en asynkron ändring i processor körningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-974">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="c756b-975">När ett avbrott uppstår sparar *avbrotts* processorn vanligt vis en liten del av den aktuella körningen på stacken och överför kontrollen till lämplig avbrotts vektor.</span><span class="sxs-lookup"><span data-stu-id="c756b-975">Typically, when an interrupt occurs, the *Interrupts* processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="c756b-976">Avbrotts vektorn är i själva verket bara adressen till den rutin som ansvarar för att hantera det speciella typ avbrottet.</span><span class="sxs-lookup"><span data-stu-id="c756b-976">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="c756b-977">Den exakta avbrotts hanterings proceduren är processor information.</span><span class="sxs-lookup"><span data-stu-id="c756b-977">The exact interrupt handling procedure is processor specific.</span></span>

### <a name="interrupt-control"></a><span data-ttu-id="c756b-978">Avbrotts kontroll</span><span class="sxs-lookup"><span data-stu-id="c756b-978">Interrupt Control</span></span>

<span data-ttu-id="c756b-979">Med tjänsten ***tx_interrupt_control*** kan program aktivera och inaktivera avbrott.</span><span class="sxs-lookup"><span data-stu-id="c756b-979">The ***tx_interrupt_control*** service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="c756b-980">Föregående avbrott för att aktivera/inaktivera position returneras av den här tjänsten.</span><span class="sxs-lookup"><span data-stu-id="c756b-980">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="c756b-981">Det är viktigt att nämna att avbrotts kontrollen endast påverkar det program segment som körs för tillfället.</span><span class="sxs-lookup"><span data-stu-id="c756b-981">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="c756b-982">Om t. ex. en tråd inaktiverar avbrott, förblir de bara inaktiverade under körningen av tråden.</span><span class="sxs-lookup"><span data-stu-id="c756b-982">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span>

> [!NOTE]
> <span data-ttu-id="c756b-983">*Ett icke-Maskbart avbrott (NMI) är ett avbrott som inte kan inaktive ras av maskin varan. Ett sådant avbrott kan användas av ThreadX-program. Programmets NMI hanterings rutin får dock inte användas för ThreadX kontext hantering eller API-tjänster.*</span><span class="sxs-lookup"><span data-stu-id="c756b-983">*A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware. Such an interrupt may be used by ThreadX applications. However, the application's NMI handling routine is not allowed to use ThreadX context management or any API services.*</span></span>

### <a name="threadx-managed-interrupts"></a><span data-ttu-id="c756b-984">ThreadX hanterade avbrott</span><span class="sxs-lookup"><span data-stu-id="c756b-984">ThreadX Managed Interrupts</span></span>

<span data-ttu-id="c756b-985">ThreadX tillhandahåller program med slutförd avbrott-hantering.</span><span class="sxs-lookup"><span data-stu-id="c756b-985">ThreadX provides applications with complete interrupt management.</span></span> <span data-ttu-id="c756b-986">Den här hanteringen omfattar att spara och återställa kontexten för den avbrutna körningen.</span><span class="sxs-lookup"><span data-stu-id="c756b-986">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="c756b-987">Dessutom tillåter ThreadX att vissa tjänster anropas inifrån ISR: er (Interrupt service rutiner).</span><span class="sxs-lookup"><span data-stu-id="c756b-987">In addition, ThreadX allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="c756b-988">Följande är en lista över ThreadX-tjänster som tillåts från Application ISR: er.</span><span class="sxs-lookup"><span data-stu-id="c756b-988">The following is a list of ThreadX services allowed from application ISRs.</span></span>

```c
tx_block_allocate
tx_block_pool_info_get tx_block_pool_prioritize
tx_block_pool_performance_info_get
tx_block_pool_performance_system_info_get tx_block_release
tx_byte_pool_info_get tx_byte_pool_performance_info_get
tx_byte_pool_performance_system_info_get
tx_byte_pool_prioritize tx_event_flags_info_get
tx_event_flags_get tx_event_flags_set
tx_event_flags_performance_info_get
tx_event_flags_performance_system_info_get
tx_event_flags_set_notify tx_interrupt_control
tx_mutex_performance_info_get
tx_mutex_performance_system_info_get tx_queue_front_send
tx_queue_info_get tx_queue_performance_info_get
tx_queue_performance_system_info_get tx_queue_prioritize
tx_queue_receive tx_queue_send tx_semaphore_get
tx_queue_send_notify tx_semaphore_ceiling_put
tx_semaphore_info_get tx_semaphore_performance_info_get
tx_semaphore_performance_system_info_get
tx_semaphore_prioritize tx_semaphore_put tx_thread_identify
tx_semaphore_put_notify tx_thread_entry_exit_notify
tx_thread_info_get tx_thread_resume
tx_thread_performance_info_get
tx_thread_performance_system_info_get
tx_thread_stack_error_notify tx_thread_wait_abort tx_time_get
tx_time_set tx_timer_activate tx_timer_change
tx_timer_deactivate tx_timer_info_get
tx_timer_performance_info_get
tx_timer_performance_system_info_get
```

> [!IMPORTANT]
> <span data-ttu-id="c756b-989">*SUS Pension tillåts inte från ISR: er. Därför måste **wait_option** parameter för alla ThreadX-tjänst anrop som görs från en ISR anges till **TX_NO_WAIT**.*</span><span class="sxs-lookup"><span data-stu-id="c756b-989">*Suspension is not allowed from ISRs. Therefore, the **wait_option** parameter for all ThreadX service calls made from an ISR must be set to **TX_NO_WAIT**.*</span></span>

### <a name="isr-template"></a><span data-ttu-id="c756b-990">ISR-mall</span><span class="sxs-lookup"><span data-stu-id="c756b-990">ISR Template</span></span>

<span data-ttu-id="c756b-991">För att hantera program avbrott måste flera ThreadX-verktyg anropas i början och slutet av Application ISR: er.</span><span class="sxs-lookup"><span data-stu-id="c756b-991">To manage application interrupts, several ThreadX utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="c756b-992">Det exakta formatet för avbrotts hantering varierar mellan olika portar.</span><span class="sxs-lookup"><span data-stu-id="c756b-992">The exact format for interrupt handling varies between ports.</span></span>

<span data-ttu-id="c756b-993">Följande små kod segment är typiska för de flesta ThreadX-hanterade ISR: er.</span><span class="sxs-lookup"><span data-stu-id="c756b-993">The following small code segment is typical of most ThreadX managed ISRs.</span></span> <span data-ttu-id="c756b-994">I de flesta fall är den här bearbetningen i sammansättnings språk.</span><span class="sxs-lookup"><span data-stu-id="c756b-994">In most cases, this processing is in assembly language.</span></span>

```c
_application_ISR_vector_entry:

; Save context and prepare for

; ThreadX use by calling the ISR

; entry function.

CALL _tx_thread_context_save

; The ISR can now call ThreadX

; services and its own C functions

; When the ISR is finished, context

; is restored (or thread preemption)

; by calling the context restore ; function. Control does not return!

JUMP _tx_thread_context_restore
```

### <a name="high-frequency-interrupts"></a><span data-ttu-id="c756b-995">Höga frekvens avbrott</span><span class="sxs-lookup"><span data-stu-id="c756b-995">High-frequency Interrupts</span></span>

<span data-ttu-id="c756b-996">Vissa avbrott sker i en sådan hög frekvens att spara och återställa en fullständig kontext vid varje avbrott förbrukar överdriven bearbetnings bandbredd.</span><span class="sxs-lookup"><span data-stu-id="c756b-996">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="c756b-997">I sådana fall är det vanligt att programmet har ett litet insamlings språk för en ISR som gör en begränsad mängd bearbetning för en majoritet av dessa höga frekvens avbrott.</span><span class="sxs-lookup"><span data-stu-id="c756b-997">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these high-frequency interrupts.</span></span>

<span data-ttu-id="c756b-998">Efter en viss tidpunkt kan den lilla ISR behöva interagera med ThreadX.</span><span class="sxs-lookup"><span data-stu-id="c756b-998">After a certain point in time, the small ISR may need to interact with ThreadX.</span></span> <span data-ttu-id="c756b-999">Detta åstadkommer du genom att anropa start-och slut funktionerna som beskrivs i ovanstående mall.</span><span class="sxs-lookup"><span data-stu-id="c756b-999">This is accomplished by calling the entry and exit functions described in the above template.</span></span>

### <a name="interrupt-latency"></a><span data-ttu-id="c756b-1000">Avbrotts svars tid</span><span class="sxs-lookup"><span data-stu-id="c756b-1000">Interrupt Latency</span></span>

<span data-ttu-id="c756b-1001">ThreadX låser ut avbrott under korta tids perioder.</span><span class="sxs-lookup"><span data-stu-id="c756b-1001">ThreadX locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="c756b-1002">Det maximala antalet tids avbrott är inaktiverat i den tid som krävs för att spara eller återställa en tråds kontext.</span><span class="sxs-lookup"><span data-stu-id="c756b-1002">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread's context.</span></span>
