---
title: Kapitel 3 – funktionell beskrivning av Azure återställnings tider NetX Secure
description: Det här kapitlet innehåller en funktions Beskrivning av NetX Secure TLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 03/22/2021
ms.locfileid: "104825686"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="f5a24-103">Kapitel 3 – funktionell beskrivning av Azure återställnings tider NetX Secure</span><span class="sxs-lookup"><span data-stu-id="f5a24-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="f5a24-104">Översikt över körning</span><span class="sxs-lookup"><span data-stu-id="f5a24-104">Execution Overview</span></span>

<span data-ttu-id="f5a24-105">Det här kapitlet innehåller en funktions Beskrivning av Azure återställnings tider NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="f5a24-106">Det finns två primära typer av program körning i ett NetX Secure TLS-program: initierings-och program gränssnitts anrop.</span><span class="sxs-lookup"><span data-stu-id="f5a24-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="f5a24-107">*NetX Secure förutsätter att ThreadX och NetX/NetXDuo finns. Från ThreadX kräver det tråd körning, avstängning, periodiska timers och ömsesidiga undantags funktioner. Från NetX/NetXDuo krävs det funktioner och driv rutiner för TCP/IP-nätverk.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="f5a24-108">Transport Layer Security (TLS) och Secure Sockets Layer (SSL)</span><span class="sxs-lookup"><span data-stu-id="f5a24-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="f5a24-109">Secure Network Protocol-komponenten i NetX Secure är en implementering av Transport Layer Security-protokollet (TLS) som beskrivs i RFC 2246 (version 1,0), 4346 (version 1,1), 5246 (version 1,2) och 8446 (version 1,3).</span><span class="sxs-lookup"><span data-stu-id="f5a24-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="f5a24-110">Det ingår också stöd för Basic X. 509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="f5a24-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="f5a24-111">NetX Secure TLS stöder TLS-versionerna 1,2 och 1,3.</span><span class="sxs-lookup"><span data-stu-id="f5a24-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="f5a24-112">Implementeringar tillhandahålls för nu-föråldrade TLS 1,0 och TLS 1,1, men de måste uttryckligen initieras och rekommenderas inte för användning i nya produkter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="f5a24-113">*Secure Sockets Layer* (SSL) var det ursprungliga namnet på TLS innan det blev standard i RFC 2246 och "SSL" används ofta som ett generiskt namn för TLS-protokollen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="f5a24-114">Den senaste versionen av SSL var 3,0 och TLS 1,0 kallas ibland SSL version 3,1.</span><span class="sxs-lookup"><span data-stu-id="f5a24-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="f5a24-115">Alla versioner av det officiella "SSL"-protokollet betraktas som föråldrade och oskyddade och för närvarande NetX Secure ger inte SSL-implementering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="f5a24-116">TLS anger ett protokoll för att generera *sessionsnycklar* som skapas under TLS- *handskakningen* mellan en TLS-klient och-server och dessa nycklar används för att kryptera data som skickas av programmet under TLS- *sessionen.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="f5a24-117">TLS-data är indelade i *poster* som är likvärdiga med ett TCP-paket.</span><span class="sxs-lookup"><span data-stu-id="f5a24-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="f5a24-118">Varje TLS-post har en rubrik, och TLS-krypterade poster har också en sidfot (kontroll Summa hash).</span><span class="sxs-lookup"><span data-stu-id="f5a24-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="f5a24-119">TLS-handskaknings poster har ett ytterligare sidhuvud inkapslat i den större TLS-posten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="f5a24-120">TLS-posten kapslas av transport skiktets nätverks protokoll på samma sätt som ett TCP-paket kapslas av ett IP-paket.</span><span class="sxs-lookup"><span data-stu-id="f5a24-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="f5a24-121">TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="f5a24-121">TLS 1.3</span></span>

<span data-ttu-id="f5a24-122">I augusti 2018 slutfördes TLS 1,3-specifikationen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="f5a24-123">Den nya versionen av protokollet är en ganska viktig uppdatering som ändrar vissa grundläggande aspekter av den underliggande säkerheten och prestandan hos TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="f5a24-124">Dessa ändringar är dock i stort sett osynliga för den typiska TLS-användaren, eftersom de tillämpas främst på TLS-hand skaknings tillstånds dator och skapande av sessionsnyckel.</span><span class="sxs-lookup"><span data-stu-id="f5a24-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="f5a24-125">Ett antal valfria funktioner och tillägg har också lagts till.</span><span class="sxs-lookup"><span data-stu-id="f5a24-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="f5a24-126">Följande är en sammanfattning av ändringarna och hur de påverkar TLS-funktioner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="f5a24-127">Hand skaknings datorn optimerades genom att ett helt utbyte av meddelanden togs bort från servern.</span><span class="sxs-lookup"><span data-stu-id="f5a24-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="f5a24-128">Generering av nycklar har uppdaterats för att använda en standardiserad rutin som kallas HKDF (HMAC-baserad nyckel härledning) och sambandet med sessionsnycklar till alla hand skaknings meddelanden (i stället för några val parametrar).</span><span class="sxs-lookup"><span data-stu-id="f5a24-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="f5a24-129">Alla TLS 1,2 och tidigare krypteringssviter är föråldrade och är inkompatibla med TLS 1,3.</span><span class="sxs-lookup"><span data-stu-id="f5a24-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="f5a24-130">På samma sätt går det inte att använda alla TLS 1,3-krypteringssviter med tidigare versioner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="f5a24-131">Alla TLS 1,3-krypteringssviter ger PFS (Perfect Forward Secrecy) med tillfälliga nycklar<sup>6</sup></span><span class="sxs-lookup"><span data-stu-id="f5a24-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="f5a24-132">TLS 1,3 tar bort "Message Authentication Code" (MAC) i varje post till förmån för att använda AEAD<sup>7</sup> -chiffer</span><span class="sxs-lookup"><span data-stu-id="f5a24-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="f5a24-133">Vissa ytterligare valfria funktioner lades till, inklusive 0-alternativ (Zero-fördröjning) som gör att program data kan skickas under hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="f5a24-134">0-sökalternativ är helt valfria och stöds för närvarande inte i Azure återställnings tider TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="f5a24-135">TLS 1,3 påverkar inte användar programmen avsevärt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="f5a24-136">API: et är exakt detsamma mellan versionerna, och krypteringssviter markeras så att en enda ciphersuite-tabell kan användas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="f5a24-137">För att kunna använda TLS 1,3 måste makro NX_SECURE_TLS_ENABLE_TLS_1_3 globalt definieras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="f5a24-138">TLS 1,3 är inaktiverat som standard i Azure återställnings tider TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="f5a24-139">"Tillfälliga" nycklar är asymmetriska nyckel par som genereras under TLS-handskakningen och används för hemligheter som Exchange endast för den sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="f5a24-140">Nyckel paret tas bort efter användningen – detta hindrar en angripare från att kunna komma åt krypterade data i en inspelad TLS-session även om en privat certifikat nyckel komprometteras när som helst, i framtiden – därmed "Perfect Forward Secrecy".</span><span class="sxs-lookup"><span data-stu-id="f5a24-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="f5a24-141">Autentiserad kryptering med associerade data – ett läge för chiffer som AES som kombinerar kryptering och integritets kontroll i en enda åtgärd, vilket eliminerar behovet av en separat hash av data för integritets kontroll.</span><span class="sxs-lookup"><span data-stu-id="f5a24-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="f5a24-142">TLS-posthuvud</span><span class="sxs-lookup"><span data-stu-id="f5a24-142">TLS Record header</span></span>

<span data-ttu-id="f5a24-143">Alla giltiga TLS-poster måste ha ett TLS-huvud, som visas i fel!</span><span class="sxs-lookup"><span data-stu-id="f5a24-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="f5a24-144">Referens källan hittades inte.</span><span class="sxs-lookup"><span data-stu-id="f5a24-144">Reference source not found.</span></span>

![Diagram över en TLS-post-rubrik.](media/image2.png)

<span data-ttu-id="f5a24-146">Bild 1 – TLS-posthuvud</span><span class="sxs-lookup"><span data-stu-id="f5a24-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="f5a24-147">Fälten i TLS-postrubriken definieras enligt följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="f5a24-148">Fält för TLS-huvud</span><span class="sxs-lookup"><span data-stu-id="f5a24-148">TLS Header Field</span></span> | <span data-ttu-id="f5a24-149">Syfte</span><span class="sxs-lookup"><span data-stu-id="f5a24-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="f5a24-150">**8-bitars meddelande typ**</span><span class="sxs-lookup"><span data-stu-id="f5a24-150">**8-bit Message Type**</span></span> | <span data-ttu-id="f5a24-151">Det här fältet innehåller den typ av TLS-post som skickas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="f5a24-152">Giltiga typer är följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-152">Valid types are as follows:</span></span><br /><span data-ttu-id="f5a24-153">-ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="f5a24-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="f5a24-154">-Avisering: 0x15</span><span class="sxs-lookup"><span data-stu-id="f5a24-154">- Alert: 0x15</span></span><br /><span data-ttu-id="f5a24-155">-Hand skakning: 0x16</span><span class="sxs-lookup"><span data-stu-id="f5a24-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="f5a24-156">– Program data: 0x17</span><span class="sxs-lookup"><span data-stu-id="f5a24-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="f5a24-157">**16-bitars protokoll version**</span><span class="sxs-lookup"><span data-stu-id="f5a24-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="f5a24-158">Det här fältet innehåller TLS-protokollets version.</span><span class="sxs-lookup"><span data-stu-id="f5a24-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="f5a24-159">Giltiga värden är följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-159">Valid values are as follows:</span></span><br /><span data-ttu-id="f5a24-160">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="f5a24-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="f5a24-161">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="f5a24-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="f5a24-162">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="f5a24-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="f5a24-163">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="f5a24-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="f5a24-164">- **TLS 1,3 <sup>9</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="f5a24-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="f5a24-165">**16-bitars längd**</span><span class="sxs-lookup"><span data-stu-id="f5a24-165">**16-bit Length**</span></span> | <span data-ttu-id="f5a24-166">Det här fältet innehåller längden på de data som kapslats i TLS-posten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="f5a24-167">I TLS 1,3 används inte längre ChangeCipherSpec-meddelandet, trots att det fortfarande kan skickas av kompatibilitetsinställningar, vilket innebär att meddelandet ignoreras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="f5a24-168">TLS 1,3 skulle tekniskt ha värdet 0x0304 om schemat fortsatte, men protokollet ändrades till att ha den faktiska protokoll versionen i ett tillägg, så alla TLS 1,3-poster använder 0x0303 i protokoll versions fält för bakåtkompatibilitet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="f5a24-169">Post rubrik för TLS-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-169">TLS Handshake Record header</span></span>

<span data-ttu-id="f5a24-170">Alla giltiga TLS-handskaknings poster måste ha en TLS-handskakning-rubrik, som visas i bild 2.</span><span class="sxs-lookup"><span data-stu-id="f5a24-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![Diagram över en post rubrik för TLS-handskakning.](media/image3.png)

<span data-ttu-id="f5a24-172">Bild 2 – post rubriken TLS-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="f5a24-173">Fälten i post rubriken TLS-handskakning definieras enligt följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="f5a24-174">Fält för TLS-huvud</span><span class="sxs-lookup"><span data-stu-id="f5a24-174">TLS Header Field</span></span> | <span data-ttu-id="f5a24-175">Syfte</span><span class="sxs-lookup"><span data-stu-id="f5a24-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="f5a24-176">**8-bitars meddelande typ**</span><span class="sxs-lookup"><span data-stu-id="f5a24-176">**8-bit Message Type**</span></span> | <span data-ttu-id="f5a24-177">Det här fältet innehåller den typ av TLS-post som skickas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="f5a24-178">Giltiga typer är följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-178">Valid types are as follows:</span></span><br /><span data-ttu-id="f5a24-179">-ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="f5a24-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="f5a24-180">-Avisering: 0x15</span><span class="sxs-lookup"><span data-stu-id="f5a24-180">- Alert: 0x15</span></span><br /><span data-ttu-id="f5a24-181">-Hand skakning: 0x16</span><span class="sxs-lookup"><span data-stu-id="f5a24-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="f5a24-182">– Program data: 0x17</span><span class="sxs-lookup"><span data-stu-id="f5a24-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="f5a24-183">**16-bitars protokoll version**</span><span class="sxs-lookup"><span data-stu-id="f5a24-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="f5a24-184">Det här fältet innehåller TLS-protokollets version.</span><span class="sxs-lookup"><span data-stu-id="f5a24-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="f5a24-185">Giltiga värden är följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-185">Valid values are as follows:</span></span><br /><span data-ttu-id="f5a24-186">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="f5a24-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="f5a24-187">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="f5a24-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="f5a24-188">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="f5a24-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="f5a24-189">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="f5a24-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="f5a24-190">- **TLS 1,3 <sup>11</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="f5a24-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="f5a24-191">**16-bitars längd**</span><span class="sxs-lookup"><span data-stu-id="f5a24-191">**16-bit Length**</span></span>    | <span data-ttu-id="f5a24-192">Det här fältet innehåller längden på de data som kapslats i TLS-posten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="f5a24-193">**8-bitars hand Skaknings typ**</span><span class="sxs-lookup"><span data-stu-id="f5a24-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="f5a24-194">Det här fältet innehåller meddelande typen hand skakning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-194">This field contains the handshake message type.</span></span> <span data-ttu-id="f5a24-195">Giltiga värden är följande (\* meddelanden i **fetstil** har lagts till i TLS 1,3):</span><span class="sxs-lookup"><span data-stu-id="f5a24-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="f5a24-196">-HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="f5a24-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="f5a24-197">-Sitt hälsnings: 0x01</span><span class="sxs-lookup"><span data-stu-id="f5a24-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="f5a24-198">-ServerHello: protokollnumret 0x02</span><span class="sxs-lookup"><span data-stu-id="f5a24-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="f5a24-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="f5a24-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="f5a24-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="f5a24-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="f5a24-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="f5a24-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="f5a24-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="f5a24-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="f5a24-203">-Certifikat: 0x0B</span><span class="sxs-lookup"><span data-stu-id="f5a24-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="f5a24-204">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="f5a24-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="f5a24-205">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="f5a24-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="f5a24-206">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="f5a24-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="f5a24-207">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="f5a24-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="f5a24-208">-ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="f5a24-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="f5a24-209">-Färdig: 0x14</span><span class="sxs-lookup"><span data-stu-id="f5a24-209">- Finished: 0x14</span></span><br /><span data-ttu-id="f5a24-210">- **Uppdatering** av **0x18:**</span><span class="sxs-lookup"><span data-stu-id="f5a24-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="f5a24-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="f5a24-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="f5a24-212">**24-bitars längd**</span><span class="sxs-lookup"><span data-stu-id="f5a24-212">**24-bit Length**</span></span>    | <span data-ttu-id="f5a24-213">Det här fältet innehåller längden på hand skaknings meddelande data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="f5a24-214">I TLS 1,3 används inte längre ChangeCipherSpec-meddelandet, trots att det fortfarande kan skickas av kompatibilitetsinställningar, vilket innebär att meddelandet ignoreras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="f5a24-215">TLS 1,3 skulle tekniskt ha värdet 0x0304 om schemat fortsatte, men protokollet ändrades till att ha den faktiska protokoll versionen i ett tillägg, så alla TLS 1,3-poster använder 0x0303 i protokoll versions fält för bakåtkompatibilitet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="f5a24-216">TLS-handskakning och TLS-session</span><span class="sxs-lookup"><span data-stu-id="f5a24-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="f5a24-217">En typisk TLS-handskakning (version 1.0-1.2) visas i bild 3.</span><span class="sxs-lookup"><span data-stu-id="f5a24-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="f5a24-218">En TLS-handskakning börjar när TLS-klienten skickar ett *sitt hälsnings* -meddelande till en TLS-server, vilket indikerar att de vill starta en TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="f5a24-219">Meddelandet innehåller information om den kryptering som klienten vill använda för sessionen, tillsammans med information som används för att generera sessionsnycklar senare i hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="f5a24-220">Alla meddelanden i TLS-handskakningen är inte krypterade tills sessionsnycklarna har skapats.</span><span class="sxs-lookup"><span data-stu-id="f5a24-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="f5a24-221">TLS 1,3 ändrar hand skakningen lite – detaljerna presenteras i nästa avsnitt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="f5a24-222">TLS-servern svarar på sitt hälsnings med ett ServerHello-meddelande som anger ett val från de krypterings alternativ som tillhandahålls av klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="f5a24-223">ServerHello följs av ett certifikat meddelande där servern tillhandahåller ett digitalt certifikat för att autentisera sin identitet för klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="f5a24-224">Slutligen skickar servern ett ServerHelloDone-meddelande som anger att det inte finns några fler meddelanden att skicka.</span><span class="sxs-lookup"><span data-stu-id="f5a24-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="f5a24-225">Servern kan eventuellt skicka andra meddelanden efter ServerHello och i vissa fall kan det inte skicka ett certifikat meddelande, och därför måste ServerHelloDone-meddelandet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="f5a24-226">När klienten har tagit emot alla serverns meddelanden har den tillräckligt med information för att generera sessionsnycklar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="f5a24-227">TLS gör detta genom att skapa en delad bit av slumpmässiga data som kallas för *huvud hemlighet*, som är en fast storlek och som används som ett Seed för att generera alla nycklar som behövs när kryptering har Aktiver ATS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="f5a24-228">Hemligheten för huvud repliken krypteras med algoritmen för offentlig nyckel (t. ex. RSA) som anges i Hello-meddelandena (se nedan för information om algoritmer för offentliga nycklar) och den offentliga nyckel som tillhandahålls av servern i dess certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="f5a24-229">En valfri TLS-funktion som kallas för delade nycklar (PSK) aktiverar krypteringssviter som inte använder ett certifikat utan använder i stället ett hemligt värde som delas mellan värdarna (vanligt vis via fysisk överföring eller annan säker metod).</span><span class="sxs-lookup"><span data-stu-id="f5a24-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="f5a24-230">Den delade hemligheten används för att generera den överordnade hemligheten i stället för att använda ett krypterat meddelande för att skicka den överordnade hemligheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="f5a24-231">Se avsnittet om i förväg delade nycklar nedan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="f5a24-232">Den krypterade hemligheten på huvud sidan skickas till servern i ClientKeyExchange-meddelandet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="f5a24-233">Servern, vid mottagning av ClientKeyExchange-meddelandet, dekrypterar hemligheten för huvud repliken med dess privata nyckel och fortsätter att generera sessionsnycklar parallellt med TLS-klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="f5a24-234">När sessionsnycklarna har genererats kan alla ytterligare meddelanden krypteras med hjälp av algoritmen för privat nyckel (t. ex. AES) som valts i Hello-meddelandena.</span><span class="sxs-lookup"><span data-stu-id="f5a24-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="f5a24-235">Ett slutligt okrypterat meddelande som kallas ChangeCipherSpec skickas av både klienten och servern för att indikera att alla ytterligare meddelanden kommer att krypteras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="f5a24-236">Det första krypterade meddelandet som skickas av både klienten och servern är också det sista TLS-handskaknings meddelandet, som kallas slutfört.</span><span class="sxs-lookup"><span data-stu-id="f5a24-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="f5a24-237">Det här meddelandet innehåller en hash av alla handskaknings meddelanden som har tagits emot och skickats.</span><span class="sxs-lookup"><span data-stu-id="f5a24-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="f5a24-238">Denna hash används för att kontrol lera att inget av meddelandena i hand skakningen har manipulerats eller skadats (vilket innebär att säkerheten kan brytas).</span><span class="sxs-lookup"><span data-stu-id="f5a24-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="f5a24-239">När de färdiga meddelandena tas emot och hand skaknings-hasharna har verifierats börjar TLS-sessionen och programmet börjar skicka och ta emot data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="f5a24-240">Alla data som skickas på endera sidan under TLS-sessionen hashas först med den hash-algoritm som valts i Hello-meddelandena (för att tillhandahålla meddelande integritet) och krypteras med den valda algoritmen för privat nyckel med de genererade sessionsnycklarna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="f5a24-241">Slutligen kan en TLS-session endast avslutas om antingen klienten eller servern väljer att göra det.</span><span class="sxs-lookup"><span data-stu-id="f5a24-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="f5a24-242">En trunkerad session betraktas som en säkerhets överträdelse (eftersom en angripare kan försöka förhindra att alla data som skickas tas emot) så att ett särskilt meddelande skickas när någon sida vill avsluta sessionen, som kallas en CloseNotify-avisering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="f5a24-243">Både klienten och servern måste skicka och bearbeta en CloseNotify-avisering för att en lyckad session ska kunna stängas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagram över en typisk TLS-handskakning.](media/image4.png)

<span data-ttu-id="f5a24-245">Bild 3 – typisk TLS-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="f5a24-246">TLS 1,3-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="f5a24-247">TLS 1,3 är en ganska stor översyn av TLS-protokollet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="f5a24-248">Den stora delen av ändringarna har gjorts i hand skakningen för att öka säkerheten och prestandan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="f5a24-249">En typisk TLS 1,3-handskakning visas i bild 4.</span><span class="sxs-lookup"><span data-stu-id="f5a24-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="f5a24-250">Den primära skillnaden kan ses i antalet utbyten mellan servern och klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="f5a24-251">I TLS 1,2 och tidigare skickar servern två flygningar<sup>12</sup> av meddelandena – först ServerHello och sedan ett ChangeCipherSpec-meddelande innan det krypterade slutförda meddelandet som avslutar hand skakningen skickas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="f5a24-252">I TLS 1,3 skickar servern allting i den första flygningen – ServerHello, tillägg, certifikat och avslutad.</span><span class="sxs-lookup"><span data-stu-id="f5a24-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="f5a24-253">ChangeCipherSpec-meddelandet eliminerades och servern genererar dess sessionsnycklar och börjar kryptera hand skaknings meddelanden direkt efter ServerHello.</span><span class="sxs-lookup"><span data-stu-id="f5a24-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="f5a24-254">Den nya överenskommelsen innebär att mer av TLS-handskakningen skyddas av kryptering, vilket begränsar mängden klartext-data som en angripare kan komma åt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="f5a24-255">Dessutom innebär borttagningen av den andra server flygningen (som bara var en ChangeCipherSpec följt av en sluten) att en TLS-klient inte längre behöver vänta på att starta sändningen av program data – så snart klienten skickar ett eget slutfört meddelande till sessionen startas sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="f5a24-256">En flygning är bara en samling TLS-meddelanden som skickas samtidigt i en grupp.</span><span class="sxs-lookup"><span data-stu-id="f5a24-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![Diagram över en TLS 1,3-handskakning.](media/image5.png)

<span data-ttu-id="f5a24-258">Bild 4 – TLS 1,3-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="f5a24-259">*TLS 1,3 introducerade även begreppet "tidiga data" och 0-efter namn (svars tid, ingen fördröjning), vilket innebär att vissa program data kan skickas i den första flygningen av meddelanden. Den här valfria funktionen har lagts till främst som en optimering för webbläsarens svars tid (t. ex. för att skicka tidig HTTP-huvuden för att börja återge en sida). Den här funktionen stöds inte från och med Azure återställnings tider 6,0.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="f5a24-260">Initiering</span><span class="sxs-lookup"><span data-stu-id="f5a24-260">Initialization</span></span>

<span data-ttu-id="f5a24-261">TCP/IP-stacken NetX eller NetXDuo måste initieras innan du använder NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="f5a24-262">I användar handboken för NetX eller NetXDuo hittar du information om hur du initierar TCP/IP-stacken korrekt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="f5a24-263">När NetX TCP/IP-stack har initierats kan TLS aktive ras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="f5a24-264">Internt hanteras all TLS-nätverkstrafik och bearbetning av NetX/NetXDuo-stacken utan att användaren behöver vidta några åtgärder.</span><span class="sxs-lookup"><span data-stu-id="f5a24-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="f5a24-265">TLS har dock vissa särskilda krav som måste hanteras separat från den underliggande nätverks stacken.</span><span class="sxs-lookup"><span data-stu-id="f5a24-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="f5a24-266">Dessa parametrar har tilldelats TLS Control Block som kallas \***NX_SECURE_TLS_SESSION** _ med hjälp av tjänsten _ \*_nx_secure_tls_session_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="f5a24-267">TLS har två lägen, en server och en klient, som kan aktive ras i ett program (men bara ett läge per NetX-socket) och varje har sina egna specifika krav, som beskrivs nedan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="f5a24-268">I båda läge kräver NetX Secure TLS att en TCP-socket (\***NX_TCP_SOCKET** _) skapas och konfigureras för TCP-kommunikation med fjärrvärden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="f5a24-269">TCP-socketen tilldelas till en TLS-session med rollen _ \*_nx_secure_tls_session_start_\*\*, som beskrivs nedan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="f5a24-270">Initiering – TLS-server</span><span class="sxs-lookup"><span data-stu-id="f5a24-270">Initialization – TLS Server</span></span>

<span data-ttu-id="f5a24-271">Förutom en TCP-socket kräver NetX Secure TLS server mode ett *digitalt certifikat*, vilket är ett dokument som används för att identifiera TLS-servern för den anslutande TLS-klienten och certifikaten motsvarande *privata nyckel*, vanligt vis för RSA-krypteringsalgoritmen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="f5a24-272">International tele Union X. 509 standard anger det certifikat format som används av TLS och det finns flera verktyg för att skapa X. 509 digitala certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="f5a24-273">För NetX Secure TLS måste X. 509-certifikatet vara Binary-kodat med Distinguished Encoding Rules (DER)-formatet för ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="f5a24-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="f5a24-274">DER är standard TLS-formatet för TLS-överföring för certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="f5a24-275">Den privata nyckeln som är associerad med det tillhandahållna certifikatet måste vara i DER-Encoded PKCS # 1-format.</span><span class="sxs-lookup"><span data-stu-id="f5a24-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="f5a24-276">Den privata nyckeln används bara på enheten och skickas aldrig över kabeln.</span><span class="sxs-lookup"><span data-stu-id="f5a24-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="f5a24-277">Se till att privata nycklar är säkra eftersom de ger säkerhet för TLS-kommunikation!</span><span class="sxs-lookup"><span data-stu-id="f5a24-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="f5a24-278">Om du vill initiera TLS-servercertifikatet måste programmet tillhandahålla en pekare till en buffert som innehåller det DER-kodade X. 509-certifikatet och valfri DER-kodad PKCS # 1-RSA-nyckel data med hjälp av tjänsten \***nx_secure_x509_certificate_intialize** _, som fyller i \*NX_SECURE_X509_CERT\*\*-strukturen med lämpliga certifikat data som ska användas av TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="f5a24-279">När Server certifikatet har initierats måste det läggas till i TLS-kontroll-blocket med hjälp av tjänsten ***nx_secure_tls_local_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="f5a24-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="f5a24-280">När serverns certifikat har lagts till i TLS Control Block kan socketen användas för att upprätta en säker TLS-server anslutning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="f5a24-281">Initiering – TLS-klient</span><span class="sxs-lookup"><span data-stu-id="f5a24-281">Initialization – TLS Client</span></span>

<span data-ttu-id="f5a24-282">NetX Secure TLS client mode kräver ett *betrott certifikat Arkiv*, som är en samling X. 509 digitala certifikat från betrodda certifikat utfärdare (ca: er).</span><span class="sxs-lookup"><span data-stu-id="f5a24-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="f5a24-283">Dessa certifikat antas av att TLS-protokollet är "betrott" och fungerar som underlag för att autentisera certifikat som tillhandahålls av TLS server-entiteter för att NetX säker TLS-klient.</span><span class="sxs-lookup"><span data-stu-id="f5a24-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="f5a24-284">Ett certifikat för betrodd certifikat utfärdare kan antingen vara *självsignerat* eller signerat av en annan certifikat utfärdare, vilket innebär att certifikatet kallas *mellanliggande ca* (ICA).</span><span class="sxs-lookup"><span data-stu-id="f5a24-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="f5a24-285">I ett typiskt TLS-program tillhandahåller servern ICA-certifikat tillsammans med dess server certifikat, men det enda kravet för lyckad autentisering är att en kedja av utfärdare (certifikat som används för att signera andra certifikat) kan spåras från Server certifikatet tillbaka till ett certifikat för betrodd certifikat utfärdare i det betrodda certifikat arkivet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="f5a24-286">Den här kedjan kallas en  *kedja av förtroende* eller en *certifikat kedja*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="f5a24-287">För att initiera en betrodd certifikat utfärdare eller ett ICA-certifikat måste programmet tillhandahålla en pekare till en buffert som innehåller det DER-kodade X. 509-certifikatet med hjälp av tjänsten ***nx_secure_x509_certificate_intialize** _, som fyller i strukturen _ *NX_SECURE_X509_CERT** med lämpliga certifikat data som ska användas av TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="f5a24-288">Betrodda certifikat som har initierats läggs sedan till i TLS-kontroll-blocket med hjälp av tjänsten ***nx_secure_tls_trusted_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="f5a24-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="f5a24-289">Om du inte lägger till ett certifikat Miss lyckas TLS-klientcertifikatet eftersom det inte finns något sätt för TLS-protokollet att autentisera fjärr-TLS-serverns värdar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="f5a24-290">TLS-klienten behöver också utrymme för att det inkommande server certifikatet ska tilldelas (förutsatt att ett i förväg delad nyckel läge inte används).</span><span class="sxs-lookup"><span data-stu-id="f5a24-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="f5a24-291">Från och med NetX Secure TLS 5,12 är det inte längre nödvändigt för programmet att allokera utrymme för Fjärrcertifikatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="f5a24-292">Men det äldre alternativet att allokera utrymme för ett Server certifikat är fortfarande tillgängligt och användare som tilldelats certifikat kommer att användas före den interna certifikat buffertens optimering <sup>13</sup> – mer information finns i ***nx_secure_tls_remote_certificate_allocates*** tjänsten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="f5a24-293">När det betrodda certifikat arkivet har skapats och utrymmet för Server certifikatet har allokerats kan socketen användas för att upprätta en säker TLS-klient anslutning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="f5a24-294">Optimeringen använder "Packet buffer" som tillhandahålls av användar programmet till TLS-sessionen med hjälp av *nx_secure_tls_session_packet_buffer_set* för att allokera X. 509-parsningsfel i stället för att använda de användar strukturer som används i tidigare versioner av netx Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="f5a24-295">Det är osannolikt att det uppstår en certifikat kedja som överskrider storleken på paketets buffert, vilket innebär att paketets buffertstorlek kan ökas eller att *nx_secure_tls _remote_certificate_allocate* kan användas för att allokera mer utrymme för certifikat kedjan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="f5a24-296">Program gränssnitts anrop</span><span class="sxs-lookup"><span data-stu-id="f5a24-296">Application Interface Calls</span></span>

<span data-ttu-id="f5a24-297">NetX Secure TLS-program gör vanligt vis att funktions anrop inifrån program trådar som körs under ThreadX-återställnings tider.</span><span class="sxs-lookup"><span data-stu-id="f5a24-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="f5a24-298">Vissa initieringar, särskilt för underliggande nätverks protokoll för nätverks kommunikation (t. ex. TCP och IP) kan anropas från \*\**tx_application_define *.**</span><span class="sxs-lookup"><span data-stu-id="f5a24-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="f5a24-299">Mer information om hur du initierar nätverkskommunikation finns i användar handboken för NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="f5a24-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="f5a24-300">TLS utnyttjar krypterings rutiner som är processor intensiva åtgärder.</span><span class="sxs-lookup"><span data-stu-id="f5a24-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="f5a24-301">De här åtgärderna utförs vanligt vis inom ramen för anrop av tråd.</span><span class="sxs-lookup"><span data-stu-id="f5a24-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="f5a24-302">TLS-session-start</span><span class="sxs-lookup"><span data-stu-id="f5a24-302">TLS Session Start</span></span>

<span data-ttu-id="f5a24-303">TLS kräver ett underliggande nätverks protokoll för transport skikt för att fungera.</span><span class="sxs-lookup"><span data-stu-id="f5a24-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="f5a24-304">Protokollet används vanligt vis för TCP.</span><span class="sxs-lookup"><span data-stu-id="f5a24-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="f5a24-305">För att upprätta en NetX Secure TLS-session måste en TCP-anslutning upprättas med hjälp av NetX/NetXDuo TCP API.</span><span class="sxs-lookup"><span data-stu-id="f5a24-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="f5a24-306">En **NX_TCP_SOCKET** måste skapas och en anslutning upprättas med hjälp av **_nx_tcp_server_socket_listen_*_ och _*_nx_tcp_server_socket_accept_*_ tjänster (för TLS-server) eller _*_nx_tcp_client_socket_connect_** -tjänsten (för TLS-klienten).</span><span class="sxs-lookup"><span data-stu-id="f5a24-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="f5a24-307">När en TCP-anslutning har upprättats skickas TCP-socketen till ***nx_secure_tls_session_start*** tjänsten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="f5a24-308">Allokering av TLS-paket</span><span class="sxs-lookup"><span data-stu-id="f5a24-308">TLS Packet Allocation</span></span>

<span data-ttu-id="f5a24-309">NetX Secure TLS använder samma paket struktur som NetX/NetXDuo TCP (***NX_PACKET** _), förutom att i stället för att anropa tjänsten _*_nx_packet_allocate_*_ måste tjänsten _ *_nx_secure_tls_packet_allocate_** ANROPAs så att utrymmet för TLS-huvudet kan allokeras korrekt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="f5a24-310">Sändning av TLS-session</span><span class="sxs-lookup"><span data-stu-id="f5a24-310">TLS Session Send</span></span>

<span data-ttu-id="f5a24-311">När TLS-sessionen har startats kan programmet skicka data med hjälp av tjänsten \***nx_secure_tls_session_send** _.</span><span class="sxs-lookup"><span data-stu-id="f5a24-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="f5a24-312">Sändnings tjänsten är identisk med den _*_nx_tcp_socket_send_*_ tjänsten, med en _*_NX_PACKET_*_ data struktur som innehåller de data som skickas. endast dessa data krypteras av den säkra TLS-stacken för NX innan de skickas, och paketet måste allokeras med _ *_nx_secure_tls_packet_allocate_* \*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="f5a24-313">Mottagning av TLS-session</span><span class="sxs-lookup"><span data-stu-id="f5a24-313">TLS Session Receive</span></span>

<span data-ttu-id="f5a24-314">När TLS-sessionen har startats kan programmet ta emot data med hjälp av tjänsten \***nx_secure_tls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="f5a24-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="f5a24-315">Precis som TLS-sessionen skickar, är den här tjänsten identisk med _ *_nx_tcp_socket_receive_* \*, förutom att inkommande data dekrypteras och verifieras av TLS-stacken innan de returneras i paket strukturen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="f5a24-316">Sessionen stängs av TLS</span><span class="sxs-lookup"><span data-stu-id="f5a24-316">TLS Session Close</span></span>

<span data-ttu-id="f5a24-317">När en TLS-session har slutförts måste både TLS-klienten och servern skicka en CloseNotify-avisering till den andra sidan för att stänga av sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="f5a24-318">Båda sidorna måste ta emot och bearbeta aviseringen för att säkerställa att en lyckad session stängs av.</span><span class="sxs-lookup"><span data-stu-id="f5a24-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="f5a24-319">Om fjärrvärden skickar en CloseNotify avisering, bearbetar alla anrop till \***nx_secure_tls_session_receive** _-tjänsten aviseringen, skickar motsvarande avisering tillbaka till fjärrvärden och returnerar värdet _ *_NX_SECURE_TLS_SESSION_CLOSED_* \*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="f5a24-320">När sessionen har stängts Miss lyckas eventuella ytterligare försök att skicka eller ta emot data med den TLS-sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="f5a24-321">Om programmet vill stänga TLS-sessionen måste tjänsten \***nx_secure_tls_session_end** _ anropas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="f5a24-322">Tjänsten kommer att skicka CloseNotify-aviseringen och bearbeta svars CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="f5a24-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="f5a24-323">Om svaret inte tas emot returneras ett felvärde på _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, vilket indikerar att TLS-sessionen inte stängdes på rätt sätt, vilket möjliggör en säkerhets överträdelse.</span><span class="sxs-lookup"><span data-stu-id="f5a24-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="f5a24-324">TLS-aviseringar</span><span class="sxs-lookup"><span data-stu-id="f5a24-324">TLS Alerts</span></span>

<span data-ttu-id="f5a24-325">TLS är utformat för att ge maximal säkerhet, så alla Errant beteenden i protokollet betraktas som en potentiell säkerhets överträdelse.</span><span class="sxs-lookup"><span data-stu-id="f5a24-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="f5a24-326">Av den anledningen betraktas eventuella fel vid meddelande bearbetning eller kryptering/dekryptering av allvarliga fel som avslutar hand skakningen eller sessionen omedelbart.</span><span class="sxs-lookup"><span data-stu-id="f5a24-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="f5a24-327">Vid hantering av fel i ett lokalt program är det relativt enkelt att ta reda på att ett fel har inträffat för att hantera situationen på ett korrekt sätt och förhindra ytterligare eventuella säkerhets överträdelser.</span><span class="sxs-lookup"><span data-stu-id="f5a24-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="f5a24-328">Därför skickar TLS ett *varnings* meddelande till fjärrvärden vid eventuella fel.</span><span class="sxs-lookup"><span data-stu-id="f5a24-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="f5a24-329">Aviseringar behandlas på samma sätt som andra TLS-meddelanden och krypteras under sessionen för att förhindra att en angripare samlar in information från den typ av avisering som tillhandahålls.</span><span class="sxs-lookup"><span data-stu-id="f5a24-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="f5a24-330">Under hand skakningen är de skickade aviseringarna begränsade inom räckvidden för att begränsa den mängd information som kan erhållas av en potentiell angripare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="f5a24-331">CloseNotify-aviseringen som används för att stänga TLS-sessionen är den enda icke-allvarliga varningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="f5a24-332">Även om det anses vara en avisering och skickas som ett varnings meddelande, är en CloseNotify till skillnad från andra aviseringar i att det inte indikerar att ett fel har uppstått.</span><span class="sxs-lookup"><span data-stu-id="f5a24-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="f5a24-333">Avisering svärdet och "level" (nivåer är "varning" och "oåterkallelig" – de flesta TLS-aviseringar är "oåterkalleliga") definieras i TLS RFC och anger vilken typ av fel som inträffat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="f5a24-334">De flesta TLS-aviseringar än CloseNotify kan betraktas som en indikation på ett eventuellt säkerhets problem och resulterar i att TLS-sessionen eller hand skakningen avbryts.</span><span class="sxs-lookup"><span data-stu-id="f5a24-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="f5a24-335">Om ett TLS API-anrop returnerar **NX_SECURE_TLS_ALERT_RECEIVED** (0x114) kan API-tjänsten **_nx_secure_tls_session_alert_value_get_** (ny i NetX Secure TLS version 5,12) användas för att hämta TLS-aviseringens värde och nivå för det program som ska användas för alla beslut om svar på säkerhets frågor.</span><span class="sxs-lookup"><span data-stu-id="f5a24-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="f5a24-336">I de flesta fall bör aviseringar som tagits emot från andra fjärrvärddatorer än CloseNotify betraktas som ett allvarligt fel, även om det finns några excptions – mer information finns i TLS-rapporterna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="f5a24-337">Omförhandling av TLS-session</span><span class="sxs-lookup"><span data-stu-id="f5a24-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="f5a24-338">TLS stöder begreppet "omförhandling" som bara är en omförhandling av TLS-sessionens parametrar inom kontexten för en befintlig TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="f5a24-339">Vad det innebär i praktiken är att de nya hand skaknings meddelandena krypteras och autentiseras med den befintliga sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="f5a24-340">Omförhandling används när en TLS-värd vill generera nya sessionsnycklar (t. ex. generera nya TLS-sessionsnycklar) utan att behöva slutföra den befintliga sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="f5a24-341">Till exempel kan omförhandlingen vara önskvärd när säkerhets principer för ett program dikterar att sessionsnycklar endast används under en begränsad tid, men en TLS-session förblir aktiv utanför den tiden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="f5a24-342">Ett problem med omförhandlad session är att gör TLS sårbart för en speciell person-in-the-Middle-attack där en angripare kan övertyga en server att initiera en omförhandling med nya parametrar, vilket innebär att angriparen kan kapa TLS-sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="f5a24-343">För att undvika det här problemet introducerades tillägget för säker omförhandling (se avsnitts **fel! Referens källan hittades inte.**</span><span class="sxs-lookup"><span data-stu-id="f5a24-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="f5a24-344">avsnittet).</span><span class="sxs-lookup"><span data-stu-id="f5a24-344">section).</span></span>

<span data-ttu-id="f5a24-345">NetX Secure TLS har fullständigt stöd för omförhandlingar av sessioner och det säkra tillägget för säker omförhandling.</span><span class="sxs-lookup"><span data-stu-id="f5a24-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="f5a24-346">När du tar emot data från en fjärran sluten värd hanteras renegotations (och tillägget) automatiskt utan program interaktion.</span><span class="sxs-lookup"><span data-stu-id="f5a24-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="f5a24-347">Om ett meddelande om att omförhandlingar om sessioner önskas, kan ett återhandlings återanrop tillhandahållas med *nx_secure_tls_session_renegotiate_callback_set* -tjänsten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="f5a24-348">Återanropet anropas när en omförhandling begärs av fjärrvärden, vilket gör att programmet kan vidta åtgärder om så önskas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="f5a24-349">Starta en omförhandling från en aktiv TLS-session genom att bara anropa *nx_secure_tls_session_renegotiate* -tjänsten på den önskade TLS-sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="f5a24-350">Återupptagande av TLS-session</span><span class="sxs-lookup"><span data-stu-id="f5a24-350">TLS Session Resumption</span></span>

<span data-ttu-id="f5a24-351">Återupptagning av TLS-sessioner bör inte förväxlas med omförhandling av sessionen, trots vissa likheter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="f5a24-352">Om omstarten av *sessionen innebär att* starta en ny hand skakning inom en befintlig TLS *-session* är sessionen återupptagning en helt valfri funktion som inbegriper omstart av en stängd TLS-session utan att utföra en fullständig TLS-handskakning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="f5a24-353">För att åstadkomma detta kan en TLS-implementering cachelagra sessionens parametrar och nycklar, och associera dem med ett *sessions-ID,* en unik identifierare som anges i den ursprungliga hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="f5a24-354">Genom att tillhandahålla ett sessions-ID till en TLS-server anger en klient att en tidigare TLS-session mellan värdarna fanns och slutförts tidigare och att klienten fortfarande har tillstånd att återupprätta sessionen med en minskad hand skakning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="f5a24-355">Eftersom sessionsnycklarna är teoretiskt fortfarande hemliga och bara känd av de två kommunicerande värdarna, kan servern starta en ny TLS-session och kringgå det mesta av den normala hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="f5a24-356">Återupptagande av sessionen kan vara användbart för att undvika de potentiellt dyra offentliga nyckel åtgärder som används för att dela nyckeln för huvud hemligheten och verifiera certifikat, men det kräver också att sessionsnycklarna, nycklarna och crypotgraphic tillstånd bevaras i minnet för alla möjliga sessioner (minst för en konfigurerbar tids period).</span><span class="sxs-lookup"><span data-stu-id="f5a24-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="f5a24-357">Den aktuella versionen av NetX Secure TLS har inte stöd för att återuppta sessionen – sessions-ID: t ignoreras helt av TLS-servrar och TLS-klienter anger alltid ett NULL-sessions-ID som gör att servern kan utföra en fullständig hand skakning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="f5a24-358">Bristen på återupptagande av sessionen bör inte orsaka några Operability-problem eftersom det är en helt valfri funktion och alla TLS-implementeringar måste standardvärdet för en fullständig hand skakning om sessions-ID: t måste vara NULL eller okänd.</span><span class="sxs-lookup"><span data-stu-id="f5a24-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="f5a24-359">Protokoll skikt</span><span class="sxs-lookup"><span data-stu-id="f5a24-359">Protocol Layering</span></span>

<span data-ttu-id="f5a24-360">TLS-protokollet passar nätverks stacken mellan transport lagret (t. ex. TCP) och program skiktet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="f5a24-361">TLS anses ibland vara ett transport lager protokoll (till exempel *Transport Layer* Security), men eftersom det fungerar som ett program med avseende på de underliggande nätverks protokollen (t. ex. TCP) är det ibland grupperat i program lagret.</span><span class="sxs-lookup"><span data-stu-id="f5a24-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="f5a24-362">TLS kräver ett transport lager protokoll som stöder in-och förlustfri överföring, till exempel TCP.</span><span class="sxs-lookup"><span data-stu-id="f5a24-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="f5a24-363">På grund av detta krav kan TLS inte köras ovanpå UDP eftersom UDP inte garanterar leverans av datagram.</span><span class="sxs-lookup"><span data-stu-id="f5a24-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="f5a24-364">Ett separat protokoll som kallas *DTLS,* som är en modifierad version av TLS, används för program som behöver TLS-TLS över ett datagram-protokoll som UDP.</span><span class="sxs-lookup"><span data-stu-id="f5a24-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="f5a24-365">NetX Secure stöder DTLS, men dokumentationen för DTLS är separat från det här dokumentet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![Diagram över ett lager med TCP/IP-och TLS-protokoll.](media/image6.png)

<span data-ttu-id="f5a24-367">Bild 5 – TCP/IP-och TLS Protocol-lager</span><span class="sxs-lookup"><span data-stu-id="f5a24-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="f5a24-368">Säkerhet för nätverks kommunikation</span><span class="sxs-lookup"><span data-stu-id="f5a24-368">Network Communications Security</span></span>

<span data-ttu-id="f5a24-369">Att skydda kommunikation över offentliga nätverk och Internet är ett kritiskt viktigt ämne och ämnet för ett stort antal böcker, artiklar och lösningar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="f5a24-370">Avsnittet är en bogglingly komplex, men det kan minskas till en enkel idé: att skicka information via ett nätverk så att endast det avsedda målet kan komma åt eller ändra informationen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="f5a24-371">Detta bryts ned i tre viktiga begrepp: sekretess, integritet och autentisering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="f5a24-372">TLS-protokollet tillhandahåller lösningar för alla tre.</span><span class="sxs-lookup"><span data-stu-id="f5a24-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="f5a24-373">Hemliga</span><span class="sxs-lookup"><span data-stu-id="f5a24-373">Secrecy</span></span>

<span data-ttu-id="f5a24-374">När du skickar data via ett nätverk är det ofta viktigt att data inte kan hämtas av en skadlig entitet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="f5a24-375">Om data skickas via en TCP/IP-anslutning kommer alla med åtkomst till nätverket att kunna läsa dessa data med hjälp av enkelt tillgängliga nätverks verktyg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="f5a24-376">För att förhindra att data hämtas, måste det kodas så att det inte kan läsas med undantag av det avsedda målet – detta är *Sekretess.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="f5a24-377">I TLS tillhandahåller krypteringsalgoritmer som RSA och AES sekretess.</span><span class="sxs-lookup"><span data-stu-id="f5a24-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="f5a24-378">Integritet</span><span class="sxs-lookup"><span data-stu-id="f5a24-378">Integrity</span></span>

<span data-ttu-id="f5a24-379">Ibland är sekretessen inte tillräckligt för att skydda data i ett nätverk.</span><span class="sxs-lookup"><span data-stu-id="f5a24-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="f5a24-380">I vissa fall kan det vara möjligt för en skadlig enhet att ändra innehållet i ett TCP-paket utan att behöva känna till vad paketet innehåller.</span><span class="sxs-lookup"><span data-stu-id="f5a24-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="f5a24-381">Krypterade data kan ändras, åter givning av dekrypteringen är ogiltig eller ändra parametrarna i meddelandet som leder till det resultat som angriparen kan vara intresse rad av.</span><span class="sxs-lookup"><span data-stu-id="f5a24-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="f5a24-382">I nätverket kan vi inte hindra en angripare från att ändra data under överföringen, men vi kan tillhandahålla en mekanism för att veta om data har ändrats eller inte.</span><span class="sxs-lookup"><span data-stu-id="f5a24-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="f5a24-383">När data ändras under överföringen är det känt och data kan avvisas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="f5a24-384">Det här konceptet är *integritet*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-384">This concept is *integrity*.</span></span> <span data-ttu-id="f5a24-385">I TLS tillhandahålls integriteten av en klass av kryptografiska rutiner som kallas *hash-funktioner*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="f5a24-386">Några exempel på hash-funktioner är MD5 och SHA-1.</span><span class="sxs-lookup"><span data-stu-id="f5a24-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="f5a24-387">Autentisering</span><span class="sxs-lookup"><span data-stu-id="f5a24-387">Authentication</span></span>

<span data-ttu-id="f5a24-388">Det tredje viktiga konceptet i säkerheten för nätverks kommunikation är tanken att data endast bör förmedlas till det avsedda målet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="f5a24-389">En angripare kan försöka att utgöra en legitim entitet för att ta emot data som är avsedda för en annan värd.</span><span class="sxs-lookup"><span data-stu-id="f5a24-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="f5a24-390">Även om data skickas med hemligheter och integritets mekanismer på plats kan angriparen fortfarande uppnå det önskade resultatet (ett hot mot säker kommunikation) via den här bedrägeri.</span><span class="sxs-lookup"><span data-stu-id="f5a24-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="f5a24-391">För att förhindra detta krävs en mekanism för att bevisa identiteten för en fjärrvärd innan känsliga data skickas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="f5a24-392">Processen att bevisa identiteten för en fjärrvärd är *autentisering.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="f5a24-393">I TLS tillhandahålls autentiseringen med hjälp av digitala certifikat, hash-funktioner och en mekanism som kallas *digitala signaturer* som använder en egenskap för kryptering med offentliga nycklar (beskrivs nedan).</span><span class="sxs-lookup"><span data-stu-id="f5a24-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="f5a24-394">En begränsad men användbar form av autentisering kan också tillhandahållas med en i *förväg delad nyckel* (PSK).</span><span class="sxs-lookup"><span data-stu-id="f5a24-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="f5a24-395">TLS-kryptering</span><span class="sxs-lookup"><span data-stu-id="f5a24-395">TLS Encryption</span></span>

<span data-ttu-id="f5a24-396">TLS-protokollet är ett ramverk för att tillhandahålla säker nätverkskommunikation över Internet användningen av kryptering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="f5a24-397">Kryptering definieras vanligt vis som processen att koda data på ett sådant sätt att det blir svårare att hämta ursprungliga data (eller information om dessa data *).*</span><span class="sxs-lookup"><span data-stu-id="f5a24-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="f5a24-398">I dator system kryptering baseras på komplex matematik, till exempel begränsade fält och kan delas in i två typer: *privat nyckel* (eller *symmetrisk kryptering*) och *offentlig nyckel* (eller *asymmetrisk kryptering*).</span><span class="sxs-lookup"><span data-stu-id="f5a24-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="f5a24-399">Exempel på kryptering av privata nycklar är AES (Advanced Encryption Standard) och RC4 (Rivest chiffer 4).</span><span class="sxs-lookup"><span data-stu-id="f5a24-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="f5a24-400">Exempel på kryptering med offentliga nycklar är RSA (Rivest, Shamir, Adleson) och Diffie-Hellman chiffer.</span><span class="sxs-lookup"><span data-stu-id="f5a24-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="f5a24-401">TLS-protokollet använder både privat nyckel och krypterings rutiner för offentliga nycklar för att ge en balans mellan prestanda, säkerhet och flexibilitet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="f5a24-402">Private-Key kryptering</span><span class="sxs-lookup"><span data-stu-id="f5a24-402">Private-Key Encryption</span></span>

<span data-ttu-id="f5a24-403">Kryptering med privat nyckel används för tusentals år.</span><span class="sxs-lookup"><span data-stu-id="f5a24-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="f5a24-404">Grundläggande avskrifts chiffer (där en bokstav eller ett ord ersätts av en annan icke-relaterad bokstav eller ord) är de tidigaste kända krypterings exemplen, men med ankomsten av informations åldern privat nyckel kryptering har du betydligt förbättrat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="f5a24-405">En nyckel för privata nycklar använder en "nyckel" som bara är ett värde (som kan vara ett ord, en fras eller en siffra i det allmänna fallet) som används för att på ett sätt koda vissa data så att endast en entitet som hade åtkomst till nyckeln kan avkoda data på ett meningsfullt sätt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="f5a24-406">Nyckeln används både för kryptering och dekryptering av data, och därför är det andra namnet *symmetrisk kryptering*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="f5a24-407">Chiffer för privata nycklar är i allmänhet snabba och relativt enkla att implementera, även om matematik risken är mer komplex.</span><span class="sxs-lookup"><span data-stu-id="f5a24-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="f5a24-408">Av den anledningen använder TLS kryptering av privata nycklar för den stora mängden säker kommunikation.</span><span class="sxs-lookup"><span data-stu-id="f5a24-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="f5a24-409">Kryptering av privata nycklar har dock ett problem när vi försöker tillämpa den på allmän dator nätverkskommunikation: nyckeln måste delas mellan båda datorerna som försöker kommunicera.</span><span class="sxs-lookup"><span data-stu-id="f5a24-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="f5a24-410">I det allmänna fallet är det opraktiskt och ofta omöjligt att kommunicera en privat nyckel på ett säkert sätt mellan två datorer på Internet, eftersom det kan antas att nätverks trafiken kan erhållas av valfritt antal entiteter i olika hopp som data tar när de dirigeras via Internet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="f5a24-411">Om nyckeln hämtas av en skadlig entitet komprometteras alla data som krypteras med den nyckeln.</span><span class="sxs-lookup"><span data-stu-id="f5a24-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="f5a24-412">Eftersom de flesta datorer på Internet bara har en nätverks anslutning och inte en annan säker kanal för kommunikation, är tantamount för att skicka data okrypterade – den ger ingen säkerhet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="f5a24-413">Av den anledningen räcker det inte med kryptering av privata nycklar för att implementera ett allmänt nätverks kommunikations säkerhets protokoll.</span><span class="sxs-lookup"><span data-stu-id="f5a24-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="f5a24-414">Det är här som kryptering av offentliga nycklar kan hjälpa dig.</span><span class="sxs-lookup"><span data-stu-id="f5a24-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="f5a24-415">NetX Secure TLS stöder kryptering med privat nyckel för AES.</span><span class="sxs-lookup"><span data-stu-id="f5a24-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="f5a24-416">Public-Key kryptering</span><span class="sxs-lookup"><span data-stu-id="f5a24-416">Public-Key Encryption</span></span>

<span data-ttu-id="f5a24-417">Till skillnad från kryptering med privat nyckel är kryptering av offentliga nycklar ett ganska nytt koncept, som har utvecklats i 1970.</span><span class="sxs-lookup"><span data-stu-id="f5a24-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="f5a24-418">Om du använder ett koncept som kallas "Trap-dörr funktioner" i matematik upptäcktes det att det fanns ett sätt att dela en nyckel över ett nätverk utan att kompromissa med säkerheten hos krypterade data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="f5a24-419">Det kan vara så att kryptering av offentliga nycklar fungerar att nyckeln (i den privata nyckel krypterings metoden som beskrivs ovan) delas upp i två delar, en *privat nyckel* och en *offentlig nyckel*, från vilken kryptering med offentlig nyckel får sitt namn.</span><span class="sxs-lookup"><span data-stu-id="f5a24-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="f5a24-420">Konceptet är att en av dessa nycklar (vanligt vis den offentliga nyckeln) används för kryptering, medan den andra används för dekryptering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="f5a24-421">Den här asymmetry av nycklar är orsaken till det andra namnet för kryptering av offentlig nyckel: *asymmetrisk kryptering*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="f5a24-422">Matematik krypteringen bakom kryptering i offentliga nycklar är ganska komplex, men tanken är att den offentliga nyckeln *bara* kan användas för kryptering och att hämtning av nyckeln inte tillåter att krypterade data hämtas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="f5a24-423">Den privata nyckeln är i sin tur det enda sättet att dekryptera data som krypteras med hjälp av den offentliga nyckeln.</span><span class="sxs-lookup"><span data-stu-id="f5a24-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="f5a24-424">Genom att behålla hemligheten för privata nycklar behöver vem som helst som vill kommunicera säkert med ägaren av den privata nyckeln bara kryptera sina data med motsvarande offentliga nyckel med den kunskap som bara någon som har till gång till den privata nyckeln kan hämta säkra data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="f5a24-425">NetX Secure TLS stöder RSA-kryptering med offentliga nycklar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="f5a24-426">*RSA är en mycket processor intensiv åtgärd om program-RSA-implementeringen används. Större nyckel storlekar ökar den bearbetnings kraft som krävs av en kvadratisk faktor – 4X långsammare för en 2X ökning i nyckel storleken.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="f5a24-427">Public-Key autentisering</span><span class="sxs-lookup"><span data-stu-id="f5a24-427">Public-Key Authentication</span></span>

<span data-ttu-id="f5a24-428">En intressant sido effekt av krypterings konceptet för offentliga nycklar är att det kan användas för att tillhandahålla autentisering och kryptering genom att utföra åtgärden baklänges: Kryptera med hjälp av den *privata* nyckeln och dekryptera med hjälp av den *offentliga* nyckeln.</span><span class="sxs-lookup"><span data-stu-id="f5a24-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="f5a24-429">Den faktiska mekanismen för att göra detta beror på vilka algoritmer för offentlig nyckel som används, men begreppet är detsamma.</span><span class="sxs-lookup"><span data-stu-id="f5a24-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="f5a24-430">För att autentisera med autentisering med offentlig nyckel krypterar ägaren av en privat nyckel vissa data (vanligt vis en kryptografisk hash av de data som ska autentiseras) med hjälp av den privata nyckeln.</span><span class="sxs-lookup"><span data-stu-id="f5a24-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="f5a24-431">Sedan kan någon som vill autentisera att data kommer från ägaren av den privata nyckeln använda den associerade offentliga nyckeln för att dekryptera data – om dekrypteringen lyckas, och förutsatt att användaren har förtroende för att den offentliga nyckeln är giltig, kan användaren vara säker på att data kommer från ägaren av den privata nyckeln.</span><span class="sxs-lookup"><span data-stu-id="f5a24-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="f5a24-432">I TLS används autentisering med offentlig nyckel för att kontrol lera giltigheten hos ett digitalt certifikat som tillhandahålls av en TLS-server (och eventuellt TLS-klienten) med hjälp av offentliga nycklar från det betrodda certifikat arkivet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="f5a24-433">Certifikatet kontrol leras mot en offentlig nyckel i arkivet och data i certifikatet används för att kontrol lera serverns identitet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="f5a24-434">NetX Secure TLS stöder RSA-autentisering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="f5a24-435">Kryptografisk hashing</span><span class="sxs-lookup"><span data-stu-id="f5a24-435">Cryptographic Hashing</span></span>

<span data-ttu-id="f5a24-436">Kryptering är inte den enda kryptografiska åtgärd som används i TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="f5a24-437">För att kunna tillhandahålla meddelande integritet under en TLS-session krävs en kontroll summa för att säkerställa att meddelande innehållet inte har manipulerats.</span><span class="sxs-lookup"><span data-stu-id="f5a24-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="f5a24-438">En enkel kontroll Summa (som används i TCP) är dock inte tillräckligt för att garantera en godtagbar integritets nivå eftersom den kan vara lätt att förenkla av en kunnig angripare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="f5a24-439">Mekanismen som används av TLS för att tillhandahålla meddelande integritet kallas *kryptografisk hash*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="f5a24-440">Kryptering är en 1:1-kodning – det vill säga att hela den ursprungliga informationen kan hämtas från krypterade data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="f5a24-441">En hash mappar dock en godtycklig mängd data till ett fast storleks värde, precis som en kontroll summa.</span><span class="sxs-lookup"><span data-stu-id="f5a24-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="f5a24-442">Till skillnad från en enkel kontroll summa är en hash särskilt utformad för att minska *kollisioner*, där olika indata resulterar i samma utdata.</span><span class="sxs-lookup"><span data-stu-id="f5a24-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="f5a24-443">I en enkel kontroll summa, om en bit vänds från 1 till 0 och en annan bit från 0 till 1, är kontroll summan densamma.</span><span class="sxs-lookup"><span data-stu-id="f5a24-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="f5a24-444">Med en kryptografisk hash skulle utdata variera avsevärt, vilket gör det svårt för en angripare att ändra de hashade data och att hash-åtgärden för de ändrade data fortfarande resulterar i samma värde (och därmed felaktigt verifierar integriteten för dessa data).</span><span class="sxs-lookup"><span data-stu-id="f5a24-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="f5a24-445">TLS använder ett antal olika hash-algoritmer för att tillhandahålla integritet för meddelanden, både program meddelanden och TLS-kontrollmeddelanden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="f5a24-446">Dessa inkluderar MD5, SHA-1 och SHA-256.</span><span class="sxs-lookup"><span data-stu-id="f5a24-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="f5a24-447">NetX Secure TLS stöder MD5-, SHA-1-och SHA-256-hashing.</span><span class="sxs-lookup"><span data-stu-id="f5a24-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="f5a24-448">TLS-tillägg</span><span class="sxs-lookup"><span data-stu-id="f5a24-448">TLS Extensions</span></span>

<span data-ttu-id="f5a24-449">TLS tillhandahåller ett antal tillägg som ger ytterligare funktioner för vissa program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="f5a24-450">Dessa tillägg skickas vanligt vis som en del av sitt hälsnings-eller ServerHello-meddelandena, vilket indikerar att en fjärrvärd vill använda ett tillägg eller tillhandahålla ytterligare information som används för att upprätta en säker TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="f5a24-451">I allmänhet tillhandahåller tillägg valfria parametrar till TLS i början av hand skakningen som vägleder dig om åtgärderna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="f5a24-452">Vissa tillägg kräver programinformation eller besluts fattande, medan andra hanteras automatiskt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="f5a24-453">I följande tabell beskrivs de TLS-tillägg som för närvarande stöds av NetX Secure TLS:</span><span class="sxs-lookup"><span data-stu-id="f5a24-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="f5a24-454">**Tilläggs namn**</span><span class="sxs-lookup"><span data-stu-id="f5a24-454">**Extension Name**</span></span>              | <span data-ttu-id="f5a24-455">**Beskrivning**</span><span class="sxs-lookup"><span data-stu-id="f5a24-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="f5a24-456">Säker omförhandlad indikering</span><span class="sxs-lookup"><span data-stu-id="f5a24-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="f5a24-457">Det här tillägget minskar risken för en man-in-the-Middle-attack som kan uppstå under en omförhandlande hand skakning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="f5a24-458">Servernamnindikator</span><span class="sxs-lookup"><span data-stu-id="f5a24-458">Server Name Indication</span></span>          | <span data-ttu-id="f5a24-459">Med det här tillägget kan en TLS-klient tillhandahålla ett särskilt DNS-namn till en TLS-server, vilket gör att servern kan välja rätt autentiseringsuppgifter (förutsätter att servern har flera identitets certifikat och nätverks-entrypoints).</span><span class="sxs-lookup"><span data-stu-id="f5a24-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="f5a24-460">Algoritmer för signaturer</span><span class="sxs-lookup"><span data-stu-id="f5a24-460">Signature Algorithms</span></span>            | <span data-ttu-id="f5a24-461">Med det här tillägget kan en TLS-klient tillhandahålla en lista över acceptabel signatur och hash-algoritmer till en TLS-server.</span><span class="sxs-lookup"><span data-stu-id="f5a24-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="f5a24-462">Översikt över TLS-tillägg som stöds</span><span class="sxs-lookup"><span data-stu-id="f5a24-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="f5a24-463">Säker omförhandlad indikering</span><span class="sxs-lookup"><span data-stu-id="f5a24-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="f5a24-464">TLS har stöd för att utföra en hand skakning i en befintlig TLS-session, och därmed använda den etablerade sessionen för att kryptera hand skaknings meddelanden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="f5a24-465">Med den här processen kan de kryptografiska sessionsnycklarna återupprättas utan att du avslutar TLS-sessionen (se avsnittet "omförhandlingar av TLS-session").</span><span class="sxs-lookup"><span data-stu-id="f5a24-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="f5a24-466">När TLS hade använt omförhandling under en viss tid upptäcktes det att det uppstod ett problem med en man-in-the-Middle-attack som utnyttjade funktionen för omförhandling.</span><span class="sxs-lookup"><span data-stu-id="f5a24-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="f5a24-467">För att stänga säkerhets problemet introducerades tillägget för säker omförhandlad indikering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="f5a24-468">I huvudsak används den färdiga meddelande-hashen från den upprättade anslutningen för att verifiera att de ursprungliga värdarna deltar i hand skakningen – i princip används hashen som en Verification-token under antagandet att en angripare inte kan falska hash (som kräver åtkomst till sessionsnycklarna).</span><span class="sxs-lookup"><span data-stu-id="f5a24-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="f5a24-469">NetX Secure TLS hanterar omförhandling automatiskt och använder tillägget för säker omförhandling som standard.</span><span class="sxs-lookup"><span data-stu-id="f5a24-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="f5a24-470">Ingen program interaktion krävs.</span><span class="sxs-lookup"><span data-stu-id="f5a24-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="f5a24-471">Servernamnindikator</span><span class="sxs-lookup"><span data-stu-id="f5a24-471">Server Name Indication</span></span>

<span data-ttu-id="f5a24-472">Under TLS-handskakning förväntar en TLS-klient en fjärrserver för att tillhandahålla ett identitets certifikat så att klienten kan autentisera servern.</span><span class="sxs-lookup"><span data-stu-id="f5a24-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="f5a24-473">Det kan dock finnas fall där en server tillhandahåller flera olika tjänster med olika "virtuella" servrar som har unika identiteter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="f5a24-474">Om det finns en enskild server med flera identiteter kan en TLS-klient ange ett visst DNS-namn som servern ska använda för att välja rätt autentiseringsuppgifter – mekanismen för att tillhandahålla detta namn är tillägget Servernamnindikator (SNI).</span><span class="sxs-lookup"><span data-stu-id="f5a24-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="f5a24-475">För ett program som använder SNI-tillägget krävs en del interaktion.</span><span class="sxs-lookup"><span data-stu-id="f5a24-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="f5a24-476">För TLS-klienter måste programmet ange ett DNS-namn som ska skickas till fjärrservern.</span><span class="sxs-lookup"><span data-stu-id="f5a24-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="f5a24-477">För TLS-servrar måste programmet läsa DNS-namnet från tillägget och välja ett lämpligt certifikat för att skicka tillbaka till klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="f5a24-478">I följande avsnitt finns mer information om hur du använder SNI-tillägget i NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="f5a24-479">SNI-tillägg – TLS-klient</span><span class="sxs-lookup"><span data-stu-id="f5a24-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="f5a24-480">En NetX säker TLS-klient som vill använda SNI-tillägget måste ange ett DNS-namn som TLS ska tillhandahållas under hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="f5a24-481">Det här namnet måste initieras och anges innan en TLS-session startas eftersom tillägget skickas i sitt hälsnings-meddelandet som startar hand skaknings processen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="f5a24-482">Följande kodfragment illustrerar användningen av tillägget.</span><span class="sxs-lookup"><span data-stu-id="f5a24-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="f5a24-483">Först initieras ett NX_SECURE_X509_DNS_NAME-objekt med det önskade Server namnet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="f5a24-484">Innan TLS-sessionen startas skickas namnet till TLS med hjälp av SNI-tilläggs-API: et.</span><span class="sxs-lookup"><span data-stu-id="f5a24-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="f5a24-485">När namnet har angetts krävs ingen ytterligare åtgärd.</span><span class="sxs-lookup"><span data-stu-id="f5a24-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="f5a24-486">Se API-referensen i kapitel 4</span><span class="sxs-lookup"><span data-stu-id="f5a24-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="f5a24-487">Beskrivning av NetX säkra tjänster för mer information om de enskilda funktionerna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="f5a24-488">SNI-tillägg – TLS-server</span><span class="sxs-lookup"><span data-stu-id="f5a24-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="f5a24-489">På TLS-server sidan kan SNI-tillägget bearbetas av programmet för att välja rätt autentiseringsuppgifter (t. ex. certifikat) för att tillhandahålla fjärrklienten under hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="f5a24-490">För att göra detta måste programmet ange ett motanrop som anropas efter att ett sitt hälsnings-meddelande har mottagits.</span><span class="sxs-lookup"><span data-stu-id="f5a24-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="f5a24-491">Exempel koden för nx_secure_tls_session_server_callback_set-API: et (se sidan 122) visar tolkningen av ett inkommande SNI-tillägg med ett Server återanrop.</span><span class="sxs-lookup"><span data-stu-id="f5a24-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="f5a24-492">I princip tar TLS-servern emot en sitt hälsnings och anropar återanropet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="f5a24-493">Sedan använder programmet *nx_secure_tls_session_sni_extension_parse* -API: et för att parsa de tilläggs data som anges för återanropet för att hitta SNI-tillägget och returnera det angivna DNS-namnet (Observera att tillägget endast stöder ett enda DNS-namn).</span><span class="sxs-lookup"><span data-stu-id="f5a24-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="f5a24-494">När namnet har hämtats använder programmet det för att hitta och skicka lämpligt Server identitets certifikat (och utfärdare om det är tillämpligt).</span><span class="sxs-lookup"><span data-stu-id="f5a24-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="f5a24-495">Tillägg för signaturalgoritm</span><span class="sxs-lookup"><span data-stu-id="f5a24-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="f5a24-496">Det här tillägget är särskilt för TLS 1,2 och tillåter att en TLS-klient tillhandahåller en lista över acceptabla signaturer och hash-algoritmer som godkänns för användning i att skapa och verifiera digitala signaturer.</span><span class="sxs-lookup"><span data-stu-id="f5a24-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="f5a24-497">Listan genereras automatiskt av NetX Secure TLS för TLS-klienter med hjälp av tabellen cipher som anges till *nx_secure_tls_session_create*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="f5a24-498">Ingen program interaktion krävs.</span><span class="sxs-lookup"><span data-stu-id="f5a24-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="f5a24-499">Autentiseringsmetoder</span><span class="sxs-lookup"><span data-stu-id="f5a24-499">Authentication Methods</span></span>

<span data-ttu-id="f5a24-500">TLS ger ramverket för att upprätta en säker anslutning mellan två enheter över ett oskyddat nätverk, men en del av problemet är att känna till enhetens identitet i den andra änden av anslutningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="f5a24-501">Utan en mekanism för att autentisera identiteten för fjärranslutna värdar blir det en trivial åtgärd för en angripare att utgöra en betrodd enhet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="f5a24-502">Inlednings vis kan det verka som att använda IP-adresser, MAC-adresser för maskin vara eller DNS ger en relativt hög exakthet för att identifiera värdar i ett nätverk, men med tanke på vilken typ av TCP/IP-teknik som kan vara falska och vilka adresser som kan vara falska och DNS-poster skadas (t. ex. genom DNS-cachelagring av data), är det klart att TLS behöver ett extra skydd mot bedrägliga identiteter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="f5a24-503">Det finns olika mekanismer som kan ge detta extra lager av autentisering för TLS, men det vanligaste är det *digitala certifikatet.*</span><span class="sxs-lookup"><span data-stu-id="f5a24-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="f5a24-504">Andra mekanismer är i förväg delade nycklar (PSK) och lösen ords scheman.</span><span class="sxs-lookup"><span data-stu-id="f5a24-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="f5a24-505">Digital certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-505">Digital Cerificates</span></span>

<span data-ttu-id="f5a24-506">Digitala certifikat är den vanligaste metoden för att autentisera en fjärran sluten värd i TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="f5a24-507">I stort sett är ett digitalt certifikat ett dokument med en speciell formatering som ger identitets information för en enhet i ett dator nätverk.</span><span class="sxs-lookup"><span data-stu-id="f5a24-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="f5a24-508">TLS använder normalt ett format som kallas X. 509, en standard som utvecklats av International Telecommunication union, även om andra certifikat utfärdare kan användas om TLS-värdarna kan komma överens om det format som används.</span><span class="sxs-lookup"><span data-stu-id="f5a24-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="f5a24-509">X. 509 definierar ett särskilt format för certifikat och olika kodningar som kan användas för att skapa ett digitalt dokument.</span><span class="sxs-lookup"><span data-stu-id="f5a24-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="f5a24-510">De flesta X. 509-certifikat som används med TLS kodas med hjälp av en variant av ASN. 1, en annan telekommunikations standard.</span><span class="sxs-lookup"><span data-stu-id="f5a24-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="f5a24-511">I ASN. 1 finns olika digitala kodningar, men den vanligaste kodningen för TLS-certifikat är Distinguished Encoding Rules (DER) standard.</span><span class="sxs-lookup"><span data-stu-id="f5a24-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="f5a24-512">DER är en förenklad del av de grundläggande kodnings reglerna för ASN. 1 (BER) som är utformade för att vara entydiga, vilket gör det enklare att parsa.</span><span class="sxs-lookup"><span data-stu-id="f5a24-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="f5a24-513">TLS-certifikat kodas vanligt vis i binärt DER, och detta är det format som NetX säkrar för X. 509-certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="f5a24-514">Även om DER-formaterade binära certifikat används i det faktiska TLS-protokollet kan de skapas och lagras i ett antal olika kodningar, med fil namns tillägg som. PEM,. CRT och. p12.</span><span class="sxs-lookup"><span data-stu-id="f5a24-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="f5a24-515">Olika varianter används av olika program från olika tillverkare, men alla kan ofta konverteras till DER med hjälp av mycket tillgängliga verktyg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="f5a24-516">De vanligaste av de alternativa certifikat kodningarna är PEM.</span><span class="sxs-lookup"><span data-stu-id="f5a24-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="f5a24-517">PEM-formatet (från Privacy-Enhanced mail) är en Base-64-kodad version av DER-kodningen som ofta används eftersom kodningen resulterar i utskrivbar text som enkelt kan skickas via e-post eller webbaserade protokoll.</span><span class="sxs-lookup"><span data-stu-id="f5a24-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="f5a24-518">Att skapa ett certifikat för ditt NetX-säkra program ligger vanligt vis utanför omfånget för den här hand boken, men kommando rads verktyget OpenSSL ([www.openssl.org](http://www.openssl.org)) är mycket tillgängligt och kan konverteras mellan de flesta format.</span><span class="sxs-lookup"><span data-stu-id="f5a24-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="f5a24-519">Beroende på ditt program kan du skapa egna certifikat, tillhandahålla certifikat av en tillverkare eller myndighets organisation eller köpa certifikat från en kommersiell certifikat utfärdare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="f5a24-520">Om du vill använda ett digitalt certifikat i NetX-skyddat program måste du först konvertera certifikatet till ett binärformat och eventuellt konvertera den associerade privata nyckeln ("privat exponent" för RSA, till exempel) till ett binärformat, vanligt vis en PKCS # 1-formaterad, DER-kodad RSA-nyckel eller en DER-kodad ECC-nyckel.</span><span class="sxs-lookup"><span data-stu-id="f5a24-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="f5a24-521">När konverteringen är klar är det upp till dig att läsa in certifikatet och den privata nyckeln på enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="f5a24-522">Möjliga alternativ är att använda ett Flash-baserat fil system eller skapa en C-matris från data (med ett verktyg som "XXD" från Linux) och kompilera certifikatet och nyckeln till ditt program som konstant data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="f5a24-523">När ditt certifikat har lästs in på enheten kan TLS-API: et användas för att associera certifikatet med en TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="f5a24-524">Mer information och exempel på hur du använder X. 509-certifikat med NetX Secure TLS finns i avsnittet "Importera X. 509-certifikat till NetX Secure".</span><span class="sxs-lookup"><span data-stu-id="f5a24-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="f5a24-525">Mer information hittar du i följande TLS-tjänster i API-referensen:</span><span class="sxs-lookup"><span data-stu-id="f5a24-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="f5a24-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="f5a24-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="f5a24-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="f5a24-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="f5a24-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="f5a24-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="f5a24-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="f5a24-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="f5a24-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="f5a24-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="f5a24-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="f5a24-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="f5a24-532">Certifikats information för TLS-klient</span><span class="sxs-lookup"><span data-stu-id="f5a24-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="f5a24-533">TLS-klientens implementeringar kräver vanligt vis inte att "lokalt" certifikat<sup>14</sup> ska läsas in på enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="f5a24-534">Undantaget till detta är när autentisering av klient certifikat är aktiverat, men detta är mycket mindre vanligt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="f5a24-535">En TLS-klient kräver minst ett "betrott" certifikat<sup>15</sup> som ska läsas in (mer kan läsas in om det behövs) och utrymme för ett "fjärran slutet" certifikat<sup>16</sup> att allokera.</span><span class="sxs-lookup"><span data-stu-id="f5a24-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="f5a24-536">Mer information om hur du lägger till betrodda certifikat och hur du allokerar utrymme för fjärrcertifikat finns i TLS API-referensen för följande tjänster: nx_secure_tls_remote_certificate_allocate nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="f5a24-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="f5a24-537">Ett "lokalt" certifikat är ett certifikat som identifierar den lokala enheten – det vill säga den innehåller identitets information för enheten som TLS-programmet läses in på.</span><span class="sxs-lookup"><span data-stu-id="f5a24-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="f5a24-538">Ett "betrott" certifikat är ett certifikat som tillhandahåller en grund för förtroende och autentisering av fjär renheten, antingen direkt eller via en PKI (Public Key Infrastructure).</span><span class="sxs-lookup"><span data-stu-id="f5a24-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="f5a24-539">Roten i förtroende kedjan kallas vanligt vis för en "certifikat utfärdare" eller CA-certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="f5a24-540">Ett "fjärran slutet" certifikat syftar på det certifikat som skickas av fjärrvärden under TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="f5a24-541">Den ger identitet för den fjärranslutna värden och autentiseras genom att jämföra den med ett "betrott" certifikat på den lokala enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="f5a24-542">Information om TLS-servercertifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="f5a24-543">TLS-serverimplementeringar kräver vanligt vis inte "betrodda" certifikat att läsas in på enheten eller fjärrcertifikaten som ska allokeras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="f5a24-544">Detta undantag är att när klient certifikatets autentisering är aktiverat (detta är mindre vanligt).</span><span class="sxs-lookup"><span data-stu-id="f5a24-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="f5a24-545">En TLS-server kräver att ett "lokalt" certifikat läses in så att servern kan ge den till fjärrklienten under TLS-handskakningen för att autentisera servern för klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="f5a24-546">Mer information om hur du läser in lokala certifikat för användning med NetX TLS server-program finns i API-referensen för följande tjänster:</span><span class="sxs-lookup"><span data-stu-id="f5a24-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="f5a24-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="f5a24-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="f5a24-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="f5a24-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="f5a24-549">I förväg delade nycklar (PSK)</span><span class="sxs-lookup"><span data-stu-id="f5a24-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="f5a24-550">En alternativ mekanism för att tillhandahålla identifierings autentisering i TLS är begreppet i förväg delade nycklar (PSK).</span><span class="sxs-lookup"><span data-stu-id="f5a24-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="f5a24-551">Om du använder en PSK-ciphersuite elimineras behovet av att utföra processor intensiva krypterings åtgärder för offentliga nycklar, en Boon för resurs begränsade inbäddade enheter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="f5a24-552">PSK ersätter certifikatet i TLS-handskakningen och används i stället för den krypterade huvud hemligheten för generering av TLS-sessionsnycklar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="f5a24-553">PSK-krypteringssviter är begränsade i den mening att en delad hemlighet måste finnas på båda enheterna innan en TLS-session kan upprättas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="f5a24-554">Det innebär att enheterna måste ha lästs in med den hemligheten med hjälp av ett säkert sätt än en TLS PSK-anslutning – PSKs kan uppdateras via en TLS PSK-anslutning, men enheten måste nödvändigt vis börja med en PSK som läses in via någon annan mekanism.</span><span class="sxs-lookup"><span data-stu-id="f5a24-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="f5a24-555">Till exempel kan en sensor enhet och dess gateway-enhet läsas in med PSKs i fabriken innan det levereras, eller en standard-TLS-anslutning (med ett certifikat) kan användas för att läsa in PSK.</span><span class="sxs-lookup"><span data-stu-id="f5a24-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="f5a24-556">PSK-krypteringssviter levereras i ett par formulär som beskrivs i RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="f5a24-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="f5a24-557">Först används RSA-eller Diffie-Hellman nycklar som används på samma sätt som de offentliga nycklar som skickas i certifikatet i standard-TLS-handskakning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="f5a24-558">Det andra formuläret, som används i en resurs begränsad miljö, använder en PSK som används för att direkt generera sessionsnycklar (för användning av AES, till exempel), så att du undviker användningen av dyra RSA-eller Diffie-Hellman-åtgärder.</span><span class="sxs-lookup"><span data-stu-id="f5a24-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="f5a24-559">NetX Secure stöder den andra formen av PSK-krypteringssviter, vilket gör det möjligt för program att ta bort all krypterings kod för offentliga nycklar och minnes användning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="f5a24-560">Själva PSK är inte en AES-nyckel, men kan anses som ett lösen ord som de faktiska nycklarna genereras från.</span><span class="sxs-lookup"><span data-stu-id="f5a24-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="f5a24-561">Det finns några begränsningar för vad PSK-värdet kan vara, även om längre värden ger högre säkerhet (samma som med lösen ord).</span><span class="sxs-lookup"><span data-stu-id="f5a24-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="f5a24-562">Om du vill använda PSK med ditt NetX-säkra program måste du först definiera det globala makrot **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="f5a24-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="f5a24-563">Detta görs vanligt vis via dina kompilator inställningar, men definitionen kan också placeras i huvud filen nx_secure_tls. h.</span><span class="sxs-lookup"><span data-stu-id="f5a24-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="f5a24-564">Med det definierade makrot kommer PSK ciphersuite-stödet att kompileras till ditt NetX-säkra TLS-program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="f5a24-565">När PSK-stödet är aktiverat kan du använda TLS API för att konfigurera PSKs för ditt program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="f5a24-566">Varje PSK kräver ett PSK-värde (den faktiska hemliga nyckeln "– Behåll det här värdet säkert), ett" Identity "-värde som används för att identifiera specifika PSK och ett" identitets tips "som används av en TLS-server för att välja ett visst PSK-värde.</span><span class="sxs-lookup"><span data-stu-id="f5a24-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="f5a24-567">Själva PSK-objektet kan vara ett binärt värde eftersom det aldrig skickas via en nätverks anslutning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="f5a24-568">PSK kan vara valfritt värde upp till 64 byte långt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="f5a24-569">Identiteten och tipset måste vara utskrivbara sträng strängar formaterade med UTF-8.</span><span class="sxs-lookup"><span data-stu-id="f5a24-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="f5a24-570">Värdena för identitet och ledtråd kan vara en valfri längd på upp till 128 byte.</span><span class="sxs-lookup"><span data-stu-id="f5a24-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="f5a24-571">Identiteten och PSK-formen bildar ett unikt par som läses in på varje enhet i nätverket som behöver kommunicera med varandra.</span><span class="sxs-lookup"><span data-stu-id="f5a24-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="f5a24-572">"Tipset" används främst för att definiera specifika program profiler för att gruppera PSKs efter funktion eller tjänst.</span><span class="sxs-lookup"><span data-stu-id="f5a24-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="f5a24-573">Dessa värden måste överenskommas i förväg och är beroende av program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="f5a24-574">Som exempel använder OpenSSL kommando rads serverprogram (med PSK aktiverat) standard strängen "Client_identity", som måste tillhandahållas av en TLS-klient för att kunna fortsätta med TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="f5a24-575">Mer information om PSKs finns i NetX Secure API-referens för följande tjänster: nx_secure_tls_client_psk_set nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="f5a24-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="f5a24-576">Importerar X. 509-certifikat till NetX Secure</span><span class="sxs-lookup"><span data-stu-id="f5a24-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="f5a24-577">Digitala certifikat krävs för de flesta TLS-anslutningar på Internet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="f5a24-578">Certifikat ger en metod för att autentisera tidigare okända värdar via Internet genom användning av betrodda mellanhänder, vanligt vis kallade *certifikat utfärdare eller certifikat* utfärdare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="f5a24-579">Om du vill ansluta din NetX-enhet till en kommersiell moln tjänst (till exempel Amazon Web Services) måste du importera certifikat till ditt program genom att läsa in dem på enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="f5a24-580">Tillsammans med certifikat behöver du ibland även en *privat nyckel* som är kopplad till ditt certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="f5a24-581">I vissa program (t. ex. TLS-klient när autentisering av klient certifikat används inte) är certifikatet tillräckligt, men om ditt certifikat används för att identifiera din enhet behöver du en privat nyckel.</span><span class="sxs-lookup"><span data-stu-id="f5a24-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="f5a24-582">Privata nycklar skapas vanligt vis när du skapar ditt certifikat och lagras i en separat fil, ofta krypterat med ett lösen ord.</span><span class="sxs-lookup"><span data-stu-id="f5a24-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="f5a24-583">Typer av certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-583">Certificate Types</span></span>

<span data-ttu-id="f5a24-584">Digitala certifikat används vanligt vis för att identifiera entiteter i ett nätverk, men beroende på vad deras program kommer att ha något annorlunda egenskaper.</span><span class="sxs-lookup"><span data-stu-id="f5a24-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="f5a24-585">Lokala certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-585">Local Certificates</span></span>

<span data-ttu-id="f5a24-586">I den här dokumentationen kommer vi att referera till "lokala certifikat" som de certifikat som ger en identitet för vår lokala enhet (ett annat möjligt namn kan vara "enhets certifikat").</span><span class="sxs-lookup"><span data-stu-id="f5a24-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="f5a24-587">De här certifikaten kommer att tillhandahållas till en fjärrvärd när fjärrvärden vill autentisera den lokala enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="f5a24-588">Fjärrcertifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-588">Remote Certificates</span></span>

<span data-ttu-id="f5a24-589">I den här dokumentationen avser "fjärrcertifikat" de certifikat som tillhandahålls av en fjärrvärd under TLS-handskakning när det är tillämpligt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="f5a24-590">Utrymmet för dessa certifikat måste tilldelas eller så kan NetX säkra inte parsa dem och slutföra TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="f5a24-591">Signerings certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-591">Signing Certificates</span></span>

<span data-ttu-id="f5a24-592">Ett "signerings certifikat" används för att digitalt signera andra certifikat eller data för autentisering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="f5a24-593">Dessa certifikat kan vara antingen mellanliggande eller rot certifikat inom en PKI (Public Key Infrastructure) och används vanligt vis inte för att identifiera enskilda enheter eller värdar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="f5a24-594">Certifikat från rot certifikat utfärdare</span><span class="sxs-lookup"><span data-stu-id="f5a24-594">Root CA Certificates</span></span>

<span data-ttu-id="f5a24-595">"Rot certifikat utfärdarens certifikat" är signerings certifikat som utgör grunden för en PKI och som är självsignerade, i stället för att signeras av ett annat signerings certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="f5a24-596">Minst ett rot certifikat för certifikat utfärdare krävs vanligt vis för att en TLS-klient ska kunna verifiera fjärrservrar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="f5a24-597">Certifikat format</span><span class="sxs-lookup"><span data-stu-id="f5a24-597">Certificate formats</span></span>

<span data-ttu-id="f5a24-598">Digitala certifikat är bara filer som innehåller strukturerade data som kodas med hjälp av ASN. 1-syntaxen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="f5a24-599">Det finns dock olika format där certifikat kan lagras och det är viktigt att ha rätt format innan du läser in ett certifikat i ett NetX-säkert program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="f5a24-600">De vanligaste formaten för certifikat är DER och PEM.</span><span class="sxs-lookup"><span data-stu-id="f5a24-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="f5a24-601">DER (för *Distinguished Encoding Rules* är ett ASN. 1-format) det binära formatet som används av TLS när den första hand skakningen utförs.</span><span class="sxs-lookup"><span data-stu-id="f5a24-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="f5a24-602">PEM (från *Privacy Enhanced mail*) är en base-64-kodad version av der-formatet som är lämplig för e-post eller sändning över http på webben.</span><span class="sxs-lookup"><span data-stu-id="f5a24-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="f5a24-603">Olika leverantörer använder olika fil namns tillägg för certifikat, till exempel ". pem" eller ". CRT" för PEM-certifikat och ". der" för DER-certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="f5a24-604">Om du har ett certifikat och det inte är oklart vilket format som används kan du använda filen i en text redigerare för att fastställa typen eftersom DER-filerna är kodade binära och PEM filer är vanliga ASCII-text som börjar med rubriken "-----BEGIN CERTIFICATe-----".</span><span class="sxs-lookup"><span data-stu-id="f5a24-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="f5a24-605">NetX Secure kräver att ditt certifikat är i binärformat, så du måste konvertera certifikatet till DER-format innan du importerar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="f5a24-606">Detta kan göras med verktyg som är lättillgängligt, till exempel OpenSSL.</span><span class="sxs-lookup"><span data-stu-id="f5a24-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="f5a24-607">Om du behöver en privat nyckel för ditt program kommer nyckel filen att kodas med hjälp av PEM eller DER i ett särskilt format (PKCS # 1 för RSA, RFC 5915 för ECC).</span><span class="sxs-lookup"><span data-stu-id="f5a24-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="f5a24-608">Den privata nyckel filen måste konverteras till DER innan den kan importeras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="f5a24-609">Följande OpenSSL-kommandon anges som ett exempel på konvertering av certifikat och RSA-nyckelfiler till DER-format som krävs av NetX Secure (ECC är liknande – se OpenSSL-dokumentationen).</span><span class="sxs-lookup"><span data-stu-id="f5a24-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="f5a24-610">Privata nycklar och certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-610">Private Keys and Certificates</span></span>

<span data-ttu-id="f5a24-611">För certifikat som identifierar en enhet måste den tillhör ande privata nyckeln läsas in tillsammans med certifikatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="f5a24-612">Den privata nyckeln (som kan vara en av de algoritmer för offentlig nyckel som RSA, Diffie-Hellman eller Elliptic-Curve kryptografi) används av en TLS-server för att dekryptera det inkommande nyckel materialet ("huvud hemlighet") från en TLS-klient och därmed autentisera sig själv för klienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="f5a24-613">Om ett identitets certifikat (ett certifikat med tillhör ande privat nyckel) anges för en TLS-klient och en server begär ett klient certifikat, den privata nyckeln används för att autentisera klienten, om RSA-klienten krypterar en token med hjälp av den privata nyckel som servern dekrypterar med hjälp av klientens offentliga nyckel, som anges i klient certifikatet (Diffie-Hellman och ECC-autentisering sker på liknande sätt, men informationen är lite annorlunda).</span><span class="sxs-lookup"><span data-stu-id="f5a24-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="f5a24-614">I NetX Secure används tjänsten *nx_secure_x509_certificate_initialize* för att initiera ett X. 509-certifikat (se avsnittet "läser in certifikat på enheten" för mer information) och eventuellt associera en privat nyckel med det certifikatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="f5a24-615">Om en privat nyckel anges markeras certifikatet som "identitets certifikat" som används för att identifiera enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="f5a24-616">Nyckeln skickas som en sammanhängande binär blob och en längd med en associerad nyckel typ.</span><span class="sxs-lookup"><span data-stu-id="f5a24-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="f5a24-617">Nyckel typen beror på typen av nyckel (t. ex. RSA, ECC osv.) och formatet (t. ex. PKCS # 1 DER).</span><span class="sxs-lookup"><span data-stu-id="f5a24-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="f5a24-618">Om ingen nyckel anges kan värdet NX_SECURE_X509_KEY_TYPE_NONE (värde 0x0) skickas för att indikera att ingen nyckel anges (en längd på 0 och en NX_NULL-pekare för data parametern kommer att uppnå samma resultat).</span><span class="sxs-lookup"><span data-stu-id="f5a24-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="f5a24-619">I följande tabell visas de nyckel typer som är kända för att NetX säkert och associerad typ identifierare som ska skickas till *nx_secure_x509_certificate_initialize*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="f5a24-620">Ytterligare nyckel typer läggs till som fler krypteringsalgoritmer läggs till i NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="f5a24-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="f5a24-621">Identifierare</span><span class="sxs-lookup"><span data-stu-id="f5a24-621">Identifier</span></span>                              | <span data-ttu-id="f5a24-622">Integritetsalgoritm</span><span class="sxs-lookup"><span data-stu-id="f5a24-622">Algorithm</span></span> | <span data-ttu-id="f5a24-623">Format</span><span class="sxs-lookup"><span data-stu-id="f5a24-623">Format</span></span>   | <span data-ttu-id="f5a24-624">Kodning</span><span class="sxs-lookup"><span data-stu-id="f5a24-624">Encoding</span></span> | <span data-ttu-id="f5a24-625">Värde</span><span class="sxs-lookup"><span data-stu-id="f5a24-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="f5a24-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="f5a24-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="f5a24-627">Inget</span><span class="sxs-lookup"><span data-stu-id="f5a24-627">None</span></span>      | <span data-ttu-id="f5a24-628">Saknas</span><span class="sxs-lookup"><span data-stu-id="f5a24-628">N/A</span></span>      | <span data-ttu-id="f5a24-629">Saknas</span><span class="sxs-lookup"><span data-stu-id="f5a24-629">N/A</span></span>      | <span data-ttu-id="f5a24-630">0x0</span><span class="sxs-lookup"><span data-stu-id="f5a24-630">0x0</span></span>   |
| <span data-ttu-id="f5a24-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="f5a24-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="f5a24-632">RSA</span><span class="sxs-lookup"><span data-stu-id="f5a24-632">RSA</span></span>       | <span data-ttu-id="f5a24-633">PKCS # 1</span><span class="sxs-lookup"><span data-stu-id="f5a24-633">PKCS#1</span></span>   | <span data-ttu-id="f5a24-634">DER</span><span class="sxs-lookup"><span data-stu-id="f5a24-634">DER</span></span>      | <span data-ttu-id="f5a24-635">0x1</span><span class="sxs-lookup"><span data-stu-id="f5a24-635">0x1</span></span>   |
| <span data-ttu-id="f5a24-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="f5a24-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="f5a24-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="f5a24-637">ECDSA</span></span>     | <span data-ttu-id="f5a24-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="f5a24-638">RFC 5915</span></span> | <span data-ttu-id="f5a24-639">DER</span><span class="sxs-lookup"><span data-stu-id="f5a24-639">DER</span></span>      | <span data-ttu-id="f5a24-640">0x2</span><span class="sxs-lookup"><span data-stu-id="f5a24-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="f5a24-641">Användardefinierade privata nyckel typer</span><span class="sxs-lookup"><span data-stu-id="f5a24-641">User-defined private key types</span></span>

<span data-ttu-id="f5a24-642">Värdena för nyckel typs identifierarna för den *nx_secure_x509_certificate_initialize* tjänsten styr de åtgärder som vidtas när den privata nyckeln anges.</span><span class="sxs-lookup"><span data-stu-id="f5a24-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="f5a24-643">För kända typer finns värdena i intervallet 0x0000 0000 – 0x0000 FFFF (nedersta 16 bitarna i ett 32-bitars osignerat heltal).</span><span class="sxs-lookup"><span data-stu-id="f5a24-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="f5a24-644">För plattformar med anpassade nyckel typer<sup>17</sup> (som är fallet för vissa maskinvarubaserade krypterings motorer) kan en användardefinierad nyckel typ i intervallet 0x0000 1000 – 0xffff FFFF (de 16 16 bitarna som inte är noll) skickas som nyckel typ.</span><span class="sxs-lookup"><span data-stu-id="f5a24-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="f5a24-645">Om någon av de översta 16 bitarna i nyckel typen har angetts skickas den privata nyckeln direkt till lämplig kryptografisk rutin (t. ex. RSA) som anges i tabellen TLS-ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="f5a24-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="f5a24-646">Användardefinierade nyckel typer kan inte parsas eller behandlas på annat sätt innan de skickas till den kryptografiska rutinen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="f5a24-647">Dessutom kommer den användardefinierade nyckel typen också att skickas till den kryptografiska rutinen så att lämplig bearbetning kan hanteras på den nivån.</span><span class="sxs-lookup"><span data-stu-id="f5a24-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="f5a24-648">Observera att användardefinierade nyckel typer vanligt vis används för vissa maskinvaruplattformar som använder anpassade (eventuellt krypterade) nyckel data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="f5a24-649">Det innebär vanligt vis att nyckel data genereras eller kodas med hjälp av en mekanism som är unik för den maskin varu leverantören (eller i fallet med en standard som PKCS # 11, en särskild standard).</span><span class="sxs-lookup"><span data-stu-id="f5a24-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="f5a24-650">Mer information finns i dokumentationen för maskin varu plattformen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="f5a24-651">Användardefinierade nyckel typer kräver en motsvarande anpassad kryptografisk rutin för att hantera det anpassade nyckel formatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="f5a24-652">Den kryptografiska rutinen måste ha en matchande algoritm (t. ex. RSA) och skickas till TLS i ciphersuite-tabellen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="f5a24-653">Läser in certifikat på din enhet</span><span class="sxs-lookup"><span data-stu-id="f5a24-653">Loading certificates onto your device</span></span>

<span data-ttu-id="f5a24-654">Alla metoder för att läsa in en fil på enheten räcker till för att importera certifikaten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="f5a24-655">Den enklaste metoden för att läsa in ett certifikat är att konvertera de binära DER-kodade data till en C-matris och kompilera den i programmet som en konstant.</span><span class="sxs-lookup"><span data-stu-id="f5a24-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="f5a24-656">Detta kan enkelt göras med verktyg som "XXD" i Linux (med alternativet "-i").</span><span class="sxs-lookup"><span data-stu-id="f5a24-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="f5a24-657">Alternativt kan du läsa in ditt certifikat i ett Flash-filsystem eller andra lagrings alternativ så länge du kan skicka en pekare till certifikat data till NetX Secure API.</span><span class="sxs-lookup"><span data-stu-id="f5a24-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="f5a24-658">Certifikatfiler som krävs för NetX Secure</span><span class="sxs-lookup"><span data-stu-id="f5a24-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="f5a24-659">De certifikatfiler du behöver importera beror på ditt program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="f5a24-660">I allmänhet kräver TLS-servrar ett certifikat för att identifiera enheten, och TLS-klienter kräver ett eller flera *betrodda certifikat* för att autentisera fjärrservrar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="f5a24-661">Följande tabell visar de certifikat som krävs för vissa olika TLS-program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="f5a24-662">**TLS-funktioner/alternativ**</span><span class="sxs-lookup"><span data-stu-id="f5a24-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="f5a24-663">**Certifikat/nycklar som krävs (minimum)**</span><span class="sxs-lookup"><span data-stu-id="f5a24-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="f5a24-664">TLS-klient</span><span class="sxs-lookup"><span data-stu-id="f5a24-664">TLS Client</span></span>                                        | <span data-ttu-id="f5a24-665">Rot certifikat utfärdarens certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="f5a24-666">TLS-server</span><span class="sxs-lookup"><span data-stu-id="f5a24-666">TLS Server</span></span>                                        | <span data-ttu-id="f5a24-667">Lokalt certifikat, privat nyckel för certifikatet</span><span class="sxs-lookup"><span data-stu-id="f5a24-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="f5a24-668">TLS-server med autentisering av klient certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="f5a24-669">Lokalt certifikat, privat nyckel, rot certifikat utfärdare</span><span class="sxs-lookup"><span data-stu-id="f5a24-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="f5a24-670">TLS-klient med autentisering av klient certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="f5a24-671">Lokalt certifikat, privat nyckel, rot certifikat utfärdare</span><span class="sxs-lookup"><span data-stu-id="f5a24-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="f5a24-672">TLS-klient eller server med i förväg delade nycklar</span><span class="sxs-lookup"><span data-stu-id="f5a24-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="f5a24-673">Ingen (PSK används i stället för certifikat)</span><span class="sxs-lookup"><span data-stu-id="f5a24-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="f5a24-674">De relevanta tjänsterna för inläsning av certifikat är följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="f5a24-675">**API-namn**</span><span class="sxs-lookup"><span data-stu-id="f5a24-675">**API Name**</span></span>                                   | <span data-ttu-id="f5a24-676">**Syfte**</span><span class="sxs-lookup"><span data-stu-id="f5a24-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="f5a24-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="f5a24-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="f5a24-678">Måste anropas för att alla certifikat ska fylla NX_SECURE_X509_CERTs strukturen med dina certifikat data och privata nycklar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="f5a24-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="f5a24-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="f5a24-680">Lägg till ett lokalt certifikat till en TLS-session för att identifiera enheten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="f5a24-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="f5a24-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="f5a24-682">Ta bort ett lokalt certifikat från en TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="f5a24-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="f5a24-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="f5a24-684">Allokera utrymme för ett fjärrcertifikat (anropas med en oinitierad NX_SECURE_X509_CERT).</span><span class="sxs-lookup"><span data-stu-id="f5a24-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="f5a24-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="f5a24-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="f5a24-686">Lägg till ett certifikat i en TLS-session som ett betrott certifikat för autentisering av fjärranslutna värdar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="f5a24-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="f5a24-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="f5a24-688">Ta bort ett betrott certifikat från en TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="f5a24-689">Arbeta med AWS IoT-certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="f5a24-690">I Amazon Web Services IoT-gränssnittet väljer du "säkerhet" på menyn i sido menyn och väljer "certifikat".</span><span class="sxs-lookup"><span data-stu-id="f5a24-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="f5a24-691">Skapa ett nytt certifikat och följ anvisningarna för att hämta det nya enhets certifikatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="f5a24-692">När du har hämtat dina certifikat måste du konvertera dem till DER-format med hjälp av OpenSSL eller ett liknande verktyg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="f5a24-693">Obs: AWS kommer också att tillhandahålla en offentlig nyckel fil.</span><span class="sxs-lookup"><span data-stu-id="f5a24-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="f5a24-694">Den offentliga nyckeln finns i det lokala enhets certifikatet så att den inte behöver importeras till ditt program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="f5a24-695">Till exempel är följande kommandon för att konvertera det lokala enhets certifikatet och dess privata nyckel till DER-format för användning med NetX Secure:</span><span class="sxs-lookup"><span data-stu-id="f5a24-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="f5a24-696">De konverterade filerna kan importeras till ditt program enligt ovanstående instruktioner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="f5a24-697">Verifiering av X. 509-certifikat i NetX Secure</span><span class="sxs-lookup"><span data-stu-id="f5a24-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="f5a24-698">När du använder TLS med X. 509-certifikat för värd identifiering och verifiering, är det viktigt att förstå hur dessa certifikat verkligen verifieras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="f5a24-699">TLS-specifikationen ger inte detaljerade instruktioner om hur du verifierar ett certifikat, det refererar till X. 509-specifikationen (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="f5a24-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="f5a24-700">I allmänhet förväntas det att TLS utför minst grundläggande verifiering av inkommande certifikat (de certifikat som tillhandahålls av fjärrvärden under TLS-handskakning) och NetX Secure TLS inte är något annat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="f5a24-701">Basic X. 509-validering</span><span class="sxs-lookup"><span data-stu-id="f5a24-701">Basic X.509 Validation</span></span>

<span data-ttu-id="f5a24-702">För alla inkommande certifikat utför NetX Secure TLS Basic X. 509-sökväg validering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="f5a24-703">Processen omfattar att kontrol lera varje certifikats digitala signatur mot utfärdarens certifikat, som kan tillhandahållas av fjärrvärden eller finnas i det betrodda certifikat arkivet (se avsnittet "Importera X. 509-certifikat till NetX Secure" för mer information om att importera betrodda certifikat).</span><span class="sxs-lookup"><span data-stu-id="f5a24-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="f5a24-704">Validerings processen upprepas rekursivt i utfärdarens certifikat tills ett betrott certifikat nås eller kedjan slutar (med ett självsignerat certifikat eller ett utfärdarcertifikat som saknas).</span><span class="sxs-lookup"><span data-stu-id="f5a24-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="f5a24-705">Om ett betrott certifikat nås, verifieras certifikatet, annars avvisas det.</span><span class="sxs-lookup"><span data-stu-id="f5a24-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="f5a24-706">Dessutom kontrol leras förfallo datumet för varje certifikat i varje steg i verifierings processen mot den tid som anges av funktionen för tidsstämpeln (se tjänsten "nx_secure_tls_session_time_function_set" för mer information).</span><span class="sxs-lookup"><span data-stu-id="f5a24-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="f5a24-707">509-specifikationen X. innehåller också en algoritm för stöd för "policies", som är identifierare som finns i ett X. 509-tillägg som kan kontrol leras under verifiering av Sök vägar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="f5a24-708">NetX säker behandlar för närvarande X. 509-certifikat som om alternativet "anyPolicy" är definierat – det vill säga att alla principer är acceptabla och att den valfria princip kontrollen inte utförs.</span><span class="sxs-lookup"><span data-stu-id="f5a24-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="f5a24-709">Implementeringen NetX Secure X. 509 kan utökas med den här funktionen i en framtida version.</span><span class="sxs-lookup"><span data-stu-id="f5a24-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="f5a24-710">För närvarande kan princip tillägget hämtas från ett certifikat med hjälp av *nx_secure_x509_extension_find* -API: et.</span><span class="sxs-lookup"><span data-stu-id="f5a24-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="f5a24-711">När den grundläggande Sök vägs valideringen är klar anropar TLS certifikat verifieringens återanrop som tillhandahålls av programmet med hjälp av *nx_secure_tls_session_certificate_callback_set* -API: et.</span><span class="sxs-lookup"><span data-stu-id="f5a24-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="f5a24-712">Om inget motanrop anges anses certifikatet vara betrott efter verifiering av lyckade sökvägar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="f5a24-713">Om ett motanrop anges utför motringningen ytterligare verifiering av det certifikat som krävs av programmet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="f5a24-714">Returvärdet från motringningen används för att avgöra om du vill fortsätta med TLS-handskakning eller om du vill avbryta hand skakningen på grund av ett verifierings problem.</span><span class="sxs-lookup"><span data-stu-id="f5a24-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="f5a24-715">Återanropet anropas med en pekare till den relevanta TLS-sessionen och en NX_SECURE_X509_CERT pekare till certifikatet som ska verifieras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="f5a24-716">Mellan TLS-sessionen och certifikatet har programmet alla data som krävs från TLS för att utföra ytterligare verifierings kontroller.</span><span class="sxs-lookup"><span data-stu-id="f5a24-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="f5a24-717">För att få hjälp med den ytterligare verifieringen ger NetX Secure X. 509-rutiner för några vanliga verifierings åtgärder, inklusive kontroll av DNS-validering och lista över återkallade certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="f5a24-718">Alla dessa rutiner är lämpliga för användning i återanrop av certifikat verifiering, men kan också användas för att utföra inaktive ring av X. 509-certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="f5a24-719">I följande tabell sammanfattas de tillgängliga hjälp funktionerna för certifikat bearbetning av X. 509.</span><span class="sxs-lookup"><span data-stu-id="f5a24-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="f5a24-720">Mer detaljerade förklaringar för åtgärderna finns i följande avsnitt och API-referensen i kapitel 4</span><span class="sxs-lookup"><span data-stu-id="f5a24-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="f5a24-721">Beskrivning av NetX Secure Services ger ytterligare information om de olika rutinerna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="f5a24-722">**API-namn**</span><span class="sxs-lookup"><span data-stu-id="f5a24-722">**API Name**</span></span>                             | <span data-ttu-id="f5a24-723">**Beskrivning**</span><span class="sxs-lookup"><span data-stu-id="f5a24-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="f5a24-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="f5a24-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="f5a24-725">Kontrol lera namnet på det unika ämnes namnet för X. 509 och SubjectAltName mot ett förväntat DNS-namn</span><span class="sxs-lookup"><span data-stu-id="f5a24-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="f5a24-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="f5a24-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="f5a24-727">Sök efter ett återkallat certifikat i en X. 509 lista över återkallade certifikat (CRL)</span><span class="sxs-lookup"><span data-stu-id="f5a24-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="f5a24-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="f5a24-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="f5a24-729">Parsa och hitta en viss utökad nyckel användning OID i ett certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="f5a24-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="f5a24-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="f5a24-731">Parsa och returnera bitfield för nyckel användning i ett certifikat</span><span class="sxs-lookup"><span data-stu-id="f5a24-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="f5a24-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="f5a24-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="f5a24-733">Hitta och returnera RAW DER-kodade ASN. 1-data för ett särskilt tillägg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="f5a24-734">X. 509 Helper-funktioner för användning i återanrop för certifikat verifiering</span><span class="sxs-lookup"><span data-stu-id="f5a24-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="f5a24-735">X. 509-tillägg</span><span class="sxs-lookup"><span data-stu-id="f5a24-735">X.509 Extensions</span></span>

<span data-ttu-id="f5a24-736">I specifikationen X. 509 beskrivs ett antal "tillägg" som kan användas för att tillhandahålla ytterligare information som kan användas vid verifiering av certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="f5a24-737">Dessa tillägg är valfria och behövs inte för säker verifiering av ett digitalt certifikat mot ett betrott rot certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="f5a24-738">NetX Secure stöder dock vissa grundläggande tillägg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="f5a24-739">Stöd för ytterligare tillägg kan läggas till i framtida versioner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="f5a24-740">De tillägg som stöds för närvarande visas i följande tabell:</span><span class="sxs-lookup"><span data-stu-id="f5a24-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="f5a24-741">Tilläggs namn</span><span class="sxs-lookup"><span data-stu-id="f5a24-741">Extension Name</span></span>           | <span data-ttu-id="f5a24-742">Beskrivning</span><span class="sxs-lookup"><span data-stu-id="f5a24-742">Description</span></span>                                                                   | <span data-ttu-id="f5a24-743">Relevant API</span><span class="sxs-lookup"><span data-stu-id="f5a24-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="f5a24-744">Nyckelanvändning</span><span class="sxs-lookup"><span data-stu-id="f5a24-744">Key Usage</span></span>                | <span data-ttu-id="f5a24-745">Ger acceptabel användning för certifikatets offentliga nyckel i en bitfield</span><span class="sxs-lookup"><span data-stu-id="f5a24-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="f5a24-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="f5a24-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="f5a24-747">Utökad nyckelanvändning</span><span class="sxs-lookup"><span data-stu-id="f5a24-747">Extended Key Usage</span></span>       | <span data-ttu-id="f5a24-748">Ger ytterligare acceptabel användning för certifikatets offentliga nyckel med hjälp av OID</span><span class="sxs-lookup"><span data-stu-id="f5a24-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="f5a24-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="f5a24-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="f5a24-750">Alternativt namn för certifikatmottagare</span><span class="sxs-lookup"><span data-stu-id="f5a24-750">Subject Alternative Name</span></span> | <span data-ttu-id="f5a24-751">Innehåller alternativa DNS-namn som också representeras av certifikatet</span><span class="sxs-lookup"><span data-stu-id="f5a24-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="f5a24-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="f5a24-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="f5a24-753">X. 509-tillägg som inte stöds</span><span class="sxs-lookup"><span data-stu-id="f5a24-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="f5a24-754">NetX Secure ' X. 509 implemenation tillhandahåller en tjänst för att extrahera tillägg som inte stöds: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="f5a24-755">Detta API är avsett för avancerade användare eftersom det kräver kunskap om DER-kodad ASN. 1 för att parsa de data som returneras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="f5a24-756">Den används internt för att extrahera stödda tillägg men tillhandahålls för att under lätta utveckling av anpassat stöd för X. 509-tillägg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="f5a24-757">Om du vill använda nx_secure_x509_extension_find skickas en NX_SECURE_X509_EXTENSION, tillsammans med certifikatet och ett tilläggs-ID, som är en heltals representation av OID-strängen med variabel längd för en känd tilläggs typ.</span><span class="sxs-lookup"><span data-stu-id="f5a24-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="f5a24-758">En fullständig lista över OID för X. 509-tillägg som stöds finns i API-referensen för nx_secure_x509_extension_find på sidan 178.</span><span class="sxs-lookup"><span data-stu-id="f5a24-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="f5a24-759">NX_SECURE_X509_EXTENSIONs strukturen definieras enligt följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="f5a24-760">När tjänsten återställs, fylls strukturen med relevanta data från certifikatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="f5a24-761">Fältet nx_secure_x509_extension_id används vanligt vis för internt bruk, men kommer att fyllas i med relevant heltals representation för OID.</span><span class="sxs-lookup"><span data-stu-id="f5a24-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="f5a24-762">Fältet nx_secure_x509_extension_critical visar det kritiska värdet för X. 509-kritiskt tillägg (Boolean).</span><span class="sxs-lookup"><span data-stu-id="f5a24-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="f5a24-763">Fälten nx_secure_x509_extension_data och nx_secure_x509_extension_data_length innehåller en pekare till de DER-kodade ASN. 1-data för tillägget och längden på dessa data.</span><span class="sxs-lookup"><span data-stu-id="f5a24-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="f5a24-764">Den faktiska parsningen av tilläggets ASN. 1-data ligger utanför det här dokumentets omfång, men om du har åtkomst till NetX Secure TLS-källan kan du se hur parsningen utförs där nx_secure_x509_extension_find anropas för tillägg som stöds.</span><span class="sxs-lookup"><span data-stu-id="f5a24-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="f5a24-765">DNS-validering för X. 509</span><span class="sxs-lookup"><span data-stu-id="f5a24-765">X.509 DNS Validation</span></span>

<span data-ttu-id="f5a24-766">En vanlig certifikat validerings åtgärd i TLS förutsätter att du kontrollerar Top-Level domän namn (topp) för en fjärrvärd mot X. 509-certifikatet som tillhandahålls av värden under TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="f5a24-767">Den här åtgärden hjälper till att säkerställa att certifikatet verkligen matchar den värd server som tillhandahöll det, förutsatt att DNS-sökningen kan vara betrodd.</span><span class="sxs-lookup"><span data-stu-id="f5a24-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="f5a24-768">I NetX Secure TLS tillhandahålls den här funktionen av tjänsten **nx_secure_x509_common_name_dns_check**, som tar certifikatet och en sträng som innehåller topp delen av den URL som används för att få åtkomst till värden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="f5a24-769">Topp domänen jämförs med certifikatets eget namn-fält och om det matchar, returneras NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="f5a24-770">Om det egna namnet inte matchar, kontrollerar rutinen även om det finns en *subjectAltName* för certifikat tillägg för X. 509.</span><span class="sxs-lookup"><span data-stu-id="f5a24-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="f5a24-771">Om det finns en subjectAltName, kontrol leras även eventuella DNSName-poster i tillägget mot den angivna topp domänen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="f5a24-772">Om det finns en matchning returneras NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="f5a24-773">Om ingen matchning hittas returneras ett fel som lämpar sig för att returnera från återanropet för certifikat verifiering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="f5a24-774">X. 509 nyckel användning och tillägg för utökad nyckel användning</span><span class="sxs-lookup"><span data-stu-id="f5a24-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="f5a24-775">Nyckel användningen för X. 509 och utökade nyckel användnings tillägg ger information om hur ett certifikats offentliga nyckel kan användas när certifikatet autentiseras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="f5a24-776">Nyckel användningen anges av certifikat utfärdaren när certifikatet signeras och utfärdas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="f5a24-777">Nyckel användningen kan användas av en TLS-värd för att kontrol lera att certifikatet har behörighet att användas för att autentisera en fjärran sluten TLS-värd och utföra andra åtgärder.</span><span class="sxs-lookup"><span data-stu-id="f5a24-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="f5a24-778">Tillägget för nyckel användning består av en enkel bitfield där varje BITS representerar en speciell nyckel användning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="f5a24-779">En fullständig lista över dessa värden finns i API-referensen för *nx_secure_x509_key_usage_extension_parse* på sidan 183.</span><span class="sxs-lookup"><span data-stu-id="f5a24-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="f5a24-780">En mer fullständig beskrivning av nyckel användnings bitarna och deras betydelser finns i RFC 5280, section 4.2.1.3.</span><span class="sxs-lookup"><span data-stu-id="f5a24-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="f5a24-781">Tillägget för utökad nyckel användning, t. ex. tillägg för nyckel användning, innehåller en acceptabel nyckel användnings information.</span><span class="sxs-lookup"><span data-stu-id="f5a24-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="f5a24-782">För att kunna stödja godtycklig användning används OID i stället för en bitfield i tillägget för utökad nyckel användning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="f5a24-783">Vid parsning av ett tillägg för utökad nyckel användning i NetX Secure X. 509, anges ett heltal som representerar OID av programmet – *nx_secure_x509_extended_key_usage_extension_parse* tjänsten kommer sedan att returnera om OID finns.</span><span class="sxs-lookup"><span data-stu-id="f5a24-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="f5a24-784">En fullständig lista över OID-objekt som stöds för utökad nyckel användning finns i API-referensen för *nx_secure_x509_extended_key_usage_extension_parse* på sidan 175.</span><span class="sxs-lookup"><span data-stu-id="f5a24-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="f5a24-785">En mer fullständig beskrivning av OID och deras betydelser finns i RFC 5280, section 4.2.1.12.</span><span class="sxs-lookup"><span data-stu-id="f5a24-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="f5a24-786">Kontroll av status för återkallade certifikat för X. 509</span><span class="sxs-lookup"><span data-stu-id="f5a24-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="f5a24-787">X. 509 innehåller en mekanism som kallas CRL ( *Certificate Revocation List* ) som tillåter en digital certifikat signerings auktoritet att återkalla giltigheten för certifikat som den har signerat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="f5a24-788">Alla program som behöver verifiera certifikat från en signerings utfärdare kan hämta en lista över återkallade certifikat och jämföra alla certifikat som har signerats av den här utfärdaren (utfärdare) mot CRL: n för att se om deras status har återkallats av någon anledning (till exempel komprometterad privat nyckel).</span><span class="sxs-lookup"><span data-stu-id="f5a24-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="f5a24-789">På så sätt kan programmet undvika att använda potentiellt farliga certifikat som skickar andra verifierings kontroller för certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="f5a24-790">Hämtning av en CRL görs av ett program genom att hämta den DER-kodade listan från en fördefinierad Server eller på något annat sätt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="f5a24-791">Den faktiska installationen varierar från utfärdaren till utfärdaren så att NetX säker inte tillhandahåller en mekanism för att hämta CRL: er, men det ger en rutin för att kontrol lera ett certifikat mot en CRL, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="f5a24-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="f5a24-792">API: et tar en DER-kodad CRL, ett certifikat arkiv (till exempel en i en TLS-session) att kontrol lera mot och det certifikat som ska kontrol leras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="f5a24-793">Rutinen validerar först själva listan över återkallade certifikat mot det betrodda arkivet (en del av det certifikat arkiv som tillhandahålls av programmet).</span><span class="sxs-lookup"><span data-stu-id="f5a24-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="f5a24-794">Detta är viktigt för att skydda mot bedrägliga listor över återkallade certifikat som används för DOS-attacker (Denial-of-Service) och upprättar att listan verkligen kommer från rätt utfärdare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="f5a24-795">Efter CRL-verifieringen kontrol leras utfärdaren – om utfärdaren av listan över återkallade certifikat inte matchar certifikat utfärdarens CRL, är CRL: en inte giltig för certifikatet och ett fel returneras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="f5a24-796">Det är upp till programmet att avgöra om TLS-handskakningen kan fortsätta nu.</span><span class="sxs-lookup"><span data-stu-id="f5a24-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="f5a24-797">Om utfärdarna matchar varandra genomsöks CRL: en efter serie numret för det certifikat som verifieras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="f5a24-798">Om serie numret finns i listan returneras ett fel som indikerar att certifikatet har återkallats.</span><span class="sxs-lookup"><span data-stu-id="f5a24-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="f5a24-799">Om ingen matchning hittas returneras NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="f5a24-800">Autentisering av klient certifikat i NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="f5a24-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="f5a24-801">När du använder autentisering med X. 509-certifikat kräver TLS-protokollet att TLS-serverinstansen tillhandahåller ett certifikat för identifiering, men som standard behöver TLS-klientcertifikatet inte tillhandahålla ett certifikat för autentisering med hjälp av en annan form av autentisering i stället (t. ex. en kombination av användar namn/lösen ord).</span><span class="sxs-lookup"><span data-stu-id="f5a24-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="f5a24-802">Detta matchar den vanligaste användningen av TLS på Internet för webbplatser.</span><span class="sxs-lookup"><span data-stu-id="f5a24-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="f5a24-803">Till exempel måste en detaljist webbplats bevisa för en potentiell kund som använder en webbläsare som servern är legitim, men användaren använder ett inloggnings-/lösen ord för att få åtkomst till ett speciellt konto.</span><span class="sxs-lookup"><span data-stu-id="f5a24-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="f5a24-804">Standard fallet är dock inte alltid önskvärt, så TLS kan alternativt tillåta att TLS-serverinstansen begär ett certifikat från fjärrklienten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="f5a24-805">När den här funktionen är aktive rad kommer TLS-servern att skicka ett CertificateRequest-meddelande till TLS-klienten under hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="f5a24-806">Klienten måste svara med ett eget certifikat och ett CertificateVerify-meddelande som innehåller en kryptografisk token som styrker att klienten äger den matchande privata nyckeln som är kopplad till certifikatet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="f5a24-807">Om verifieringen Miss lyckas eller om certifikatet inte är anslutet till ett betrott certifikat på servern Miss lyckas TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="f5a24-808">Det finns två separata fall för autentisering av klient certifikat i TLS – följande avsnitt beskriver båda fallen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="f5a24-809">Autentisering av klient certifikat för TLS-klienter</span><span class="sxs-lookup"><span data-stu-id="f5a24-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="f5a24-810">En TLS-klient kan försöka ansluta till en server som begär ett certifikat för klientautentisering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="f5a24-811">I det här fallet måste klienten ange ett certifikat för servern och kontrol lera att den äger den matchande privata nyckeln eller att servern avslutar TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="f5a24-812">I NetX Secure TLS finns det ingen särskild konfiguration som stöder den här funktionen, men programmet måste ange ett lokalt identifierings certifikat för TLS-klientcertifikatet med hjälp av tjänsten *nx_secure_tls_local_certificate_add* .</span><span class="sxs-lookup"><span data-stu-id="f5a24-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="f5a24-813">Om inget certifikat tillhandahålls av programmet men fjärrservern använder autentisering av klient certifikat och begär ett certifikat, kommer TLS-handskakningen att Miss läge.</span><span class="sxs-lookup"><span data-stu-id="f5a24-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="f5a24-814">Det certifikat som angavs för TLS-sessionen med *nx_secure_tls_local_certificate_add* måste identifieras av fjärrservern för att du ska kunna slutföra TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="f5a24-815">Autentisering av klient certifikat för TLS-servrar</span><span class="sxs-lookup"><span data-stu-id="f5a24-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="f5a24-816">TLS-serverns händelse för autentisering av klient certifikat är något mer komplicerat än TLS-klientens fall på grund av att funktionen är valfri.</span><span class="sxs-lookup"><span data-stu-id="f5a24-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="f5a24-817">I det här fallet måste TLS-servern uttryckligen begära ett certifikat från fjärr-TLS-klienten, sedan bearbeta CertificateVerify-meddelandet för att verifiera att den fjärranslutna klienten äger den matchande privata nyckeln och servern måste kontrol lera att det certifikat som tillhandahålls av klienten kan spåras till ett certifikat i det lokala betrodda certifikat arkivet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="f5a24-818">I NetX Secure TLS Server-instanser styrs klient certifikat autentisering av</span><span class="sxs-lookup"><span data-stu-id="f5a24-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="f5a24-819">*NX <span class="underline"> _</span> säker <span class="underline">_</span>TLS-<span class="underline"> _</span> session <span class="underline">_</span>klienten <span class="underline"> _</span> verifierar <span class="underline">_</span>aktivera* och</span><span class="sxs-lookup"><span data-stu-id="f5a24-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="f5a24-820">*NX <span class="underline"> _</span> Secure <span class="underline">_</span>TLS <span class="underline"> _</span> session <span class="underline">_</span>client <span class="underline"> _</span> Verifiera <span class="underline">_</span>inaktivera* tjänster.</span><span class="sxs-lookup"><span data-stu-id="f5a24-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="f5a24-821">Om du vill aktivera autentisering av klient certifikat måste ett program anropa</span><span class="sxs-lookup"><span data-stu-id="f5a24-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="f5a24-822">*NX <span class="underline"> _</span> säker <span class="underline">_</span>TLS <span class="underline"> _</span> session <span class="underline">_</span>klient <span class="underline"> _</span> verifiera <span class="underline">_</span>aktivera* med TLS-serverinstans innan du anropar *nx_secure_tls_session_start*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="f5a24-823">Observera att anropet till den här tjänsten på en TLS-session som används för TLS-klientanslutningar inte kommer att påverka.</span><span class="sxs-lookup"><span data-stu-id="f5a24-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="f5a24-824">När autentisering av klient certifikat är aktiverat begär TLS-servern ett certifikat från fjärr-TLS-klienten under TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="f5a24-825">I NetX Secure TLS-server kontrol leras klient certifikatet mot arkivet med betrodda certifikat som skapats med *nx <span class="underline"> _</span> secure_tls <span class="underline">_</span>betrodda <span class="underline"> _</span> certifikat <span class="underline">_</span>Lägg till* följande kedja i X. 509-utfärdaren.</span><span class="sxs-lookup"><span data-stu-id="f5a24-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="f5a24-826">Fjärrklienten måste ange en kedja som ansluter sitt identitets certifikat till ett certifikat i det betrodda arkivet eller så Miss känner TLS-handskakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="f5a24-827">Även om bearbetningen av CertificateVerify-meddelanden Miss lyckas kommer TLS-handskakningen att Miss lyckas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="f5a24-828">De autentiseringsmetoder som används för metoden CertificateVerify är fasta för TLS version 1,0 och TLS-version 1,1 och anges av TLS-servern i TLS version 1,2.</span><span class="sxs-lookup"><span data-stu-id="f5a24-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="f5a24-829">Under TLS 1,2 följer de autentiseringsmetoder som stöds vanligt vis de relevanta metoder som anges i tabellen med kryptografiska metoder, men vanligt vis RSA med SHA-256 (se avsnittet "kryptografi i NetX Secure TLS" för mer information om att initiera TLS med kryptografiska metoder).</span><span class="sxs-lookup"><span data-stu-id="f5a24-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="f5a24-830">Kryptografi i NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="f5a24-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="f5a24-831">TLS definierar ett protokoll där kryptografi kan användas för att skydda nätverkskommunikation.</span><span class="sxs-lookup"><span data-stu-id="f5a24-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="f5a24-832">Därför lämnar den den faktiska kryptografin att använda ganska stor öppen för TLS-användare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="f5a24-833">För specifikationen krävs bara att en enda ciphersuite implementeras – i händelse av TLS 1,2 är ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA, vilket indikerar användningen av RSA för offentliga nyckel åtgärder, AES i CBC-läge med 128-bitars nycklar för sessions kryptering och SHA-1 för hash-meddelanden för meddelandeautentisering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="f5a24-834">Som standard är TLS 1,2-kompatibel och den obligatoriska TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite som standard, men med tanke på antalet möjliga implementeringar för var och en av de kryptografiska metoderna på grund av maskin varu funktioner och andra överväganden, är NetX Secure en allmän krypterings-API som gör att en användare kan ange vilka kryptografiska metoder som ska användas med TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="f5a24-835">OBS! den allmänna kryptografiska API-mekanismen gör det också möjligt för användarna att implementera sina egna krypteringssviter, men det rekommenderas för avancerade användare som är bekanta med TLS-krypteringssviter och-tillägg.</span><span class="sxs-lookup"><span data-stu-id="f5a24-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="f5a24-836">Kontakta din uttryckliga Logic-representant om du är intresse rad av att stödja din egen krypteringssviter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="f5a24-837">Kryptografiska metoder</span><span class="sxs-lookup"><span data-stu-id="f5a24-837">Cryptographic Methods</span></span>

<span data-ttu-id="f5a24-838">NetX Secure TLS implementerar DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA och ECC (valda kurvor) i program vara med maskin varu driv rutiner för vissa maskinvaruplattformar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="f5a24-839">Ett program kan använda de kryptografiska rutiner som medföljer NetX Secure, eller använda anpassade rutiner som tillhandahålls av slutanvändaren eller tredje part.</span><span class="sxs-lookup"><span data-stu-id="f5a24-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="f5a24-840">*NX_CRYPTO_METHOD* är ett kontroll block som har utformats för ett program för att beskriva en viss implementering av en kryptografisk algoritm som ska användas med netx Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="f5a24-841">Med *NX_CRYPTO_METHOD* kan ett program enkelt integrera sin egen krypterings implementering i netx Secure.</span><span class="sxs-lookup"><span data-stu-id="f5a24-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="f5a24-842">*NX_CRYPTO_METHODs* strukturen deklareras som:</span><span class="sxs-lookup"><span data-stu-id="f5a24-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="f5a24-843">Nedan visas en beskrivning av varje element i *NX_CRYPTO_METHODs* strukturen:</span><span class="sxs-lookup"><span data-stu-id="f5a24-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="f5a24-844">nx_crypto_algorithm: det här fältet identifierar algoritmen som beskrivs i variabel *metoden* vissa giltiga värden för netx Secure TLS är följande (se nx_crypto_const. h för vissa värden):</span><span class="sxs-lookup"><span data-stu-id="f5a24-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="f5a24-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="f5a24-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="f5a24-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="f5a24-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="f5a24-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="f5a24-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="f5a24-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="f5a24-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="f5a24-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="f5a24-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="f5a24-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="f5a24-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="f5a24-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="f5a24-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="f5a24-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="f5a24-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="f5a24-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="f5a24-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="f5a24-854">nx_crypto_key_size_in_bits: det här fältet anger storleken på den hemliga nyckel som används av metoden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="f5a24-855">nx_crypto_IV_size_in_bits: det här fältet anger storleken på initierings vektorn (IV).</span><span class="sxs-lookup"><span data-stu-id="f5a24-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="f5a24-856">Observera att i de flesta fall används IV-blocket endast för kryptering/dekryptering av algoritmer.</span><span class="sxs-lookup"><span data-stu-id="f5a24-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="f5a24-857">Autentiserings-och verifierings algoritmer använder sällan det här fältet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="f5a24-858">nx_crypto_ICV_size_in_bits: det här fältet anger storleken på INTEGRITETSKONTROLLVÄRDET-blocket (integritets kontroll värde).</span><span class="sxs-lookup"><span data-stu-id="f5a24-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="f5a24-859">Obs! det här blocket används för IPsec-användning och används inte i TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="f5a24-860">Mer information finns i NetX Duo IPsec.</span><span class="sxs-lookup"><span data-stu-id="f5a24-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="f5a24-861">nx_crypto_block_size_in_bytes: det här fältet anger storleken på det kryptografiska krypteringsalgoritm blocket för blockbaserade chiffer i byte.</span><span class="sxs-lookup"><span data-stu-id="f5a24-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="f5a24-862">I de flesta fall används detta av krypterings rutiner och sällan med autentiserings-rutiner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="f5a24-863">nx_crypto_metadata_area_size: det här fältet anger storleken på det metadata-område som metoden kräver.</span><span class="sxs-lookup"><span data-stu-id="f5a24-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="f5a24-864">Varje implementering kan kräva ett visst minne för att lagra tillståndsinformation, eller för att lagra mellanliggande data (t. ex. nyckel omvandlings material) eller använda som arbets yta.</span><span class="sxs-lookup"><span data-stu-id="f5a24-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="f5a24-865">Mängden utrymme som krävs av en implementering anges i det här fältet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="f5a24-866">Programmet tillhandahåller minnes utrymmet när du skapar en TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="f5a24-867">Den kryptografiska funktionen ansvarar för att hantera det här metadata-avsnittet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="f5a24-868">nx_crypto_init: Detta är initierings funktionen för krypteringsalgoritmen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="f5a24-869">För en implementering som inte behöver en initierings rutin, kan det här fältet anges till NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="f5a24-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="f5a24-870">En typisk användning av en initierings funktion är att initiera den interna data strukturen för algoritmen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="f5a24-871">NetX Secure TLS hanterar initiering av den kryptografiska rutinen genom att anropa den här funktionen internt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="f5a24-872">Prototypen för initierings funktionen är:</span><span class="sxs-lookup"><span data-stu-id="f5a24-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="f5a24-873">metoden är en pekare till kontroll blocket för kryptografi metoden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="f5a24-874">Key är den hemliga nyckel strängen för bearbetning av data paketen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="f5a24-875">key_size_in_bits definierar storleken på den hemliga nyckeln i bitar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="f5a24-876">referens är ett implementations-definierat objekt som identifierar en viss kryptografisk session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="f5a24-877">Värdet genereras av initierings rutinen och skickas tillbaka till anroparen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="f5a24-878">Den efterföljande kryptografi åtgärden eller rensa rutinen Använd den här referensen för att identifiera sessionen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="f5a24-879">crypto_metadata är en pekare till metadata-ytan som krävs för den här algoritmens implementering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="f5a24-880">För algoritmer som inte behöver ett område för metadata är det här fältet inställt på NX_NULL och initierings rutinen får inte komma åt området metadata.</span><span class="sxs-lookup"><span data-stu-id="f5a24-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="f5a24-881">crypto_metadata_size anger storleken på metadata-ytan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="f5a24-882">För SAs som skapats utan området metadata är det här fältet inställt på noll och initierings rutinen får inte komma åt området metadata.</span><span class="sxs-lookup"><span data-stu-id="f5a24-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="f5a24-883">Den här rutinen ska returnera *NX_SUCCESS* om initierings processen lyckas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="f5a24-884">Anroparen behandlar andra retur värden som felaktiga.</span><span class="sxs-lookup"><span data-stu-id="f5a24-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="f5a24-885">nx_crypto_cleanup: det här är den rensnings rutin som definierats för implementeringen av en krypteringsalgoritm.</span><span class="sxs-lookup"><span data-stu-id="f5a24-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="f5a24-886">Den anropas när en TLS-session tas bort eller startas om.</span><span class="sxs-lookup"><span data-stu-id="f5a24-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="f5a24-887">Prototypen för rensnings funktionen är:</span><span class="sxs-lookup"><span data-stu-id="f5a24-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="f5a24-888">referensen skickas till rensnings funktionen av anroparen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="f5a24-889">Referensen initieras av initierings rutinen för kryptografi och används för att identifiera tillstånd för kryptografisk algoritm.</span><span class="sxs-lookup"><span data-stu-id="f5a24-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="f5a24-890">Den här rutinen ska returnera *NX_SUCCESS* om rensnings processen lyckas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="f5a24-891">Anroparen behandlar andra retur värden som felaktiga.</span><span class="sxs-lookup"><span data-stu-id="f5a24-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="f5a24-892">nx_crypto_operation: det här är den rutin som utför den faktiska krypterings-, dekrypterings-och Autentiseringstjänsten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="f5a24-893">Funktions prototypen för åtgärds rutinen är:</span><span class="sxs-lookup"><span data-stu-id="f5a24-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="f5a24-894">OP anger vilken typ av åtgärd som denna rutin förväntas utföra. Giltiga värden är:</span><span class="sxs-lookup"><span data-stu-id="f5a24-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="f5a24-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="f5a24-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="f5a24-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="f5a24-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="f5a24-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="f5a24-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="f5a24-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="f5a24-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="f5a24-899">referensen skickas till funktions funktionen av anroparen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="f5a24-900">Den genereras av rutinen för kryptografisk initiering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="f5a24-901">metoden pekar på krypterings metodens kontroll block</span><span class="sxs-lookup"><span data-stu-id="f5a24-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="f5a24-902">nycklar pekar på den hemliga nyckel som används för den här åtgärden</span><span class="sxs-lookup"><span data-stu-id="f5a24-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="f5a24-903">key_size_in_bits är storleken på den hemliga nyckeln i bitar</span><span class="sxs-lookup"><span data-stu-id="f5a24-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="f5a24-904">indatamängden är en pekare till början av meddelandet som ska användas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="f5a24-905">input_length_in_byte skickas av anroparen för att indikera storleken på det meddelande som ska användas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="f5a24-906">iv_ptr konfigureras av anroparen så att den pekar mot början av ett IV-block.</span><span class="sxs-lookup"><span data-stu-id="f5a24-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="f5a24-907">Observera att minnet för IV-blocket tillhandahålls av anroparen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="f5a24-908">För kryptering ska funktionen funktion skriva IV-information till det här minnes blocket. för dekryptering ska funktionen funktion hämta IV-informationen från det här minnes blocket.</span><span class="sxs-lookup"><span data-stu-id="f5a24-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="f5a24-909">Algoritmer för autentiserings-och verifierings åtgärder använder vanligt vis inte initierings vektorn.</span><span class="sxs-lookup"><span data-stu-id="f5a24-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="f5a24-910">utdata installeras av anroparen för att peka på en utdatabuffert.</span><span class="sxs-lookup"><span data-stu-id="f5a24-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="f5a24-911">Observera att minnet för utdatabufferten tillhandahålls av anroparen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="f5a24-912">För kryptering ska funktionen funktion skriva cipher-texten till utdatabufferten. vid dekryptering ska åtgärden skriva den dechiffrerade texten (klartext) till utdatabufferten. för autentiseringen ska hash-värdet skrivas till utdatabufferten.</span><span class="sxs-lookup"><span data-stu-id="f5a24-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="f5a24-913">För verifiering används utdatabufferten för att lagra hash-information.</span><span class="sxs-lookup"><span data-stu-id="f5a24-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="f5a24-914">output_length_in_byte anger storleken på utdatabufferten</span><span class="sxs-lookup"><span data-stu-id="f5a24-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="f5a24-915">crypto_metadata pekar på det metadata-fält som ska användas av den här kryptografi åtgärden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="f5a24-916">Avsnittet för krypto-metadata initieras vanligt vis av crypto_init_function.</span><span class="sxs-lookup"><span data-stu-id="f5a24-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="f5a24-917">crypto_metadata_size anger storleken på metadata-ytan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="f5a24-918">Den här rutinen ska returnera *NX_SUCCESS* om åtgärds processen lyckas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="f5a24-919">Anroparen behandlar andra retur värden som felaktiga.</span><span class="sxs-lookup"><span data-stu-id="f5a24-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="f5a24-920">packet_ptr: det paket som innehåller de data som bearbetas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="f5a24-921">OBS! den här parametern används inte av TLS och ska vara inställd på NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="f5a24-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="f5a24-922">nx_crypto_hw_process_callback: en callback-funktion som tillhandahålls av krypterings metoden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="f5a24-923">Detta används om funktionen för kryptering tillhandahålls av maskin vara och kräver en callback-rutin.</span><span class="sxs-lookup"><span data-stu-id="f5a24-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="f5a24-924">NetX Secure TLS tillhandahåller följande krypterings metoder:</span><span class="sxs-lookup"><span data-stu-id="f5a24-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="f5a24-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="f5a24-925">*AES*</span></span>  
- <span data-ttu-id="f5a24-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="f5a24-926">*RSA*</span></span>  
- <span data-ttu-id="f5a24-927">*HA*</span><span class="sxs-lookup"><span data-stu-id="f5a24-927">*NULL*</span></span>

<span data-ttu-id="f5a24-928">NetX Secure TLS tillhandahåller följande autentiseringsmetoder:</span><span class="sxs-lookup"><span data-stu-id="f5a24-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="f5a24-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="f5a24-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="f5a24-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="f5a24-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="f5a24-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="f5a24-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="f5a24-932">I följande exempel visas hur du konfigurerar *NX_CRYPTO_METHOD* -strukturen så att den använder de krypterings-och autentiseringsmetoder som tillhandahålls av netx Duo IPSec.</span><span class="sxs-lookup"><span data-stu-id="f5a24-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="f5a24-933">***AES***</span><span class="sxs-lookup"><span data-stu-id="f5a24-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="f5a24-934">***HA***</span><span class="sxs-lookup"><span data-stu-id="f5a24-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="f5a24-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="f5a24-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="f5a24-936">***ALTERNATIVET***</span><span class="sxs-lookup"><span data-stu-id="f5a24-936">***NONE***</span></span>

<span data-ttu-id="f5a24-937">En särskild metod **NX_CRYPTO_NONE** används för att signalera IPSec-modulen som krypteringen eller Autentiseringstjänsten inte kräver.</span><span class="sxs-lookup"><span data-stu-id="f5a24-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="f5a24-938">Den konfigureras på följande sätt:</span><span class="sxs-lookup"><span data-stu-id="f5a24-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="f5a24-939">Initiera TLS med kryptografiska metoder</span><span class="sxs-lookup"><span data-stu-id="f5a24-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="f5a24-940">När du har skapat dina kryptografiska rutiner som följer de signaturer för kryptografiska metoder som beskrivs i föregående avsnitt måste du skicka dem till TLS när du initierar ett NX_SECURE_TLS_SESSION kontroll block.</span><span class="sxs-lookup"><span data-stu-id="f5a24-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="f5a24-941">Detta görs i TLS-tjänsten nx_secure_tls_session_create:</span><span class="sxs-lookup"><span data-stu-id="f5a24-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="f5a24-942">session_pointer är en pekare till NX_SECURE_TLS_SESSION kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="f5a24-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="f5a24-943">tls_cipher_table är en pekare till ett NX_SECURE_TLS_CRYPTO kontroll block som beskrivs nedan.</span><span class="sxs-lookup"><span data-stu-id="f5a24-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="f5a24-944">encryption_metadata_area pekar på utrymme som används av kryptografiska rutiner i TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="f5a24-945">encryption_metadata_size är storleken på metadata-ytan i byte.</span><span class="sxs-lookup"><span data-stu-id="f5a24-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="f5a24-946">Elliptic Curve Cryptography (ECC) i NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="f5a24-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="f5a24-947">Elliptic Curve Cryptography (ECC) tillhandahåller ett krypterings schema med offentliga nycklar som kan användas i stället för RSA.</span><span class="sxs-lookup"><span data-stu-id="f5a24-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="f5a24-948">ECC är normalt snabbare och använder mindre nycklar än RSA, så det kan vara ett värdefullt alternativ för inbäddad TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="f5a24-949">I X-version-versioner före Azure återställnings tider 6,0 levererades ECC som ett tillägg, vilket kräver att ECC-källkoden installeras i projektet.</span><span class="sxs-lookup"><span data-stu-id="f5a24-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="f5a24-950">Azure återställnings tider 6,0 integrerad ECC i Mainline-kodbasen så det är inte längre nödvändigt att installera ECC-filerna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="f5a24-951">ECC kräver dock fortfarande samma initiering som tidigare versioner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="f5a24-952">ECC-kurvor som stöds</span><span class="sxs-lookup"><span data-stu-id="f5a24-952">Supported ECC curves</span></span>

<span data-ttu-id="f5a24-953">NetX säkra implementerar delar av kurvorna enligt <http://www.secg.org/sec2-v2.pdf> .</span><span class="sxs-lookup"><span data-stu-id="f5a24-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="f5a24-954">Thefollowing-kurvor stöds<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="f5a24-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="f5a24-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="f5a24-955">secp256r1</span></span> 
  - <span data-ttu-id="f5a24-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="f5a24-956">secp384r1</span></span> 
  - <span data-ttu-id="f5a24-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="f5a24-957">secp521r1</span></span> 

<span data-ttu-id="f5a24-958">Om andra ECC-kurvor används returnerar rutinen *nx_secure_tls_session_start ()* fel NX_SECURE_TLS_NO_SUPPORTED_CIPHERS som anger att kurvor som inte stöds användes.</span><span class="sxs-lookup"><span data-stu-id="f5a24-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="f5a24-959">Observera att TLS-certifikat kedjan även kan krypteras av ECC-algoritmer.</span><span class="sxs-lookup"><span data-stu-id="f5a24-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="f5a24-960">Även om de kurvor som tillhandahålls av TLS-klienten stöds, är det möjligt att ECC-kurvan som används i certifikat kedjan inte stöds.</span><span class="sxs-lookup"><span data-stu-id="f5a24-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="f5a24-961">I det här fallet returnerar *nx_secure_tls_session_start* rutinen NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span><span class="sxs-lookup"><span data-stu-id="f5a24-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="f5a24-962">Ett standard tabell exempel för ciphersuite för ECC finns i nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="f5a24-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="f5a24-963">Se avsnittet "TLS Cryptographic chiffer Table" för mer information om ciphersuite-tabeller.</span><span class="sxs-lookup"><span data-stu-id="f5a24-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="f5a24-964">Observera att implementeringar för de secp192r1 och secp224r1are som också finns för äldre program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="f5a24-965">Dessa kurvor betraktas dock som svaga och bör inte användas för utveckling av nya program.</span><span class="sxs-lookup"><span data-stu-id="f5a24-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="f5a24-966">Krypterings metoder för ECC</span><span class="sxs-lookup"><span data-stu-id="f5a24-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="f5a24-967">Krypterings metoder för Elliptic kurv grupper:</span><span class="sxs-lookup"><span data-stu-id="f5a24-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="f5a24-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="f5a24-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="f5a24-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="f5a24-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="f5a24-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="f5a24-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="f5a24-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="f5a24-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="f5a24-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="f5a24-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="f5a24-973">Krypterings metoder för ECC-kurvor definieras i nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="f5a24-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="f5a24-974">Krypterings metod för ECDHE:</span><span class="sxs-lookup"><span data-stu-id="f5a24-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="f5a24-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="f5a24-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="f5a24-976">Krypterings metod för ECDSA:</span><span class="sxs-lookup"><span data-stu-id="f5a24-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="f5a24-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="f5a24-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="f5a24-978">ECDSA-och ECDHE-krypterings metoder definieras i nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="f5a24-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="f5a24-979">Kombineras med andra krypterings metoder som RSA, SHA, AES, och de kan användas som bygg stenar för ciphersuite lookup-tabellen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="f5a24-980">Aktivera ECC-stöd för TLS</span><span class="sxs-lookup"><span data-stu-id="f5a24-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="f5a24-981">ECC är aktiverat som standard för TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="f5a24-982">För att inaktivera ECC-stöd måste symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE definieras.</span><span class="sxs-lookup"><span data-stu-id="f5a24-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="f5a24-983">För att ändringen ska börja gälla måste du återskapa NetX Secure-biblioteket och alla program som använder det biblioteket.</span><span class="sxs-lookup"><span data-stu-id="f5a24-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="f5a24-984">I program koden måste API n *x_secure_tls_ecc_initialize ()* anropas när TLS-sessionen har skapats.</span><span class="sxs-lookup"><span data-stu-id="f5a24-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="f5a24-985">Detta API meddelar TLS-sessionen av den typ av kurvor som ska användas för TLS-nyckelns utbytes åtgärder och certifikat verifiering.</span><span class="sxs-lookup"><span data-stu-id="f5a24-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="f5a24-986">Om en ECC-algoritm har valts under fasen TLS-handskakning, kan du bestämma vilken kurva som ska användas om du väljer en ECC-algoritm för klient och server.</span><span class="sxs-lookup"><span data-stu-id="f5a24-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="f5a24-987">Följande kod segment illustrerar hur du använder API: et.</span><span class="sxs-lookup"><span data-stu-id="f5a24-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="f5a24-988">Observera att argumenten (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size och nx_crypto_ecc_curves)* är definierade i *nx_crypto_generic_ciphersuites. c*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="f5a24-989">Dessa symboler kan därför användas direkt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="f5a24-990">Exempel konfigurationen i nx_crypto_generic_ciphersuites. c innehåller en uppslags tabell för ECC-ciphersuite som används när ECC är aktiverat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="f5a24-991">Om du vill använda ECC kan du bara skicka nx_crypto_tls_ciphers_ecc som tabell parameter för ciphersuite när du skapar TLS-sessioner med nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="f5a24-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="f5a24-992">Tabellen exempel innehåller både ECC-och Non-ECC-krypteringssviter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="f5a24-993">TLS-kryptografisk chiffrering tabell</span><span class="sxs-lookup"><span data-stu-id="f5a24-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="f5a24-994">NX_SECURE_TLS_CRYPTOs strukturen definieras som:</span><span class="sxs-lookup"><span data-stu-id="f5a24-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="f5a24-995">Tabellen skapas genom att fylla i posterna för den här strukturen i en statisk konstant som finns i NetX Secure TLS-projektet, som vanligt vis finns i de kryptografiska rutinerna och modulerna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="f5a24-996">Det kryptografiska biblioteket ("generisk") som tillhandahålls med NetX Secure innehåller följande tabell definition (för icke-ECC ciphersuite support<sup>19</sup>):</span><span class="sxs-lookup"><span data-stu-id="f5a24-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="f5a24-997">Den första posten i strukturen är TLS ciphersuite-tabellen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="f5a24-998">NX_SECURE_TLS_CIPHERSUITE_INFOs strukturen mappar kryptografiska rutiner (i form av NX_CRYPTO_METHOD pekare) till särskilda krypteringssviter som definieras i TLS-specifikationerna.</span><span class="sxs-lookup"><span data-stu-id="f5a24-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="f5a24-999">Det andra värdet är antalet poster i tabellen som det första fältet pekar på.</span><span class="sxs-lookup"><span data-stu-id="f5a24-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="f5a24-1000">Nästa fält pekar på en tabell med rutiner som används av X. 509 vid bearbetning av digitala certifikat och struktur NX_SECURE_X509_CRYPTO liknar i formulär för att NX_SECURE_TLS_CIPHERSUITE_INFO.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="f5a24-1001">Följande fält är antalet poster i tabellen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="f5a24-1002">Följande uppslags tabell är ett antal rutiner som behövs för vissa versioner av TLS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="f5a24-1003">Till exempel, före TLS version 1,2, har hash-rutiner för nyckel generering och hand skakning åtgärd ATS för att använda en kombination av SHA-1 och MD5 – metoderna för dessa rutiner kallas särskilt i chiffrering eftersom de inte är kopplade till specifika krypteringssviter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="f5a24-1004">I TLS version 1,2 väljs ciphersuite och hashing-rutinerna av, men för krypteringssviter som inte anger vilka rutiner som ska användas används hash-metoden SHA-256, och chiffrering anropar den rutinen specifikt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="f5a24-1005">TLS 1,3 kräver några extra särskilda chiffer för olika åtgärder.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="f5a24-1006">Observera att TLS 1,3-stöd kräver ECC – Använd nx_crypto_tls_ciphers_ecc om TLS 1,3 har Aktiver ATS.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="f5a24-1007">Uppslags tabell för TLS-Ciphersuite</span><span class="sxs-lookup"><span data-stu-id="f5a24-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="f5a24-1008">Om du vill fylla i tabellen Cipher för TLS, måste du också skapa en ciphersuite lookup-tabell som mappar kryptografiska rutiner till vissa ciphersuite-identifierare.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="f5a24-1009">Identifierarna är IANA-registrerade värden som är universella.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="f5a24-1010">Mer information finns i avsnittet om TLS-rapporter.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="f5a24-1011">Rutinerna representerar 5 separata metoder som används i varje ciphersuite (vissa krypteringssviter får inte använda alla 5): offentligt chiffer, offentlig nyckel autentisering, session-chiffer, sessions-hash-rutin och TLS-Pseudo-Random funktion (PRF).</span><span class="sxs-lookup"><span data-stu-id="f5a24-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="f5a24-1012">I följande tabell förklaras var och en av de fem metoderna:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="f5a24-1013">**Rutin kategori**</span><span class="sxs-lookup"><span data-stu-id="f5a24-1013">**Routine category**</span></span>      | <span data-ttu-id="f5a24-1014">**Beskrivning**</span><span class="sxs-lookup"><span data-stu-id="f5a24-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="f5a24-1015">**Exempel på algoritmer**</span><span class="sxs-lookup"><span data-stu-id="f5a24-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="f5a24-1016">Offentligt chiffer</span><span class="sxs-lookup"><span data-stu-id="f5a24-1016">Public cipher</span></span>             | <span data-ttu-id="f5a24-1017">Används för att byta nycklar under TLS-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="f5a24-1018">RSA, Diffie-Hellman, ECC</span><span class="sxs-lookup"><span data-stu-id="f5a24-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="f5a24-1019">Offentlig nyckel autentisering</span><span class="sxs-lookup"><span data-stu-id="f5a24-1019">Public-key authentication</span></span> | <span data-ttu-id="f5a24-1020">Används för att autentisera eller signera data under TLS-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="f5a24-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="f5a24-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="f5a24-1022">Chiffrering av session</span><span class="sxs-lookup"><span data-stu-id="f5a24-1022">Session cipher</span></span>            | <span data-ttu-id="f5a24-1023">Algoritmer för symmetrisk nyckel som används för att kryptera program data under TLS-sessionen</span><span class="sxs-lookup"><span data-stu-id="f5a24-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="f5a24-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="f5a24-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="f5a24-1025">Sessions-hash</span><span class="sxs-lookup"><span data-stu-id="f5a24-1025">Session hash</span></span>              | <span data-ttu-id="f5a24-1026">Används för att bevara integriteten hos meddelanden under TLS-sessionen (säkerställer att data inte har ändrats)</span><span class="sxs-lookup"><span data-stu-id="f5a24-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="f5a24-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="f5a24-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="f5a24-1028">TLS-PRF</span><span class="sxs-lookup"><span data-stu-id="f5a24-1028">TLS PRF</span></span>                   | <span data-ttu-id="f5a24-1029">Används för att generera nyckel material och i hand skaknings-hashvärdet i TLS-handskakning</span><span class="sxs-lookup"><span data-stu-id="f5a24-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="f5a24-1030">PRF baseras på hash-rutiner – SHA-1 + MD5, SHA-256, SHA-512</span><span class="sxs-lookup"><span data-stu-id="f5a24-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="f5a24-1031">NX_SECURE_TLS_CIPHERSUITE_INFOs strukturen definieras enligt följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="f5a24-1032">Fältet nx_secure_tls_ciphersuite innehåller värdet för IANA-ciphersuite och NX_CRYPTO_METHODs pekare representerar de 5 metoder som används av ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="f5a24-1033">De skalära värdena (nx_secure_tls_iv_size, nx_secure_tls_key_size och nx_secure_tls_hash_size) är information och ger information som kanske inte är tillgänglig i NX_CRYPTO_METHOD poster.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="f5a24-1034">Som exempel kommer vi att titta på standard ciphersuite för TLS, TLS_RSA_WITH_AES_128_CBC_SHA, som anger användningen av RSA-, AES-CBC med 128-bitars nycklar och SHA-1 för sessions-hashing.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="f5a24-1035">Ingen TLS-PRF har angetts för den här ciphersuite, så i TLSv 1.2-läge används standard SHA-256-PRF.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="f5a24-1036">Observera att alla krypteringssviter använder SHA-1 + MD5 PRF i TLS 1,0 och 1,1, oavsett vilken PRF som anges i tabellen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="f5a24-1037">Posten i NX_SECURE_TLS_CIPHERSUITE_INFOs tabellen i det generiska kryptografi biblioteket definieras enligt följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="f5a24-1038">Observera att nyckel storleken för-sessionen avgörs av ciphersuite, men för offentliga nyckel metoder är nyckel storleken inte känd förrän TLS-handskakningen är igång sedan de offentliga nycklarna finns i de digitala certifikat som utbyts under hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="f5a24-1039">X. 509 chiffer-uppslags tabell</span><span class="sxs-lookup"><span data-stu-id="f5a24-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="f5a24-1040">Precis som NX_SECURE_TLS_CIPHERSUITE_INFO tabell mappar NX_SECURE_X509_CRYPTOs strukturen kryptografiska rutiner till kända värden.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="f5a24-1041">Om det gäller X. 509 är identifierarna egentligen de OID: er som definierats av X. 509 och som registrerats med ISO-och ITU-standard-organen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="f5a24-1042">OID är värden för flera byte i varierande längd som är utformade för att unikt identifiera olika uppgifter i olika telekommunikations standarder, inklusive kryptografiska rutiner som används i digitala certifikat.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="f5a24-1043">På grund av det faktum att OID är varierande längd mappar NetX Secure TLS de officiella OID-värdena till konstanter med fast längd som används internt (se nx_secure_x509. h).</span><span class="sxs-lookup"><span data-stu-id="f5a24-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="f5a24-1044">Dessa konstanter används i NX_SECURE_X509_CRYPTOs strukturen, som definieras enligt följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="f5a24-1045">Det första fältet *nx_secure_x509_crypto_identifier* är den interna OID-representation som används av netx Secure.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="f5a24-1046">Det andra och tredje fältet pekar på NX_CRYPTO_METHOD objekt som representerar de kryptografiska metoder som identifieras av OID: en offentlig nyckel åtgärd som kopplats till en hash-rutin.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="f5a24-1047">Observera att varje digitalt certifikat kan ha mer än en OID för kryptografiska rutiner.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="f5a24-1048">Metod tabellen för X. 509 är konstruerad på samma sätt som ciphersuite lookup-tabellen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="f5a24-1049">Som exempel kommer vi att titta på OID för RSA_SHA1.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="f5a24-1050">Det faktiska OID-värde för RSA_SHA1 är följande:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="f5a24-1051">OID: en visas i ASN. 1-syntax och har ett numeriskt värde för 1.2.840.113549.1.1.5.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="f5a24-1052">Värdet kodas sedan i binärt format, vilket skapar följande byte:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="f5a24-1053">Den faktiska konverteringen från ASN. 1 till binärformatet ligger utanför det här dokumentets omfattning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="f5a24-1054">Sök efter ASN. 1-kodningar för OID: er för mer information.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="f5a24-1055">Den binära representationen av OID som stöds av NetX Secure finns i filen *nx_secure_x509. c*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="f5a24-1056">När vi har en mappning av den faktiska OID-identifieraren till en internt känd konstant, kan vi skapa en post för RSA_SHA1 i tabellen NX_SECURE_X509_CRYPTO:</span><span class="sxs-lookup"><span data-stu-id="f5a24-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="f5a24-1057">Standard-TLS-rutiner</span><span class="sxs-lookup"><span data-stu-id="f5a24-1057">Default TLS Routines</span></span>

<span data-ttu-id="f5a24-1058">Som nämnts ovan kräver TLS vissa standard rutiner för generering av nycklar och meddelande verifiering under hand skakningen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="f5a24-1059">Den primära rutinen är TLS-Pseudo-Random funktion eller PRF.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="f5a24-1060">PRF baseras på hash-rutiner och kan användas för att generera en godtycklig mängd pseudo-slumpmässiga data<sup>20</sup> för nyckel skapande eller andra användnings sätt.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="f5a24-1061">Förutom PRF använder varje version av TLS standard-hash-rutiner som också måste tillhandahållas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="f5a24-1062">För TLS-versionerna 1,0 och 1,1 är dessa hash-rutiner MD5 och SHA-1.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="f5a24-1063">TLS version 1,2 kräver endast SHA-256.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="f5a24-1064">I NX_SECURE_TLS_CRYPTOs strukturen finns NX_CRYPTO_METHOD pekare för MD5, SHA-1, SHA-256, TLS-version 1.0/1.1 PRF och standard-TLS 1,2-PRF.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="f5a24-1065">TLS 1,3-stöd lägger till fält för HKDF (nyckel generering), HMAC (för vissa hash-åtgärder som används under hand skakningen) och ECDHE (krävs för TLS 1,3-funktioner).</span><span class="sxs-lookup"><span data-stu-id="f5a24-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="f5a24-1066">Som tillhandahålls i det allmänna biblioteket för program varu kryptografi är program varu versioner av TLS PRF.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="f5a24-1067">För TLS 1.0/1.1 kallas den här funktionen *nx_crypto_tls_prf_1*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="f5a24-1068">För TLS 1,2 kallas funktionen *nx_secure_tls_prf_sha256*.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="f5a24-1069">Suffixet "1" representerar den äldre-TLS 1,0-PRFen och "SHA256"-suffixet avser det faktum att TLS 1,2 standard PRF baseras på SHA-256.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="f5a24-1070">När stöd för andra PRF-rutiner behövs kommer suffixet för dessa rutiner att avspegla den hash-metod som används.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="f5a24-1071">Eftersom PRF-rutinerna baseras på hash-metoder kan de underliggande hash-rutinerna i maskin vara accelereras oberoende på olika plattformar.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="f5a24-1072">Förutom uppslags tabellerna TLS ciphersuite och X. 509, med standard-PRF-och hash-rutiner som är fyllda i NX_SECURE_TLS_CRYPTOs strukturen, kan fyllas och användas för att initiera en TLS-session.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="f5a24-1073">"Pseudo-slumpmässig" syftar på det faktum att PRF är deterministisk, vilket innebär att det alltid kommer att producera samma utdata med samma indata, men slumpmässigt i det faktum att utdata inte är förutsägbara.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="f5a24-1074">TLS använder den här egenskapen i PRF för att generera sessionsnycklar från olika offentliga data tillsammans med huvud hemligheten som utbyts under hand skakningen med hjälp av en offentlig nyckel chiffer som RSA.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="f5a24-1075">Kryptografiska metadata</span><span class="sxs-lookup"><span data-stu-id="f5a24-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="f5a24-1076">Innan vi kan initiera TLS-sessionen med NX_SECURE_TLS_CRYPTO-tabellen måste vi allokera buffertutrymme för metadata för den kryptografiska rutinen.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="f5a24-1077">Metadata används för att lagra all status som är kopplad till en viss rutin som representeras av kontroll blocket.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="f5a24-1078">*Nx_crypto_metadata_area_sizes* fältet för varje NX_CRYPTO_METHOD måste anges till storleken på den kontroll struktur som är kopplad till den rutinen eller så kan TLS-initieringen inte användas korrekt för det utrymme som behövs, vilket kan orsaka buffertöverskridning.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="f5a24-1079">Innan TLS-sessionen skapas måste bufferten för metadata tilldelas.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="f5a24-1080">Bufferten delas automatiskt upp av nx_secure_tls_session_create och utrymmet är reserverat för var och en av de rutiner som finns i tabellen med kryptografiska metoder.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="f5a24-1081">Observera att eftersom endast en ciphersuite är aktiv i taget i en TLS-session, påverkar inte antalet krypteringssviter som behövs – utrymmet är reserverat för var och en av de fem ciphersuite-rutinerna med den maximala kontroll block storleken för den kategorin i tabellen ciphersuite lookup.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="f5a24-1082">För att göra det enkelt att beräkna buffertstorleken utför tjänsten *nx_secure_metadata_size_calculate* samma beräkningar som nx_secure_tls_session_create men returnerar bara den sammanlagda buffertstorleken för metadata som krävs i byte.</span><span class="sxs-lookup"><span data-stu-id="f5a24-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="f5a24-1083">Initiera TLS-sessionen</span><span class="sxs-lookup"><span data-stu-id="f5a24-1083">Initializing the TLS session</span></span>

<span data-ttu-id="f5a24-1084">När NX_CRYPTO_METHOD och NX_SECURE_TLS_CRYPTO objekt har skapats och metadata-ytan reserverat, kan vi initiera en TLS-session enligt följande (värden som tas från ovanstående exempel):</span><span class="sxs-lookup"><span data-stu-id="f5a24-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
